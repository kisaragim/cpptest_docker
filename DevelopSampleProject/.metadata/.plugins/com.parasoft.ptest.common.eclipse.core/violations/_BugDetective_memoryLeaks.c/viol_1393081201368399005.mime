MIME-Version: 1.0
Content-Type: multipart/mixed; boundary=Sg7K1FI4l1sgCNil90NEdlqXk518AQo
StorageVersion: v1

--Sg7K1FI4l1sgCNil90NEdlqXk518AQo

<?xml version='1.0' encoding='UTF-8'?><ResultsList path="/BugDetective/memoryLeaks.c"><VersionInfos><StorageInfo ownerId="com.parasoft.xtest.checkers.api.execution" resultId="IExecutionViolation" ver="2"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.execution" resultId="InsureViolation" ver="3"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.scope" resultId="IScopeProjectInfo" ver="3"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IMetricsViolation" ver="2"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IDupCodeViolation" ver="2"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IMetricEstimationInfo" ver="2"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IFlowAnalysisViolation" ver="2"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="ICodingStandardsViolation" ver="2"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.generation" resultId="IGenerationInfo" ver="2"/><StorageInfo ownerId="com.parasoft.xtest.checkers.api.generation" resultId="IGenerationProjectInfo" ver="2"/></VersionInfos></ResultsList>
--Sg7K1FI4l1sgCNil90NEdlqXk518AQo

<?xml version='1.0' encoding='UTF-8'?><ResultInfo resultId="IFlowAnalysisViolation" ownerId="com.parasoft.xtest.checkers.api.standards" violKeys="71_/BugDetective/memoryLeaks.c;68_/BugDetective/memoryLeaks.c;72_/BugDetective/memoryLeaks.c;70_/BugDetective/memoryLeaks.c;69_/BugDetective/memoryLeaks.c"><FlowViol msg="Memory not deallocated: pointer" ln="40" ruleSAFMsg="Point where allocated memory is lost" auth="root" sev="4" rule="MISRAC2012-DIR_4_13-a" ruleSCSCMsg="Point where memory is allocated" tool="c++test" id="525280961" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="40" locStartPos="0" locEndLn="41" locEndPos="0" locFile="/BugDetective/memoryLeaks.c" FirstElSrcRngStartln="40" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="41" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/BugDetective/memoryLeaks.c"><Props><Prop key="Tracked variables" val="Allocated memory"/></Props><ElDescList><ElDesc srcRngStartln="34" srcRngStartPos="0" srcRngEndLn="35" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="34" ElType="." desc="int count = 0;" rngLn="34"><Props/></ElDesc><ElDesc srcRngStartln="35" srcRngStartPos="0" srcRngEndLn="36" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="35" ElType="." desc="int LOOPS = 100;" rngLn="35"><Props/></ElDesc><ElDesc srcRngStartln="36" srcRngStartPos="0" srcRngEndLn="37" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="36" ElType="." desc="int MAXSIZE = 100;" rngLn="36"><Props/></ElDesc><ElDesc srcRngStartln="37" srcRngStartPos="0" srcRngEndLn="38" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="37" ElType="." desc="char *pointer = NULL;" rngLn="37"><Props/></ElDesc><ElDesc srcRngStartln="39" srcRngStartPos="0" srcRngEndLn="40" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="39" ElType="." desc="for(count=0; count &lt; LOOPS; count++) {" rngLn="39"><Props/><Anns><Ann msg="Loop condition evaluation: (count &lt; LOOPS) (true)" kind="condEval"/><Ann msg="Entering the loop" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="40" ElType=".C" desc="malloc(...)" rngLn="40"><Props><Prop key="Tracked variables" val="malloc(...)"/></Props><Anns><Ann msg="Point where memory is allocated" kind="cause"/><Ann msg="Allocated memory: malloc(...)" kind="var"/></Anns></ElDesc><ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="40" ElType="!" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" rngLn="40"><Props/></ElDesc><ElDesc srcRngStartln="39" srcRngStartPos="0" srcRngEndLn="40" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="39" ElType="." desc="for(count=0; count &lt; LOOPS; count++) {" rngLn="39"><Props><Prop key="Tracked variables" val="pointer"/></Props><Anns><Ann msg="Allocated memory: pointer" kind="var"/><Ann msg="Loop condition evaluation: (count &lt; LOOPS) (assuming true)" kind="condEval"/><Ann msg="Entering the loop" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="40" ElType=".P" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" rngLn="40"><Props><Prop key="Tracked variables" val="pointer"/></Props><Anns><Ann msg="Allocated memory: pointer" kind="var"/><Ann msg="Point where allocated memory is lost" kind="point"/></Anns></ElDesc></ElDescList></FlowViol><FlowViol msg="Memory not deallocated: p" ln="26" ruleSAFMsg="Point where allocated memory is lost" auth="root" sev="2" rule="MISRAC2012-RULE_22_1-a" ruleSCSCMsg="Point where memory is allocated" tool="c++test" id="585789567" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="26" locStartPos="0" locEndLn="27" locEndPos="0" locFile="/BugDetective/memoryLeaks.c" FirstElSrcRngStartln="18" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="19" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/BugDetective/memoryLeaks.c"><Props><Prop key="Tracked variables" val="Allocated memory"/></Props><ElDescList><ElDesc srcRngStartln="12" srcRngStartPos="0" srcRngEndLn="13" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="12" ElType="." desc="char *c;" rngLn="12"><Props/></ElDesc><ElDesc srcRngStartln="13" srcRngStartPos="0" srcRngEndLn="14" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="13" ElType="." desc="char buf[100];" rngLn="13"><Props/></ElDesc><ElDesc srcRngStartln="14" srcRngStartPos="0" srcRngEndLn="15" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="14" ElType="." desc="int id = 0;" rngLn="14"><Props/></ElDesc><ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="15" ElType="." desc="while(1) {" rngLn="15"><Props/><Anns><Ann msg="Loop condition evaluation: 1 (true)" kind="condEval"/><Ann msg="Entering the loop" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="16" ElType="." desc="c = fgets(buf, 100, file);" rngLn="16"><Props/></ElDesc><ElDesc srcRngStartln="17" srcRngStartPos="0" srcRngEndLn="18" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="17" ElType="." desc="if (c!=NULL) {" rngLn="17"><Props/><Anns><Ann msg="Condition evaluation: (c != 0) (assuming true)" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="18" srcRngStartPos="0" srcRngEndLn="19" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="18" ElType=".C" desc="malloc(...)" rngLn="18"><Props><Prop key="Tracked variables" val="malloc(...)"/></Props><Anns><Ann msg="Point where memory is allocated" kind="cause"/><Ann msg="Allocated memory: malloc(...)" kind="var"/></Anns></ElDesc><ElDesc srcRngStartln="18" srcRngStartPos="0" srcRngEndLn="19" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="18" ElType="!" desc="Person* p = malloc(sizeof(Person));" rngLn="18"><Props/></ElDesc><ElDesc srcRngStartln="19" srcRngStartPos="0" srcRngEndLn="20" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="19" ElType="." desc="if (p == 0) exit(1);" rngLn="19"><Props><Prop key="Tracked variables" val="p"/></Props><Anns><Ann msg="Allocated memory: p" kind="var"/><Ann msg="Condition evaluation: (p == 0) (assuming false)" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="20" srcRngStartPos="0" srcRngEndLn="21" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="20" ElType="." desc="p->personalId = ++id;" rngLn="20"><Props/></ElDesc><ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="21" ElType="." desc="p->name = buf;" rngLn="21"><Props/></ElDesc><ElDesc srcRngStartln="22" srcRngStartPos="0" srcRngEndLn="23" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="22" ElType="." desc="storePerson(p);" rngLn="22"><Props/></ElDesc><ElDesc srcRngStartln="26" srcRngStartPos="0" srcRngEndLn="27" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="26" ElType=".P" desc="} else {" rngLn="26"><Props><Prop key="Tracked variables" val="p"/></Props><Anns><Ann msg="Allocated memory: p" kind="var"/><Ann msg="Point where allocated memory is lost" kind="point"/></Anns></ElDesc></ElDescList></FlowViol><FlowViol msg="Value returned from method &quot;malloc&quot; should be checked" ln="44" ruleSAFMsg="Point by which returned value should be checked" auth="root" sev="2" rule="MISRAC2012-DIR_4_7-b" ruleSCSCMsg="Method call" tool="c++test" id="1381748893" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="44" locStartPos="0" locEndLn="45" locEndPos="0" locFile="/BugDetective/memoryLeaks.c" FirstElSrcRngStartln="40" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="41" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/BugDetective/memoryLeaks.c"><Props/><ElDescList><ElDesc srcRngStartln="34" srcRngStartPos="0" srcRngEndLn="35" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="34" ElType="." desc="int count = 0;" rngLn="34"><Props/></ElDesc><ElDesc srcRngStartln="35" srcRngStartPos="0" srcRngEndLn="36" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="35" ElType="." desc="int LOOPS = 100;" rngLn="35"><Props/></ElDesc><ElDesc srcRngStartln="36" srcRngStartPos="0" srcRngEndLn="37" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="36" ElType="." desc="int MAXSIZE = 100;" rngLn="36"><Props/></ElDesc><ElDesc srcRngStartln="37" srcRngStartPos="0" srcRngEndLn="38" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="37" ElType="." desc="char *pointer = NULL;" rngLn="37"><Props/></ElDesc><ElDesc srcRngStartln="39" srcRngStartPos="0" srcRngEndLn="40" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="39" ElType="." desc="for(count=0; count &lt; LOOPS; count++) {" rngLn="39"><Props/><Anns><Ann msg="Loop condition evaluation: (count &lt; LOOPS) (true)" kind="condEval"/><Ann msg="Entering the loop" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="40" ElType=".C" desc="malloc(...)" rngLn="40"><Props/><Anns><Ann msg="Method call" kind="cause"/></Anns></ElDesc><ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="40" ElType="." desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" rngLn="40"><Props/></ElDesc><ElDesc srcRngStartln="39" srcRngStartPos="0" srcRngEndLn="40" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="39" ElType="." desc="for(count=0; count &lt; LOOPS; count++) {" rngLn="39"><Props/><Anns><Ann msg="Loop condition evaluation: (count &lt; LOOPS) (assuming false)" kind="condEval"/><Ann msg="Not entering the loop" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="44" srcRngStartPos="0" srcRngEndLn="45" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="44" ElType=".P" desc="free(pointer);" rngLn="44"><Props/><Anns><Ann msg="Point by which returned value should be checked" kind="point"/></Anns></ElDesc></ElDescList></FlowViol><FlowViol msg="Memory not deallocated: pointer" ln="40" ruleSAFMsg="Point where allocated memory is lost" auth="root" sev="2" rule="MISRAC2012-RULE_22_1-a" ruleSCSCMsg="Point where memory is allocated" tool="c++test" id="525280961" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="40" locStartPos="0" locEndLn="41" locEndPos="0" locFile="/BugDetective/memoryLeaks.c" FirstElSrcRngStartln="40" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="41" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/BugDetective/memoryLeaks.c"><Props><Prop key="Tracked variables" val="Allocated memory"/></Props><ElDescList><ElDesc srcRngStartln="34" srcRngStartPos="0" srcRngEndLn="35" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="34" ElType="." desc="int count = 0;" rngLn="34"><Props/></ElDesc><ElDesc srcRngStartln="35" srcRngStartPos="0" srcRngEndLn="36" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="35" ElType="." desc="int LOOPS = 100;" rngLn="35"><Props/></ElDesc><ElDesc srcRngStartln="36" srcRngStartPos="0" srcRngEndLn="37" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="36" ElType="." desc="int MAXSIZE = 100;" rngLn="36"><Props/></ElDesc><ElDesc srcRngStartln="37" srcRngStartPos="0" srcRngEndLn="38" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="37" ElType="." desc="char *pointer = NULL;" rngLn="37"><Props/></ElDesc><ElDesc srcRngStartln="39" srcRngStartPos="0" srcRngEndLn="40" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="39" ElType="." desc="for(count=0; count &lt; LOOPS; count++) {" rngLn="39"><Props/><Anns><Ann msg="Loop condition evaluation: (count &lt; LOOPS) (true)" kind="condEval"/><Ann msg="Entering the loop" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="40" ElType=".C" desc="malloc(...)" rngLn="40"><Props><Prop key="Tracked variables" val="malloc(...)"/></Props><Anns><Ann msg="Point where memory is allocated" kind="cause"/><Ann msg="Allocated memory: malloc(...)" kind="var"/></Anns></ElDesc><ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="40" ElType="!" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" rngLn="40"><Props/></ElDesc><ElDesc srcRngStartln="39" srcRngStartPos="0" srcRngEndLn="40" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="39" ElType="." desc="for(count=0; count &lt; LOOPS; count++) {" rngLn="39"><Props><Prop key="Tracked variables" val="pointer"/></Props><Anns><Ann msg="Allocated memory: pointer" kind="var"/><Ann msg="Loop condition evaluation: (count &lt; LOOPS) (assuming true)" kind="condEval"/><Ann msg="Entering the loop" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="40" srcRngStartPos="0" srcRngEndLn="41" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="40" ElType=".P" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" rngLn="40"><Props><Prop key="Tracked variables" val="pointer"/></Props><Anns><Ann msg="Allocated memory: pointer" kind="var"/><Ann msg="Point where allocated memory is lost" kind="point"/></Anns></ElDesc></ElDescList></FlowViol><FlowViol msg="Memory not deallocated: p" ln="26" ruleSAFMsg="Point where allocated memory is lost" auth="root" sev="4" rule="MISRAC2012-DIR_4_13-a" ruleSCSCMsg="Point where memory is allocated" tool="c++test" id="585789567" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="26" locStartPos="0" locEndLn="27" locEndPos="0" locFile="/BugDetective/memoryLeaks.c" FirstElSrcRngStartln="18" FirstElSrcRngStartPos="0" FirstElSrcRngEndLn="19" FirstElSrcRngEndPos="0" FirstElSrcRngFile="/BugDetective/memoryLeaks.c"><Props><Prop key="Tracked variables" val="Allocated memory"/></Props><ElDescList><ElDesc srcRngStartln="12" srcRngStartPos="0" srcRngEndLn="13" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="12" ElType="." desc="char *c;" rngLn="12"><Props/></ElDesc><ElDesc srcRngStartln="13" srcRngStartPos="0" srcRngEndLn="14" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="13" ElType="." desc="char buf[100];" rngLn="13"><Props/></ElDesc><ElDesc srcRngStartln="14" srcRngStartPos="0" srcRngEndLn="15" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="14" ElType="." desc="int id = 0;" rngLn="14"><Props/></ElDesc><ElDesc srcRngStartln="15" srcRngStartPos="0" srcRngEndLn="16" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="15" ElType="." desc="while(1) {" rngLn="15"><Props/><Anns><Ann msg="Loop condition evaluation: 1 (true)" kind="condEval"/><Ann msg="Entering the loop" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="16" srcRngStartPos="0" srcRngEndLn="17" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="16" ElType="." desc="c = fgets(buf, 100, file);" rngLn="16"><Props/></ElDesc><ElDesc srcRngStartln="17" srcRngStartPos="0" srcRngEndLn="18" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="17" ElType="." desc="if (c!=NULL) {" rngLn="17"><Props/><Anns><Ann msg="Condition evaluation: (c != 0) (assuming true)" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="18" srcRngStartPos="0" srcRngEndLn="19" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="18" ElType=".C" desc="malloc(...)" rngLn="18"><Props><Prop key="Tracked variables" val="malloc(...)"/></Props><Anns><Ann msg="Point where memory is allocated" kind="cause"/><Ann msg="Allocated memory: malloc(...)" kind="var"/></Anns></ElDesc><ElDesc srcRngStartln="18" srcRngStartPos="0" srcRngEndLn="19" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="18" ElType="!" desc="Person* p = malloc(sizeof(Person));" rngLn="18"><Props/></ElDesc><ElDesc srcRngStartln="19" srcRngStartPos="0" srcRngEndLn="20" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="19" ElType="." desc="if (p == 0) exit(1);" rngLn="19"><Props><Prop key="Tracked variables" val="p"/></Props><Anns><Ann msg="Allocated memory: p" kind="var"/><Ann msg="Condition evaluation: (p == 0) (assuming false)" kind="condEval"/></Anns></ElDesc><ElDesc srcRngStartln="20" srcRngStartPos="0" srcRngEndLn="21" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="20" ElType="." desc="p->personalId = ++id;" rngLn="20"><Props/></ElDesc><ElDesc srcRngStartln="21" srcRngStartPos="0" srcRngEndLn="22" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="21" ElType="." desc="p->name = buf;" rngLn="21"><Props/></ElDesc><ElDesc srcRngStartln="22" srcRngStartPos="0" srcRngEndLn="23" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="22" ElType="." desc="storePerson(p);" rngLn="22"><Props/></ElDesc><ElDesc srcRngStartln="26" srcRngStartPos="0" srcRngEndLn="27" srcRngEndPos="0" srcRngFile="/BugDetective/memoryLeaks.c" srcRnghash="1502549011" ln="26" ElType=".P" desc="} else {" rngLn="26"><Props><Prop key="Tracked variables" val="p"/></Props><Anns><Ann msg="Allocated memory: p" kind="var"/><Ann msg="Point where allocated memory is lost" kind="point"/></Anns></ElDesc></ElDescList></FlowViol></ResultInfo>
--Sg7K1FI4l1sgCNil90NEdlqXk518AQo

<?xml version='1.0' encoding='UTF-8'?><ResultInfo resultId="ICodingStandardsViolation" ownerId="com.parasoft.xtest.checkers.api.standards" violKeys="297_/BugDetective/memoryLeaks.c;301_/BugDetective/memoryLeaks.c;279_/BugDetective/memoryLeaks.c;287_/BugDetective/memoryLeaks.c;282_/BugDetective/memoryLeaks.c;296_/BugDetective/memoryLeaks.c;291_/BugDetective/memoryLeaks.c;298_/BugDetective/memoryLeaks.c;305_/BugDetective/memoryLeaks.c;306_/BugDetective/memoryLeaks.c;285_/BugDetective/memoryLeaks.c;300_/BugDetective/memoryLeaks.c;290_/BugDetective/memoryLeaks.c;280_/BugDetective/memoryLeaks.c;289_/BugDetective/memoryLeaks.c;299_/BugDetective/memoryLeaks.c;304_/BugDetective/memoryLeaks.c;278_/BugDetective/memoryLeaks.c;281_/BugDetective/memoryLeaks.c;288_/BugDetective/memoryLeaks.c;292_/BugDetective/memoryLeaks.c;293_/BugDetective/memoryLeaks.c;303_/BugDetective/memoryLeaks.c;284_/BugDetective/memoryLeaks.c;286_/BugDetective/memoryLeaks.c;294_/BugDetective/memoryLeaks.c;283_/BugDetective/memoryLeaks.c;295_/BugDetective/memoryLeaks.c;302_/BugDetective/memoryLeaks.c"><StdViol msg="Function 'simpleLeakInCycle' is not in prototype form" ln="32" sev="2" auth="root" rule="MISRAC2012-RULE_8_2-c" tool="c++test" cat="MISRAC2012-RULE_8_2" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="32" locStartPos="5" locEndLn="32" locEndPos="6" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Pointer to void type should not be converted to pointer to object type 'char *'" ln="40" sev="4" auth="root" rule="MISRAC2012-RULE_11_5-a" tool="c++test" cat="MISRAC2012-RULE_11_5" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="40" locStartPos="18" locEndLn="40" locEndPos="19" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="The function 'storePerson' is referenced only in the translation unit where it is defined" ln="5" sev="4" auth="root" rule="MISRAC2012-RULE_8_7-a" tool="c++test" cat="MISRAC2012-RULE_8_7" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="'malloc' function should not be used" ln="18" sev="2" auth="root" rule="MISRAC2012-DIR_4_12-a" tool="c++test" cat="MISRAC2012-DIR_4_12" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="18" locStartPos="24" locEndLn="18" locEndPos="25" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Prototype of function 'printPersonInfo' does not precede function definition" ln="10" sev="2" auth="root" rule="MISRAC2012-RULE_8_4-a" tool="c++test" cat="MISRAC2012-RULE_8_4" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="10" locStartPos="5" locEndLn="10" locEndPos="6" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Function 'simpleLeakInCycle' is not in prototype form" ln="32" sev="2" auth="root" rule="MISRAC2012-RULE_1_5-c" tool="c++test" cat="MISRAC2012-RULE_1_5" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="32" locStartPos="5" locEndLn="32" locEndPos="6" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Function 'exit' should be called at the end of the 'printPersonInfo' function" ln="19" sev="4" auth="root" rule="MISRAC2012-RULE_15_5-a" tool="c++test" cat="MISRAC2012-RULE_15_5" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="19" locStartPos="24" locEndLn="19" locEndPos="25" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="The basic numerical type 'int' should not be used" ln="34" sev="4" auth="root" rule="MISRAC2012-DIR_4_6-b" tool="c++test" cat="MISRAC2012-DIR_4_6" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="34" locStartPos="4" locEndLn="34" locEndPos="5" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="'free' function should not be used" ln="44" sev="2" auth="root" rule="MISRAC2012-RULE_21_3-a" tool="c++test" cat="MISRAC2012-RULE_21_3" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="44" locStartPos="4" locEndLn="44" locEndPos="5" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="'free' function should not be used" ln="44" sev="2" auth="root" rule="MISRAC2012-DIR_4_12-a" tool="c++test" cat="MISRAC2012-DIR_4_12" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="44" locStartPos="4" locEndLn="44" locEndPos="5" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Pointer to void type should not be converted to pointer to object type 'Person *'" ln="18" sev="4" auth="root" rule="MISRAC2012-RULE_11_5-a" tool="c++test" cat="MISRAC2012-RULE_11_5" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="18" locStartPos="20" locEndLn="18" locEndPos="21" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="The basic numerical type 'int' should not be used" ln="36" sev="4" auth="root" rule="MISRAC2012-DIR_4_6-b" tool="c++test" cat="MISRAC2012-DIR_4_6" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="36" locStartPos="4" locEndLn="36" locEndPos="5" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Expression of pointer type is compared with '0'" ln="19" sev="2" auth="root" rule="MISRAC2012-RULE_11_9-b" tool="c++test" cat="MISRAC2012-RULE_11_9" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="19" locStartPos="21" locEndLn="19" locEndPos="22" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Pass parameter &quot;p&quot; with const specifier" ln="5" sev="4" auth="root" rule="MISRAC2012-RULE_8_13-a" tool="c++test" cat="MISRAC2012-RULE_8_13" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="5" locStartPos="25" locEndLn="5" locEndPos="26" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Expression of pointer type is compared with '0'" ln="19" sev="2" auth="root" rule="MISRAC2012-RULE_11_9-a" tool="c++test" cat="MISRAC2012-RULE_11_9" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="19" locStartPos="21" locEndLn="19" locEndPos="22" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="The basic numerical type 'int' should not be used" ln="35" sev="4" auth="root" rule="MISRAC2012-DIR_4_6-b" tool="c++test" cat="MISRAC2012-DIR_4_6" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="35" locStartPos="4" locEndLn="35" locEndPos="5" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Operands of the '*' operator have different essential types: 'unsigned long' and 'int'" ln="40" sev="2" auth="root" rule="MISRAC2012-RULE_10_4-a" tool="c++test" cat="MISRAC2012-RULE_10_4" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="40" locStartPos="33" locEndLn="40" locEndPos="34" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Prototype of function 'storePerson' does not precede function definition" ln="5" sev="2" auth="root" rule="MISRAC2012-RULE_8_4-a" tool="c++test" cat="MISRAC2012-RULE_8_4" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="5" locStartPos="5" locEndLn="5" locEndPos="6" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Parameter 'p' is not used in function 'storePerson'" ln="5" sev="4" auth="root" rule="MISRAC2012-RULE_2_7-a" tool="c++test" cat="MISRAC2012-RULE_2_7" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="5" locStartPos="25" locEndLn="5" locEndPos="26" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Conditional statement 'if' in a function 'printPersonInfo' should be followed by a block" ln="19" sev="2" auth="root" rule="MISRAC2012-RULE_15_6-b" tool="c++test" cat="MISRAC2012-RULE_15_6" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="19" locStartPos="12" locEndLn="19" locEndPos="13" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="The 'exit' library function should not be used" ln="19" sev="2" auth="root" rule="MISRAC2012-RULE_21_8-b" tool="c++test" cat="MISRAC2012-RULE_21_8" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="19" locStartPos="24" locEndLn="19" locEndPos="25" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="The '++' operator should cause the only side effect in an expression" ln="20" sev="4" auth="root" rule="MISRAC2012-RULE_13_3-a" tool="c++test" cat="MISRAC2012-RULE_13_3" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="20" locStartPos="28" locEndLn="20" locEndPos="29" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="'malloc' function should not be used" ln="40" sev="2" auth="root" rule="MISRAC2012-DIR_4_12-a" tool="c++test" cat="MISRAC2012-DIR_4_12" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="40" locStartPos="26" locEndLn="40" locEndPos="27" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Usage of 'fgets' function is not allowed" ln="16" sev="2" auth="root" rule="MISRAC2012-RULE_21_6-a" tool="c++test" cat="MISRAC2012-RULE_21_6" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="16" locStartPos="12" locEndLn="16" locEndPos="13" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="'malloc' function should not be used" ln="18" sev="2" auth="root" rule="MISRAC2012-RULE_21_3-a" tool="c++test" cat="MISRAC2012-RULE_21_3" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="18" locStartPos="24" locEndLn="18" locEndPos="25" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Section of code should not be 'commented out'" ln="24" sev="4" auth="root" rule="MISRAC2012-DIR_4_4-a" tool="c++test" cat="MISRAC2012-DIR_4_4" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="24" locStartPos="12" locEndLn="24" locEndPos="13" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="The basic numerical type 'int' should not be used" ln="14" sev="4" auth="root" rule="MISRAC2012-DIR_4_6-b" tool="c++test" cat="MISRAC2012-DIR_4_6" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="14" locStartPos="4" locEndLn="14" locEndPos="5" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="Prototype of function 'simpleLeakInCycle' does not precede function definition" ln="32" sev="2" auth="root" rule="MISRAC2012-RULE_8_4-a" tool="c++test" cat="MISRAC2012-RULE_8_4" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="32" locStartPos="5" locEndLn="32" locEndPos="6" locFile="/BugDetective/memoryLeaks.c"/><StdViol msg="'malloc' function should not be used" ln="40" sev="2" auth="root" rule="MISRAC2012-RULE_21_3-a" tool="c++test" cat="MISRAC2012-RULE_21_3" lang="cpp" locType="sr" config="1" hash="1502549011" locStartln="40" locStartPos="26" locEndLn="40" locEndPos="27" locFile="/BugDetective/memoryLeaks.c"/></ResultInfo>
--Sg7K1FI4l1sgCNil90NEdlqXk518AQo--
