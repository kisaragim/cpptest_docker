<?xml version='1.0' encoding='UTF-8'?>
<ResultsSession buildId="Default Project-2023-09-12" climode="true" execEnv="linux_x86_64" hasViols="true" id="1695814796702" lang="en_US" machine="f4ce4f3ddc16" prjModule="BugDetective" project="" tag="MISRA C 2012" time="2023-09-12T01:55:56+00:00" toolDispName="C/C++test" toolId="c++test" toolName="DTP Engine for C/C++" toolVer="2022.2.0" user="root">
   <TestConfig machine="f4ce4f3ddc16" name="MISRA C 2012" pseudoUrl="builtin://MISRA C 2012" user="root" />
   <Authors>
      <Author id="dev1" name="root" />
   </Authors>
   <Analyzers>
      <Analyzer id="com.parasoft.xtest.scope.analyzer" name="Scope Analyzer" ver="10.6.1.20221116" />
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.code" name="Parasoft C/C++ Code Analyzer" ver="10.6.1.20221118B1887" />
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.desktop.files.in.scope" name="Helper Scope Analyzer for C/C++test Professional" ver="10.6.1.20221118B1887" />
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.pattern" name="Parasoft C/C++ Static Analyzer" ver="10.6.1.20221118B1887" />
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.flow" name="Parasoft C/C++ Flow Analyzer" ver="10.6.1.20221108B3828" />
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.global" name="Parasoft C/C++ Global Static Analyzer" ver="10.6.1.20221118B1887" />
   </Analyzers>
   <VersionInfos>
      <StorageInfo ownerId="" resultId="ISetupResult" ver="1" ver10x="1" />
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IMetricsViolation" ver="2" ver10x="1" />
      <StorageInfo ownerId="" resultId="IExecutionViolation" ver="1" ver10x="1" />
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IDupCodeViolation" ver="2" ver10x="1" />
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IFlowAnalysisViolation" ver="2" ver10x="1" />
      <StorageInfo ownerId="" resultId="IFunctionalViolation" ver="1" ver10x="1" />
      <StorageInfo ownerId="" resultId="IChangeImpactViolation" ver="1" ver10x="1" />
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="ICodingStandardsViolation" ver="2" ver10x="1" />
      <StorageInfo ownerId="" resultId="IUnitTestViolation" ver="1" ver10x="1" />
   </VersionInfos>
   <Goals tsks="50">
      
   </Goals>
   <Scope>
      <Repositories />
      <Locations>
         <Loc auth="root" hash="-1375949553" locRef="1" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="arrayOutOfBounds.c" totLns="48" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/arrayOutOfBounds.c" />
         <Loc auth="root" hash="1082458265" locRef="2" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="bufferOverflow.c" totLns="35" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/bufferOverflow.c" />
         <Loc auth="root" hash="-892903586" locRef="3" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="dbutil.c" totLns="17" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/dbutil.c" />
         <Loc auth="root" hash="1923244810" locRef="4" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="divisionByZero.c" totLns="58" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/divisionByZero.c" />
         <Loc auth="root" hash="1210532432" locRef="5" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="fileLeaks.c" totLns="60" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/fileLeaks.c" />
         <Loc auth="root" hash="-1197576192" locRef="6" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="integerOverflow.c" totLns="42" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/integerOverflow.c" />
         <Loc auth="root" hash="1502549011" locRef="7" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="memoryLeaks.c" totLns="46" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/memoryLeaks.c" />
         <Loc auth="root" hash="522847191" locRef="8" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="nullPointerDeref.c" totLns="43" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/nullPointerDeref.c" />
         <Loc auth="root" hash="-1583021683" locRef="9" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="nullPointerDerefBenchmark.c" totLns="79" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/nullPointerDerefBenchmark.c" />
         <Loc auth="root" hash="1115766966" locRef="10" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="sql.c" totLns="12" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/sql.c" />
         <Loc auth="root" hash="-1138451494" locRef="11" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="sqlInjection.c" totLns="37" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/sqlInjection.c" />
         <Loc auth="root" hash="1398926183" locRef="12" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="unreachableCode.c" totLns="68" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/unreachableCode.c" />
         <Loc auth="root" hash="-54878936" locRef="13" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="useBeforeInit.c" totLns="53" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/useBeforeInit.c" />
         <Loc auth="root" hash="-390129458" locRef="14" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="dbutil.h" totLns="10" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/dbutil.h" />
         <Loc auth="root" hash="-1106475955" locRef="15" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="socket.h" totLns="22" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/socket.h" />
         <Loc auth="root" hash="-1897154214" locRef="16" projId="BugDetective" projPath="/BugDetective" project="BugDetective" resProjPath="sql.h" totLns="28" uri="file://f4ce4f3ddc16/home/keio/cpptest_git/cpptest_docker/sagyou/cpptest_docker/DevelopSampleProject/BugDetective/sql.h" />
      </Locations>
   </Scope>
   
  <SetupProblems />

   <CodingStandards ownerId="com.parasoft.xtest.checkers.api.standards" time="0:00:13">
      <Projects>
         <Project bdCheckedFiles="0" bdTotalFiles="0" checkedFiles="16" checkedLns="658" id="BugDetective" name="BugDetective" qfixErrs="0" suppErrs="0" totErrs="489" totFiles="16" totLns="658" />
      </Projects>
      
      
      <Rules>
         <CategoriesList>
            <Category authTot="0;" authUrg="0;" desc="MISRA C 2012" name="MISRAC2012" rules="354" total="0">
               <Category authTot="0;" authUrg="0;" desc="Rule 11.3 (Required) A cast shall not be performed between a pointer to object type and a pointer to a different object type" name="MISRAC2012-RULE_11_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.5 (Required) An external object or function shall be declared once in one and only one file" name="MISRAC2012-RULE_8_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 11.4 (Advisory) A conversion should not be performed between a pointer to object and an integer type" name="MISRAC2012-RULE_11_4" rules="1" total="0" />
               <Category authTot="2;" authUrg="0;" desc="Rule 8.6 (Required) An identifier with external linkage shall have exactly one external definition" name="MISRAC2012-RULE_8_6" rules="1" total="2" />
               <Category authTot="7;" authUrg="0;" desc="Rule 11.5 (Advisory) A conversion should not be performed from pointer to void into pointer to object" name="MISRAC2012-RULE_11_5" rules="1" total="7" />
               <Category authTot="2;" authUrg="0;" desc="Rule 8.3 (Required) All declarations of an object or function shall use the same names and type qualifiers" name="MISRAC2012-RULE_8_3" rules="3" total="2" />
               <Category authTot="0;" authUrg="0;" desc="Rule 11.6 (Required) A cast shall not be performed between pointer to void and an arithmetic type" name="MISRAC2012-RULE_11_6" rules="1" total="0" />
               <Category authTot="36;" authUrg="9;" desc="Rule 8.4 (Required) A compatible declaration shall be visible when an object or function with external linkage is defined" name="MISRAC2012-RULE_8_4" rules="2" total="36" />
               <Category authTot="0;" authUrg="0;" desc="Rule 11.7 (Required) A cast shall not be performed between pointer to object and a non-integer arithmetic type" name="MISRAC2012-RULE_11_7" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.9 (Advisory) An object should be defined at block scope if its identifier only appears in a single function" name="MISRAC2012-RULE_8_9" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 11.8 (Required) A cast shall not remove any const or volatile qualification from the type pointed to by a pointer" name="MISRAC2012-RULE_11_8" rules="1" total="0" />
               <Category authTot="40;" authUrg="6;" desc="Rule 11.9 (Required) The macro NULL shall be the only permitted form of integer null pointer constant" name="MISRAC2012-RULE_11_9" rules="2" total="40" />
               <Category authTot="0;" authUrg="0;" desc="Rule 19.1 (Mandatory) An object shall not be assigned or copied to an overlapping object" name="MISRAC2012-RULE_19_1" rules="3" total="0" />
               <Category authTot="18;" authUrg="0;" desc="Rule 8.7 (Advisory) Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" name="MISRAC2012-RULE_8_7" rules="1" total="18" />
               <Category authTot="0;" authUrg="0;" desc="Dir 4.15 (Required) Evaluation of floating-point expressions shall not lead to the undetected generation of infinities and NaNs" name="MISRAC2012-DIR_4_15" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 19.2 (Advisory) The union keyword should not be used" name="MISRAC2012-RULE_19_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.8 (Required) The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage" name="MISRAC2012-RULE_8_8" rules="1" total="0" />
               <Category authTot="6;" authUrg="0;" desc="Dir 4.14 (Required) The validity of values received from external sources shall be checked" name="MISRAC2012-DIR_4_14" rules="12" total="6" />
               <Category authTot="5;" authUrg="0;" desc="Dir 4.13 (Advisory) Functions which are designed to provide operations on a resource should be called in an appropriate sequence" name="MISRAC2012-DIR_4_13" rules="6" total="5" />
               <Category authTot="12;" authUrg="1;" desc="Dir 4.12 (Required) Dynamic memory allocation shall not be used" name="MISRAC2012-DIR_4_12" rules="1" total="12" />
               <Category authTot="0;" authUrg="0;" desc="Dir 4.11 (Required) The validity of values passed to library functions shall be checked" name="MISRAC2012-DIR_4_11" rules="1" total="0" />
               <Category authTot="1;" authUrg="1;" desc="Dir 4.10 (Required) Precautions shall be taken in order to prevent the contents of a header file being included more than once" name="MISRAC2012-DIR_4_10" rules="1" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.1 (Required) Types shall be explicitly specified" name="MISRAC2012-RULE_8_1" rules="2" total="0" />
               <Category authTot="11;" authUrg="3;" desc="Rule 8.2 (Required) Function types shall be in prototype form with named parameters" name="MISRAC2012-RULE_8_2" rules="3" total="11" />
               <Category authTot="0;" authUrg="0;" desc="Rule 11.1 (Required) Conversions shall not be performed between a pointer to a function and any other type" name="MISRAC2012-RULE_11_1" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 11.2 (Required) Conversions shall not be performed between a pointer to an incomplete type and any other type" name="MISRAC2012-RULE_11_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 22.3 (Required) The same file shall not be open for read and write access at the same time on different streams" name="MISRAC2012-RULE_22_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 22.4 (Mandatory) There shall be no attempt to write to a stream which has been opened as read-only" name="MISRAC2012-RULE_22_4" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 22.5 (Mandatory) A pointer to a FILE object shall not be dereferenced" name="MISRAC2012-RULE_22_5" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 22.6 (Mandatory) The value of a pointer to a FILE shall not be used after the associated stream has been closed" name="MISRAC2012-RULE_22_6" rules="1" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 22.7 (Required) The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF" name="MISRAC2012-RULE_22_7" rules="1" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 22.8 (Required) The value of errno shall be set to zero prior to a call to an errno-setting-function" name="MISRAC2012-RULE_22_8" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 22.9 (Required) The value of errno shall be tested against zero after calling an errno-setting-function" name="MISRAC2012-RULE_22_9" rules="1" total="0" />
               <Category authTot="5;" authUrg="0;" desc="Rule 22.1 (Required) All resources obtained dynamically by means of Standard Library functions shall be explicitly released" name="MISRAC2012-RULE_22_1" rules="1" total="5" />
               <Category authTot="0;" authUrg="0;" desc="Rule 22.2 (Mandatory) A block of memory shall only be freed if it was allocated by means of a" name="MISRAC2012-RULE_22_2" rules="2" total="0" />
               <Category authTot="4;" authUrg="0;" desc="Rule 10.4 (Required) Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" name="MISRAC2012-RULE_10_4" rules="2" total="4" />
               <Category authTot="0;" authUrg="0;" desc="Rule 10.5 (Advisory) The value of an expression should not be cast to an inappropriate essential type" name="MISRAC2012-RULE_10_5" rules="3" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 10.6 (Required) The value of a composite expression shall not be assigned to an object with wider essential type" name="MISRAC2012-RULE_10_6" rules="1" total="0" />
               <Category authTot="2;" authUrg="0;" desc="Rule 7.4 (Required) A string literal shall not be assigned to an object unless the object's type is &quot;pointer to const-qualified char&quot;" name="MISRAC2012-RULE_7_4" rules="1" total="2" />
               <Category authTot="0;" authUrg="0;" desc="Rule 10.7 (Required) If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" name="MISRAC2012-RULE_10_7" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 7.5 (Mandatory) The argument of an integer-constant macro shall have an appropriate form" name="MISRAC2012-RULE_7_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 10.8 (Required) The value of a composite expression shall not be cast to a different essential type category or a wider essential type" name="MISRAC2012-RULE_10_8" rules="1" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 18.1 (Required) A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand" name="MISRAC2012-RULE_18_1" rules="3" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 18.2 (Required) Subtraction between pointers shall only be applied to pointers that address elements of the same array" name="MISRAC2012-RULE_18_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 18.3 (Required) The relational operators >, >=, &lt; and &lt;= shall not be applied to objects of pointer type except where they point into the same object" name="MISRAC2012-RULE_18_3" rules="1" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 18.4 (Advisory) The +, -, += and -= operators should not be applied to an expression of pointer type" name="MISRAC2012-RULE_18_4" rules="1" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 18.5 (Advisory) Declarations should contain no more than two levels of pointer nesting" name="MISRAC2012-RULE_18_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 18.6 (Required) The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist" name="MISRAC2012-RULE_18_6" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 18.7 (Required) Flexible array members shall not be declared" name="MISRAC2012-RULE_18_7" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 18.8 (Required) Variable-length array types shall not be used" name="MISRAC2012-RULE_18_8" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 18.9 (Required) An object with temporary lifetime shall not undergo array-to-pointer conversion" name="MISRAC2012-RULE_18_9" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 7.2 (Required) A &quot;u&quot; or &quot;U&quot; suffix shall be applied to all integer constants that are represented in an unsigned type" name="MISRAC2012-RULE_7_2" rules="1" total="0" />
               <Category authTot="7;" authUrg="0;" desc="Rule 10.1 (Required) Operands shall not be of an inappropriate essential type" name="MISRAC2012-RULE_10_1" rules="8" total="7" />
               <Category authTot="0;" authUrg="0;" desc="Rule 7.3 (Required) The lowercase character &quot;l&quot; shall not be used in a literal suffix" name="MISRAC2012-RULE_7_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 10.2 (Required) Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" name="MISRAC2012-RULE_10_2" rules="1" total="0" />
               <Category authTot="15;" authUrg="2;" desc="Rule 10.3 (Required) The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category" name="MISRAC2012-RULE_10_3" rules="2" total="15" />
               <Category authTot="0;" authUrg="0;" desc="Rule 7.1 (Required) Octal constants shall not be used" name="MISRAC2012-RULE_7_1" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.4 (Required) The standard header file &lt;setjmp.h> shall not be used" name="MISRAC2012-RULE_21_4" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.5 (Required) The standard header file &lt;signal.h> shall not be used" name="MISRAC2012-RULE_21_5" rules="2" total="0" />
               <Category authTot="42;" authUrg="4;" desc="Rule 21.6 (Required) The Standard Library input/output functions shall not be used" name="MISRAC2012-RULE_21_6" rules="1" total="42" />
               <Category authTot="2;" authUrg="0;" desc="Rule 21.7 (Required) The atof, atoi, atol and atoll functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_7" rules="1" total="2" />
               <Category authTot="4;" authUrg="0;" desc="Rule 21.8 (Required) The Standard Library termination functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_8" rules="3" total="4" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.9 (Required) The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_9" rules="1" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 21.1 (Required) #define and #undef shall not be used on a reserved identifier or reserved macro name" name="MISRAC2012-RULE_21_1" rules="4" total="1" />
               <Category authTot="1;" authUrg="0;" desc="Rule 21.2 (Required) A reserved identifier or macro name shall not be declared" name="MISRAC2012-RULE_21_2" rules="3" total="1" />
               <Category authTot="12;" authUrg="1;" desc="Rule 21.3 (Required) The memory allocation and deallocation functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_3" rules="1" total="12" />
               <Category authTot="0;" authUrg="0;" desc="Rule 13.1 (Required) Initializer lists shall not contain persistent side effects" name="MISRAC2012-RULE_13_1" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 13.2 (Required) The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders" name="MISRAC2012-RULE_13_2" rules="7" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.24 (Required) The random number generator functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_24" rules="1" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 13.3 (Advisory) A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator" name="MISRAC2012-RULE_13_3" rules="1" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.23 (Required) All arguments to any multi-argument type-generic macros declared in &lt;tgmath.h> shall have the same standard type" name="MISRAC2012-RULE_21_23" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 13.4 (Advisory) The result of an assignment operator should not be used" name="MISRAC2012-RULE_13_4" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.22 (Mandatory) All arguments to any type-generic macros declared in &lt;tgmath.h> shall have appropriate essential type" name="MISRAC2012-RULE_21_22" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 13.5 (Required) The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects" name="MISRAC2012-RULE_13_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.21 (Required) The Standard Library function system of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_21" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 13.6 (Required) The operand of the sizeof operator shall not contain any expression which has potential side effects" name="MISRAC2012-RULE_13_6" rules="3" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.20 (Mandatory) The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function" name="MISRAC2012-RULE_21_20" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 2.3 (Advisory) A project should not contain unused type declarations" name="MISRAC2012-RULE_2_3" rules="2" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 2.4 (Advisory) A project should not contain unused tag declarations" name="MISRAC2012-RULE_2_4" rules="2" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 2.1 (Required) A project shall not contain unreachable code" name="MISRAC2012-RULE_2_1" rules="7" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 2.2 (Required) There shall be no dead code" name="MISRAC2012-RULE_2_2" rules="2" total="1" />
               <Category authTot="10;" authUrg="0;" desc="Rule 2.7 (Advisory) There should be no unused parameters in functions" name="MISRAC2012-RULE_2_7" rules="1" total="10" />
               <Category authTot="0;" authUrg="0;" desc="Rule 2.5 (Advisory) A project should not contain unused macro definitions" name="MISRAC2012-RULE_2_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 2.6 (Advisory) A function should not contain unused label declarations" name="MISRAC2012-RULE_2_6" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 12.2 (Required) The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand" name="MISRAC2012-RULE_12_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 9.4 (Required) An element of an object shall not be initialized more than once" name="MISRAC2012-RULE_9_4" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 12.3 (Advisory) The comma operator should not be used" name="MISRAC2012-RULE_12_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 9.5 (Required) Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" name="MISRAC2012-RULE_9_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 12.4 (Advisory) Evaluation of constant expressions should not lead to unsigned integer wrap-around" name="MISRAC2012-RULE_12_4" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 9.2 (Required) The initializer for an aggregate or union shall be enclosed in braces" name="MISRAC2012-RULE_9_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 12.5 (Mandatory) The sizeof operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" name="MISRAC2012-RULE_12_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 9.3 (Required) Arrays shall not be partially initialized" name="MISRAC2012-RULE_9_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 22.10 (Required) The value of errno shall only be tested when the last function to be called was an errno-setting-function" name="MISRAC2012-RULE_22_10" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Dir 4.9 (Advisory) A function should be used in preference to a function-like macro where they are interchangeable" name="MISRAC2012-DIR_4_9" rules="1" total="0" />
               <Category authTot="2;" authUrg="1;" desc="Dir 4.8 (Advisory) If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" name="MISRAC2012-DIR_4_8" rules="1" total="2" />
               <Category authTot="4;" authUrg="1;" desc="Dir 4.5 (Advisory) Identifiers in the same name space with overlapping visibility should be typographically unambiguous" name="MISRAC2012-DIR_4_5" rules="1" total="4" />
               <Category authTot="4;" authUrg="1;" desc="Dir 4.4 (Advisory) Sections of code should not be &quot;commented out&quot;" name="MISRAC2012-DIR_4_4" rules="1" total="4" />
               <Category authTot="5;" authUrg="0;" desc="Dir 4.7 (Required) If a function returns error information, then that error information shall be tested" name="MISRAC2012-DIR_4_7" rules="2" total="5" />
               <Category authTot="70;" authUrg="13;" desc="Dir 4.6 (Advisory) typedefs that indicate size and signedness should be used in place of the basic numerical types" name="MISRAC2012-DIR_4_6" rules="3" total="70" />
               <Category authTot="12;" authUrg="0;" desc="Dir 4.1 (Required) Run-time failures shall be minimized" name="MISRAC2012-DIR_4_1" rules="11" total="12" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.12 (Required) Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" name="MISRAC2012-RULE_8_12" rules="1" total="0" />
               <Category authTot="15;" authUrg="0;" desc="Rule 8.13 (Advisory) A pointer should point to a const-qualified type whenever possible" name="MISRAC2012-RULE_8_13" rules="2" total="15" />
               <Category authTot="0;" authUrg="0;" desc="Dir 4.3 (Required) Assembly language shall be encapsulated and isolated" name="MISRAC2012-DIR_4_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.14 (Required) The restrict type qualifier shall not be used" name="MISRAC2012-RULE_8_14" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Dir 4.2 (Advisory) All usage of assembly language should be documented" name="MISRAC2012-DIR_4_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.15 (Required) All declarations of an object with an explicit alignment specification shall specify the same alignment" name="MISRAC2012-RULE_8_15" rules="2" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 1.1 (Required) The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits" name="MISRAC2012-RULE_1_1" rules="4" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.10 (Required) An inline function shall be declared with the static storage class" name="MISRAC2012-RULE_8_10" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.11 (Advisory) When an array with external linkage is declared, its size should be explicitly specified" name="MISRAC2012-RULE_8_11" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 1.4 (Required) Emergent language features shall not be used" name="MISRAC2012-RULE_1_4" rules="9" total="0" />
               <Category authTot="11;" authUrg="4;" desc="Rule 1.5 (Required) Obsolescent language features shall not be used" name="MISRAC2012-RULE_1_5" rules="7" total="11" />
               <Category authTot="5;" authUrg="0;" desc="Rule 1.3 (Required) There shall be no occurrence of undefined or critical unspecified behaviour" name="MISRAC2012-RULE_1_3" rules="15" total="5" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.16 (Advisory) The alignment specification of zero should not appear in an object declaration" name="MISRAC2012-RULE_8_16" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 8.17 (Advisory) At most one explicit alignment specifier should appear in an object declaration" name="MISRAC2012-RULE_8_17" rules="1" total="0" />
               <Category authTot="2;" authUrg="0;" desc="Rule 9.1 (Mandatory) The value of an object with automatic storage duration shall not be read before it has been set" name="MISRAC2012-RULE_9_1" rules="1" total="2" />
               <Category authTot="2;" authUrg="0;" desc="Rule 12.1 (Advisory) The precedence of operators within expressions should be made explicit" name="MISRAC2012-RULE_12_1" rules="3" total="2" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.10 (Required) A function declared with a _Noreturn function specifier shall have void return type" name="MISRAC2012-RULE_17_10" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 23.2 (Required) A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression" name="MISRAC2012-RULE_23_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.11 (Advisory) A function that never returns should be declared with a _Noreturn function specifier" name="MISRAC2012-RULE_17_11" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 23.3 (Advisory) A generic selection should contain at least one non-default association" name="MISRAC2012-RULE_23_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.12 (Advisory) A function identifier should only be used with either a preceding &amp;, or with a parenthesised parameter list" name="MISRAC2012-RULE_17_12" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 23.4 (Required) A generic association shall list an appropriate type" name="MISRAC2012-RULE_23_4" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.13 (Required) A function type shall not be type qualified" name="MISRAC2012-RULE_17_13" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 23.5 (Advisory) A generic selection should not depend on implicit pointer type conversion" name="MISRAC2012-RULE_23_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 23.6 (Required) The controlling expression of a generic selection shall have an essential type that matches its standard type" name="MISRAC2012-RULE_23_6" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 23.7 (Advisory) A generic selection that is expanded from a macro should evaluate its argument only once" name="MISRAC2012-RULE_23_7" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 23.8 (Required) A default association shall appear as either the first or the last association of a generic selection" name="MISRAC2012-RULE_23_8" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 23.1 (Advisory) A generic selection should only be expanded from a macro" name="MISRAC2012-RULE_23_1" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.13 (Required) A line whose first token is # shall be a valid preprocessing directive" name="MISRAC2012-RULE_20_13" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.12 (Required) A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" name="MISRAC2012-RULE_20_12" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 15.1 (Advisory) The goto statement should not be used" name="MISRAC2012-RULE_15_1" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.11 (Required) A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" name="MISRAC2012-RULE_20_11" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 15.2 (Required) The goto statement shall jump to a label declared later in the same function" name="MISRAC2012-RULE_15_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.10 (Advisory) The # and ## preprocessor operators should not be used" name="MISRAC2012-RULE_20_10" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 15.3 (Required) Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement" name="MISRAC2012-RULE_15_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 15.4 (Advisory) There should be no more than one break or goto statement used to terminate any iteration statement" name="MISRAC2012-RULE_15_4" rules="1" total="0" />
               <Category authTot="28;" authUrg="0;" desc="Rule 15.5 (Advisory) A function should have a single point of exit at the end" name="MISRAC2012-RULE_15_5" rules="1" total="28" />
               <Category authTot="18;" authUrg="0;" desc="Rule 15.6 (Required) The body of an iteration-statement or a selection-statement shall be a compound-statement" name="MISRAC2012-RULE_15_6" rules="2" total="18" />
               <Category authTot="0;" authUrg="0;" desc="Rule 15.7 (Required) All if ... else if constructs shall be terminated with an else statement" name="MISRAC2012-RULE_15_7" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.14 (Required) All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related" name="MISRAC2012-RULE_20_14" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 4.1 (Required) Octal and hexadecimal escape sequences shall be terminated" name="MISRAC2012-RULE_4_1" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 4.2 (Advisory) Trigraphs should not be used" name="MISRAC2012-RULE_4_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 14.1 (Required) A loop counter shall not have essentially floating type" name="MISRAC2012-RULE_14_1" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 14.2 (Required) A for loop shall be well-formed" name="MISRAC2012-RULE_14_2" rules="4" total="0" />
               <Category authTot="2;" authUrg="0;" desc="Rule 14.3 (Required) Controlling expressions shall not be invariant" name="MISRAC2012-RULE_14_3" rules="1" total="2" />
               <Category authTot="4;" authUrg="0;" desc="Rule 14.4 (Required) The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type" name="MISRAC2012-RULE_14_4" rules="1" total="4" />
               <Category authTot="0;" authUrg="0;" desc="Rule 3.2 (Required) Line-splicing shall not be used in // comments" name="MISRAC2012-RULE_3_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 3.1 (Required) The character sequences /* and // shall not be used within a comment" name="MISRAC2012-RULE_3_1" rules="3" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.14 (Required) The Standard Library function memcmp shall not be used to compare null terminated strings" name="MISRAC2012-RULE_21_14" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.13 (Mandatory) Any value passed to a function in &lt;ctype.h> shall be representable as an unsigned char or be the value EOF" name="MISRAC2012-RULE_21_13" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.12 (Required) The standard header file &lt;fenv.h> shall not be used" name="MISRAC2012-RULE_21_12" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.11 (Required) The standard header file &lt;tgmath.h> shall not be used" name="MISRAC2012-RULE_21_11" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.10 (Required) The Standard Library time and date functions shall not be used" name="MISRAC2012-RULE_21_10" rules="3" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.19 (Mandatory) The pointers returned by the Standard Library functions localeconv, getenv, setlocale or, strerror shall only be used as if they have pointer to const-qualified type" name="MISRAC2012-RULE_21_19" rules="2" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 21.18 (Mandatory) The size_t argument passed to any function in &lt;string.h> shall have an appropriate value" name="MISRAC2012-RULE_21_18" rules="1" total="1" />
               <Category authTot="1;" authUrg="0;" desc="Rule 21.17 (Mandatory) Use of the string handling functions from &lt;string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters" name="MISRAC2012-RULE_21_17" rules="2" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.16 (Required) The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" name="MISRAC2012-RULE_21_16" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 21.15 (Required) The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types" name="MISRAC2012-RULE_21_15" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.1 (Required) The features of &lt;stdarg.h> shall not be used" name="MISRAC2012-RULE_17_1" rules="3" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.2 (Required) Functions shall not call themselves, either directly or indirectly" name="MISRAC2012-RULE_17_2" rules="1" total="0" />
               <Category authTot="2;" authUrg="0;" desc="Rule 17.3 (Mandatory) A function shall not be declared implicitly" name="MISRAC2012-RULE_17_3" rules="1" total="2" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.4 (Mandatory) All exit paths from a function with non-void return type shall have an explicit return statement with an expression" name="MISRAC2012-RULE_17_4" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.5 (Required) The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" name="MISRAC2012-RULE_17_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.6 (Mandatory) The declaration of an array parameter shall not contain the static keyword between the [ ]" name="MISRAC2012-RULE_17_6" rules="1" total="0" />
               <Category authTot="45;" authUrg="2;" desc="Rule 17.7 (Required) The value returned by a function having non-void return type shall be used" name="MISRAC2012-RULE_17_7" rules="2" total="45" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.8 (Advisory) A function parameter should not be modified" name="MISRAC2012-RULE_17_8" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 17.9 (Mandatory) A function declared with a _Noreturn function specifier shall not return to its caller" name="MISRAC2012-RULE_17_9" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 6.3 (Required) A bit field shall not be declared as a member of a union" name="MISRAC2012-RULE_6_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 6.1 (Required) Bit-fields shall only be declared with an appropriate type" name="MISRAC2012-RULE_6_1" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 6.2 (Required) Single-bit named bit fields shall not be of a signed type" name="MISRAC2012-RULE_6_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.5 (Advisory) #undef should not be used" name="MISRAC2012-RULE_20_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.6 (Required) Tokens that look like a preprocessing directive shall not occur within a macro argument" name="MISRAC2012-RULE_20_6" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.7 (Required) Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses" name="MISRAC2012-RULE_20_7" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.8 (Required) The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" name="MISRAC2012-RULE_20_8" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.9 (Required) All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation" name="MISRAC2012-RULE_20_9" rules="1" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 20.1 (Advisory) #include directives should only be preceded by preprocessor directives or comments" name="MISRAC2012-RULE_20_1" rules="1" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.2 (Required) The ', &quot; or \ characters and the /* or // character sequences shall not occur in a header file name" name="MISRAC2012-RULE_20_2" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.3 (Required) The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" name="MISRAC2012-RULE_20_3" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 20.4 (Required) A macro shall not be defined with the same name as a keyword" name="MISRAC2012-RULE_20_4" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 5.8 (Required) Identifiers that define objects or functions with external linkage shall be unique" name="MISRAC2012-RULE_5_8" rules="1" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 5.9 (Advisory) Identifiers that define objects or functions with internal linkage should be unique" name="MISRAC2012-RULE_5_9" rules="2" total="1" />
               <Category authTot="1;" authUrg="1;" desc="Rule 5.6 (Required) A typedef name shall be a unique identifier" name="MISRAC2012-RULE_5_6" rules="2" total="1" />
               <Category authTot="0;" authUrg="0;" desc="Rule 16.1 (Required) All switch statements shall be well-formed" name="MISRAC2012-RULE_16_1" rules="8" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 5.7 (Required) A tag name shall be a unique identifier" name="MISRAC2012-RULE_5_7" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 16.2 (Required) A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" name="MISRAC2012-RULE_16_2" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 16.3 (Required) An unconditional break statement shall terminate every switch-clause" name="MISRAC2012-RULE_16_3" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 16.4 (Required) Every switch statement shall have a default label" name="MISRAC2012-RULE_16_4" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 16.5 (Required) A default label shall appear as either the first or the last switch label of a switch statement" name="MISRAC2012-RULE_16_5" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 16.6 (Required) Every switch statement shall have at least two switch-clauses" name="MISRAC2012-RULE_16_6" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 16.7 (Required) A switch-expression shall not have essentially Boolean type" name="MISRAC2012-RULE_16_7" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 5.1 (Required) External identifiers shall be distinct" name="MISRAC2012-RULE_5_1" rules="1" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 5.4 (Required) Macro identifiers shall be distinct" name="MISRAC2012-RULE_5_4" rules="4" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 5.5 (Required) Identifiers shall be distinct from macro names" name="MISRAC2012-RULE_5_5" rules="2" total="0" />
               <Category authTot="0;" authUrg="0;" desc="Rule 5.2 (Required) Identifiers declared in the same scope and name space shall be distinct" name="MISRAC2012-RULE_5_2" rules="4" total="0" />
               <Category authTot="1;" authUrg="0;" desc="Rule 5.3 (Required) An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" name="MISRAC2012-RULE_5_3" rules="2" total="1" />
            </Category>
         </CategoriesList>
         <RulesList>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid accessing arrays out of bounds" id="MISRAC2012-DIR_4_1-a" origId="BD-PB-ARRAY" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="7;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid null pointer dereferencing" id="MISRAC2012-DIR_4_1-b" origId="BD-PB-NP" sev="2" total="7" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="2;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid division by zero" id="MISRAC2012-DIR_4_1-c" origId="BD-PB-ZERO" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid buffer overflow due to defining incorrect format limits" id="MISRAC2012-DIR_4_1-d" origId="BD-PB-OVERFFMT" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid overflow due to reading a not zero terminated string" id="MISRAC2012-DIR_4_1-e" origId="BD-PB-OVERFNZT" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Do not check for null after dereferencing" id="MISRAC2012-DIR_4_1-f" origId="BD-PB-DEREF" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid overflow when reading from a buffer" id="MISRAC2012-DIR_4_1-g" origId="BD-PB-OVERFRD" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-DIR_4_1-h" origId="BD-PB-OVERFWR" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRAC2012-DIR_4_1-i" origId="BD-PB-PTRSUB" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Do not compare two unrelated pointers" id="MISRAC2012-DIR_4_1-j" origId="BD-PB-PTRCMP" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid integer overflows" id="MISRAC2012-DIR_4_1-k" origId="BD-PB-INTOVERF" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="MISRAC2012-DIR_4_10" desc="Use multiple include guards" id="MISRAC2012-DIR_4_10-a" origId="PFO-02" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_11" desc="Validate values passed to library functions" id="MISRAC2012-DIR_4_11-a" origId="BD-API-VALPARAM" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="12;" authUrg="1;" cat="MISRAC2012-DIR_4_12" desc="Dynamic heap memory allocation shall not be used" id="MISRAC2012-DIR_4_12-a" origId="MISRA2004-20_4" sev="2" total="12" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="5;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Ensure resources are freed" id="MISRAC2012-DIR_4_13-a" origId="BD-RES-LEAKS" sev="4" total="5" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Do not use resources that have been freed" id="MISRAC2012-DIR_4_13-b" origId="BD-RES-FREE" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Do not free resources using invalid pointers" id="MISRAC2012-DIR_4_13-c" origId="BD-RES-INVFREE" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Do not abandon unreleased locks" id="MISRAC2012-DIR_4_13-d" origId="BD-TRS-LOCK" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Avoid double locking" id="MISRAC2012-DIR_4_13-e" origId="BD-TRS-DLOCK" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Do not release a lock that has not been acquired" id="MISRAC2012-DIR_4_13-f" origId="BD-TRS-REVLOCK" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid tainted data in array indexes" id="MISRAC2012-DIR_4_14-a" origId="BD-SECURITY-ARRAY" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="2;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against integer overflow/underflow from tainted data" id="MISRAC2012-DIR_4_14-b" origId="BD-SECURITY-INTOVERF" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid buffer read overflow from tainted data" id="MISRAC2012-DIR_4_14-c" origId="BD-SECURITY-OVERFRD" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid buffer write overflow from tainted data" id="MISRAC2012-DIR_4_14-d" origId="BD-SECURITY-OVERFWR" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against command injection" id="MISRAC2012-DIR_4_14-e" origId="BD-SECURITY-TDCMD" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against file name injection" id="MISRAC2012-DIR_4_14-f" origId="BD-SECURITY-TDFNAMES" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against SQL injection" id="MISRAC2012-DIR_4_14-g" origId="BD-SECURITY-TDSQL" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Prevent buffer overflows from tainted data" id="MISRAC2012-DIR_4_14-h" origId="BD-SECURITY-BUFWRITE" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="MISRAC2012-DIR_4_14-i" origId="BD-SECURITY-OVERFFMT" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against environment injection" id="MISRAC2012-DIR_4_14-j" origId="BD-SECURITY-TDENV" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid printing tainted data on the output console" id="MISRAC2012-DIR_4_14-k" origId="BD-SECURITY-TDCONSOLE" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Exclude unsanitized user input from format strings" id="MISRAC2012-DIR_4_14-l" origId="BD-SECURITY-TDINPUT" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_15" desc="Do not use floating-point expressions which may result in NaN and infinity values" id="MISRAC2012-DIR_4_15-a" origId="BD-PB-NANINF" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_2" desc="All usage of assembler shall be documented" id="MISRAC2012-DIR_4_2-a" origId="COMMENT-09" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_3" desc="Assembly language shall be encapsulated and isolated" id="MISRAC2012-DIR_4_3-a" origId="MISRA2004-2_1" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="1;" cat="MISRAC2012-DIR_4_4" desc="Sections of code should not be &quot;commented out&quot;" id="MISRAC2012-DIR_4_4-a" origId="MISRA2004-2_4" sev="4" total="4" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="1;" cat="MISRAC2012-DIR_4_5" desc="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" id="MISRAC2012-DIR_4_5-a" origId="NAMING-50" sev="4" total="4" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="MISRAC2012-DIR_4_6" desc="typedefs to basic types should contain some digits in their name" id="MISRAC2012-DIR_4_6-a" origId="MISRA2004-6_3" sev="4" total="3" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="64;" authUrg="13;" cat="MISRAC2012-DIR_4_6" desc="typedefs should be used in place of the basic types" id="MISRAC2012-DIR_4_6-b" origId="MISRA2004-6_3_b" sev="4" total="64" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="MISRAC2012-DIR_4_6" desc="Use typedefs from stdint.h instead of declaring your own in C99 code" id="MISRAC2012-DIR_4_6-c" origId="CODSTA-155" sev="4" total="3" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_7" desc="Consistently check the returned value of non-void functions" id="MISRAC2012-DIR_4_7-a" origId="BD-PB-CHECKRET" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="5;" authUrg="0;" cat="MISRAC2012-DIR_4_7" desc="Always check the returned value of non-void function" id="MISRAC2012-DIR_4_7-b" origId="BD-PB-CHECKRETGEN" sev="2" total="5" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="1;" cat="MISRAC2012-DIR_4_8" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="MISRAC2012-DIR_4_8-a" origId="CODSTA-115" sev="4" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_9" desc="A function should be used in preference to a function-like macro" id="MISRAC2012-DIR_4_9-a" origId="MISRA2004-19_7" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="7;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="MISRAC2012-RULE_10_1-a" origId="CODSTA-161_a" sev="2" total="7" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="MISRAC2012-RULE_10_1-b" origId="CODSTA-161_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="MISRAC2012-RULE_10_1-c" origId="CODSTA-161_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="MISRAC2012-RULE_10_1-d" origId="CODSTA-161_d" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="MISRAC2012-RULE_10_1-e" origId="CODSTA-161_e" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator" id="MISRAC2012-RULE_10_1-f" origId="CODSTA-161_f" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="MISRAC2012-RULE_10_1-g" origId="CODSTA-161_g" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="Floating-point expressions shall not be explicitly (syntactically) tested for equality (==) or inequality (!=)" id="MISRAC2012-RULE_10_1-h" origId="CODSTA-225" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_2" desc="Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" id="MISRAC2012-RULE_10_2-a" origId="CODSTA-162" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_3" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="MISRAC2012-RULE_10_3-a" origId="CODSTA-163_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="15;" authUrg="2;" cat="MISRAC2012-RULE_10_3" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="MISRAC2012-RULE_10_3-b" origId="CODSTA-163_b" sev="2" total="15" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRAC2012-RULE_10_4" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="MISRAC2012-RULE_10_4-a" origId="CODSTA-164_a" sev="2" total="4" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_4" desc="The second and third operands of the ternary operator shall have the same essential type category" id="MISRAC2012-RULE_10_4-b" origId="CODSTA-164_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_5" desc="The cast operation to essentially enumeration type is not allowed" id="MISRAC2012-RULE_10_5-a" origId="CODSTA-165_a" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_5" desc="Do not cast from or to essentially Boolean type" id="MISRAC2012-RULE_10_5-b" origId="CODSTA-165_b" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_5" desc="Do not use casts between essentially character types and essentially floating types" id="MISRAC2012-RULE_10_5-c" origId="CODSTA-165_c" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_6" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="MISRAC2012-RULE_10_6-a" origId="CODSTA-157" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_7" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="MISRAC2012-RULE_10_7-a" origId="CODSTA-156_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_7" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="MISRAC2012-RULE_10_7-b" origId="CODSTA-156_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_8" desc="The value of a composite expression shall not be cast to a different essential type category or a wider essential type" id="MISRAC2012-RULE_10_8-a" origId="CODSTA-152" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_1" desc="Conversions shall not be performed between a pointer to a function and any other type than pointer to function" id="MISRAC2012-RULE_11_1-a" origId="CODSTA-124_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_1" desc="Conversions shall not be performed between non compatible pointer to a function types" id="MISRAC2012-RULE_11_1-b" origId="CODSTA-124_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_2" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="MISRAC2012-RULE_11_2-a" origId="CODSTA-125" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_3" desc="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="MISRAC2012-RULE_11_3-a" origId="CODSTA-126" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_4" desc="A conversion should not be performed between a pointer to object and an integer type" id="MISRAC2012-RULE_11_4-a" origId="CODSTA-127" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="7;" authUrg="0;" cat="MISRAC2012-RULE_11_5" desc="A conversion should not be performed from pointer to void into pointer to object" id="MISRAC2012-RULE_11_5-a" origId="CODSTA-128" sev="4" total="7" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_6" desc="A cast shall not be performed between pointer to void and an arithmetic type" id="MISRAC2012-RULE_11_6-a" origId="CODSTA-129_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_7" desc="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="MISRAC2012-RULE_11_7-a" origId="CODSTA-130" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_8" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="MISRAC2012-RULE_11_8-a" origId="MISRA2004-11_5" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="20;" authUrg="3;" cat="MISRAC2012-RULE_11_9" desc="Literal zero (0) shall not be used as the null-pointer-constant" id="MISRAC2012-RULE_11_9-a" origId="CODSTA-CPP-63" sev="2" total="20" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="20;" authUrg="3;" cat="MISRAC2012-RULE_11_9" desc="Use NULL instead of literal zero (0) as the null-pointer-constant" id="MISRAC2012-RULE_11_9-b" origId="CODSTA-131" sev="2" total="20" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_1" desc="Use parentheses unless all operators in the expression are the same" id="MISRAC2012-RULE_12_1-a" origId="MISRA2004-12_1_e" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_12_1" desc="The operands of a logical &amp;&amp; or || shall be primary-expressions" id="MISRAC2012-RULE_12_1-b" origId="MISRA2004-12_5" sev="4" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_1" desc="The operand of the 'sizeof' operator should be enclosed in parentheses" id="MISRAC2012-RULE_12_1-c" origId="FORMAT-25" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_2" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="MISRAC2012-RULE_12_2-a" origId="MISRA2004-12_8" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_3" desc="The comma operator shall not be used" id="MISRAC2012-RULE_12_3-a" origId="MISRA2004-12_10" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_4" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="MISRAC2012-RULE_12_4-a" origId="PB-66_a" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_4" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="MISRAC2012-RULE_12_4-b" origId="PB-66_b" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_5" desc="The 'sizeof' operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" id="MISRAC2012-RULE_12_5-a" origId="CODSTA-182" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_1" desc="Initializer lists shall not contain persistent side effects" id="MISRAC2012-RULE_13_1-a" origId="CODSTA-141_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRAC2012-RULE_13_2-a" origId="MISRA2004-12_2_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRAC2012-RULE_13_2-b" origId="MISRA2004-12_2_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRAC2012-RULE_13_2-c" origId="MISRA2004-12_2_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRAC2012-RULE_13_2-d" origId="MISRA2004-12_2_d" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRAC2012-RULE_13_2-e" origId="MISRA2004-12_2_e" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Do not use more than one volatile between two adjacent sequence points" id="MISRAC2012-RULE_13_2-f" origId="MISRA2004-12_2_f" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRAC2012-RULE_13_2-g" origId="MISRA2004-12_2_g" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_13_3" desc="A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects" id="MISRAC2012-RULE_13_3-a" origId="CODSTA-123" sev="4" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_4" desc="The result of a built-in assignment operator should not be used" id="MISRAC2012-RULE_13_4-a" origId="CODSTA-138" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_5" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="MISRAC2012-RULE_13_5-a" origId="MISRA2004-12_4_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_6" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="MISRAC2012-RULE_13_6-a" origId="MISRA2004-12_3" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_6" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="MISRAC2012-RULE_13_6-b" origId="MISRA2004-12_3_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_6" desc="The function call shall not be the operand of the sizeof operator" id="MISRAC2012-RULE_13_6-c" origId="CODSTA-137" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_1" desc="A loop counter in a 'for' loop shall not have essentially floating type" id="MISRAC2012-RULE_14_1-a" origId="CODSTA-167_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_1" desc="A loop counter in 'while' and 'do-while' loops shall not have essentially floating type" id="MISRAC2012-RULE_14_1-b" origId="CODSTA-167_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_2" desc="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="MISRAC2012-RULE_14_2-a" origId="CODSTA-168" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_2" desc="The first clause of a 'for' loop shall be well-formed" id="MISRAC2012-RULE_14_2-b" origId="CODSTA-169_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_2" desc="The second clause of a 'for' loop shall be well-formed" id="MISRAC2012-RULE_14_2-c" origId="CODSTA-169_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_2" desc="The third clause of a 'for' statement shall be well-formed" id="MISRAC2012-RULE_14_2-d" origId="CODSTA-169_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_14_3" desc="Avoid conditions that always evaluate to the same value" id="MISRAC2012-RULE_14_3-ac" origId="BD-PB-CC" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRAC2012-RULE_14_4" desc="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" id="MISRAC2012-RULE_14_4-a" origId="MISRA2004-13_2" sev="2" total="4" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_1" desc="The goto statement shall not be used" id="MISRAC2012-RULE_15_1-a" origId="MISRA2004-14_4" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_2" desc="The goto statement shall jump to a label declared later in the same function body" id="MISRAC2012-RULE_15_2-a" origId="CODSTA-77" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_3" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="MISRAC2012-RULE_15_3-a" origId="CODSTA-78" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_4" desc="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="MISRAC2012-RULE_15_4-a" origId="CODSTA-79" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="28;" authUrg="0;" cat="MISRAC2012-RULE_15_5" desc="A function shall have a single point of exit at the end of the function" id="MISRAC2012-RULE_15_5-a" origId="MISRA2004-14_7" sev="4" total="28" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_6" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="MISRAC2012-RULE_15_6-a" origId="MISRA2004-14_8" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="18;" authUrg="0;" cat="MISRAC2012-RULE_15_6" desc="'if' and 'else' should be followed by a compound statement" id="MISRAC2012-RULE_15_6-b" origId="MISRA2004-14_9" sev="2" total="18" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_7" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="MISRAC2012-RULE_15_7-a" origId="MISRA2004-14_10" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="MISRAC2012-RULE_16_1-a" origId="MISRA2004-15_0_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRAC2012-RULE_16_1-b" origId="MISRA2004-15_1" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRAC2012-RULE_16_1-c" origId="MISRA2004-15_2" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRAC2012-RULE_16_1-d" origId="MISRA2004-15_2_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="Always provide a default branch for switch statements" id="MISRAC2012-RULE_16_1-e" origId="CODSTA-35" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRAC2012-RULE_16_1-f" origId="CODSTA-119" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="MISRAC2012-RULE_16_1-g" origId="CODSTA-116" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="Every switch statement shall have at least two switch-clauses" id="MISRAC2012-RULE_16_1-h" origId="OPT-39" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_2" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRAC2012-RULE_16_2-a" origId="MISRA2004-15_1" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_3" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRAC2012-RULE_16_3-a" origId="MISRA2004-15_2" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_3" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRAC2012-RULE_16_3-b" origId="MISRA2004-15_2_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_4" desc="Always provide a default branch for switch statements" id="MISRAC2012-RULE_16_4-a" origId="CODSTA-35" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_4" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRAC2012-RULE_16_4-b" origId="CODSTA-119" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_5" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="MISRAC2012-RULE_16_5-a" origId="CODSTA-116" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_6" desc="Every switch statement shall have at least two switch-clauses" id="MISRAC2012-RULE_16_6-a" origId="OPT-39" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_7" desc="A switch expression shall not represent a value that is effectively Boolean" id="MISRAC2012-RULE_16_7-a" origId="MISRA2004-15_4" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_7" desc="A switch expression shall not represent a value that is effectively Boolean" id="MISRAC2012-RULE_16_7-b" origId="MISRA2004-15_4_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_1" desc="The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used" id="MISRAC2012-RULE_17_1-a" origId="CODSTA-136_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_1" desc="The identifiers va_list, va_arg, va_start, va_end should not be used" id="MISRAC2012-RULE_17_1-b" origId="CODSTA-136_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_1" desc="The standard header file &lt;stdarg.h> or &lt;cstdarg> shall not be used" id="MISRAC2012-RULE_17_1-c" origId="CODSTA-136_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_10" desc="Functions declared as 'noreturn' shall have the 'void' return type" id="MISRAC2012-RULE_17_10-a" origId="CODSTA-204" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_11" desc="Declare non-returning functions with the attribute that specifies that they do not return" id="MISRAC2012-RULE_17_11-a" origId="BD-PB-NORETDECL" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_12" desc="A function identifier shall only be used with either a preceding '&amp;', or with a parenthesised parameter list, which may be empty" id="MISRAC2012-RULE_17_12-a" origId="MISRA2004-16_9" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_13" desc="Do not include any type qualifiers in the specification of a function type" id="MISRAC2012-RULE_17_13-a" origId="CODSTA-221" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_2" desc="Functions shall not call themselves, either directly or indirectly" id="MISRAC2012-RULE_17_2-a" origId="MISRA2004-16_2" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_17_3" desc="Functions shall always have visible prototype at the function call" id="MISRAC2012-RULE_17_3-a" origId="MISRA-071_b" sev="1" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_4" desc="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="MISRAC2012-RULE_17_4-a" origId="MISRA2004-16_8" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_4" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="MISRAC2012-RULE_17_4-b" origId="MISRA2004-16_8_b" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_5" desc="The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" id="MISRAC2012-RULE_17_5-a" origId="CODSTA-134" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_6" desc="The declaration of an array parameter shall not contain the 'static' keyword between the [ ]" id="MISRAC2012-RULE_17_6-a" origId="CODSTA-160" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="45;" authUrg="2;" cat="MISRAC2012-RULE_17_7" desc="The value returned by a function having non-void return type shall be used" id="MISRAC2012-RULE_17_7-a" origId="CODSTA-122_a" sev="2" total="45" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_7" desc="The value returned by a function having non-void return type shall be used" id="MISRAC2012-RULE_17_7-b" origId="CODSTA-122_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_8" desc="A function parameter should not be modified" id="MISRAC2012-RULE_17_8-a" origId="CODSTA-132" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_9" desc="Never return from functions that should not return" id="MISRAC2012-RULE_17_9-a" origId="BD-PB-NORETURN" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_18_1" desc="Avoid accessing arrays out of bounds" id="MISRAC2012-RULE_18_1-a" origId="BD-PB-ARRAY" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_1" desc="Avoid accessing arrays and pointers out of bounds" id="MISRAC2012-RULE_18_1-b" origId="BD-PB-OVERFARRAY" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_1" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="MISRAC2012-RULE_18_1-c" origId="BD-PB-PTRARR" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_2" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRAC2012-RULE_18_2-a" origId="BD-PB-PTRSUB" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_3" desc="Do not compare two unrelated pointers" id="MISRAC2012-RULE_18_3-a" origId="BD-PB-PTRCMP" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_18_4" desc="The +, -, += and -= operators should not be applied to an expression of pointer type" id="MISRAC2012-RULE_18_4-a" origId="CODSTA-181" sev="4" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_5" desc="The declaration of objects should contain no more than 2 levels of pointer indirection" id="MISRAC2012-RULE_18_5-a" origId="MISRA2004-17_5" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_6" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRAC2012-RULE_18_6-a" origId="MISRA2004-17_6_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_6" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRAC2012-RULE_18_6-b" origId="MISRA2004-17_6_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_7" desc="Flexible array members shall not be declared" id="MISRAC2012-RULE_18_7-a" origId="CODSTA-113" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_8" desc="Variable-length array types shall not be used" id="MISRAC2012-RULE_18_8-a" origId="CODSTA-112" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_9" desc="Do not modify objects with temporary lifetime" id="MISRAC2012-RULE_18_9-a" origId="CODSTA-196" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned to an overlapping object" id="MISRAC2012-RULE_19_1-a" origId="MISRA2004-18_2" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned to an overlapping object" id="MISRAC2012-RULE_19_1-b" origId="MISRA2004-18_2_b" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned or copied to an overlapping object" id="MISRAC2012-RULE_19_1-c" origId="BD-PB-OVERLAP" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_19_2" desc="The union keyword should not be used" id="MISRAC2012-RULE_19_2-a" origId="CODSTA-111" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRAC2012-RULE_1_1-a" origId="CODSTA-174_a_c90" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRAC2012-RULE_1_1-b" origId="CODSTA-174_a_c99" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRAC2012-RULE_1_1-c" origId="CODSTA-174_b_c90" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRAC2012-RULE_1_1-d" origId="CODSTA-174_b_c99" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Avoid division by zero" id="MISRAC2012-RULE_1_3-a" origId="BD-PB-ZERO" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Avoid use before initialization" id="MISRAC2012-RULE_1_3-b" origId="BD-PB-NOTINIT" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_1_3-c" origId="BD-RES-FREE" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Avoid overflow when reading from a buffer" id="MISRAC2012-RULE_1_3-d" origId="BD-PB-OVERFRD" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-RULE_1_3-e" origId="BD-PB-OVERFWR" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRAC2012-RULE_1_3-f" origId="MISRA2004-12_2_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRAC2012-RULE_1_3-g" origId="MISRA2004-12_2_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRAC2012-RULE_1_3-h" origId="MISRA2004-12_2_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRAC2012-RULE_1_3-i" origId="MISRA2004-12_2_d" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRAC2012-RULE_1_3-j" origId="MISRA2004-12_2_e" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Do not use more than one volatile between two adjacent sequence points" id="MISRAC2012-RULE_1_3-k" origId="MISRA2004-12_2_f" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRAC2012-RULE_1_3-l" origId="MISRA2004-12_2_g" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRAC2012-RULE_1_3-m" origId="MISRA2004-17_6_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRAC2012-RULE_1_3-n" origId="MISRA2004-17_6_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="The left-hand operand of a right-shift operator shall not have a negative value" id="MISRAC2012-RULE_1_3-o" origId="PB-29" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The '_Atomic' type specifier and the '_Atomic' type qualifier should not be used" id="MISRAC2012-RULE_1_4-d" origId="CODSTA-214" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The facilities that are specified as being provided by &lt;stdatomic.h> should not be used" id="MISRAC2012-RULE_1_4-e" origId="CODSTA-209" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The '_Thread_local' storage class specifier should not be used" id="MISRAC2012-RULE_1_4-f" origId="CODSTA-210" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The facilities that are specified as being provided by &lt;threads.h> should not be used" id="MISRAC2012-RULE_1_4-g" origId="CODSTA-211" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'" id="MISRAC2012-RULE_1_4-j" origId="CODSTA-215" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The 'rsize_t' type should not be used" id="MISRAC2012-RULE_1_4-k" origId="CODSTA-212" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The 'errno_t' type should not be used" id="MISRAC2012-RULE_1_4-l" origId="CODSTA-217" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="Do not use following macros: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S" id="MISRAC2012-RULE_1_4-m" origId="CODSTA-218" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="Do not use the functions defined in Annex K of ISO/IEC 9899:2011 standard" id="MISRAC2012-RULE_1_4-n" origId="CODSTA-219" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_5" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="MISRAC2012-RULE_1_5-a" origId="MISRA2004-8_11" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_5" desc="Storage type modifiers shall be associated with the type, not the variable or the function" id="MISRAC2012-RULE_1_5-b" origId="CODSTA-10" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="11;" authUrg="4;" cat="MISRAC2012-RULE_1_5" desc="Function types shall be in prototype form" id="MISRAC2012-RULE_1_5-c" origId="CODSTA-159" sev="2" total="11" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_5" desc="Do not use the macro ATOMIC_VAR_INIT" id="MISRAC2012-RULE_1_5-d" origId="CODSTA-209_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_5" desc="Do not use the 'bool', 'false' or 'true' identifiers in the #undef directive" id="MISRAC2012-RULE_1_5-e" origId="PREPROC-27" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_5" desc="Do not use the ungetc function on a stream with the file position indicator zero" id="MISRAC2012-RULE_1_5-f" origId="BD-PB-UNGETC" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_5" desc="Do not pass 0 value as a size argument to the realloc function" id="MISRAC2012-RULE_1_5-g" origId="BD-API-REALLOC" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_20_1" desc="#include statements in a file should only be preceded by other preprocessor directives or comments" id="MISRAC2012-RULE_20_1-a" origId="MISRA2004-19_1" sev="4" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_10" desc="The # and ## preprocessor operators should not be used" id="MISRAC2012-RULE_20_10-a" origId="MISRA2004-19_13" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_11" desc="A macro parameter immediately following a # operator shall not immediately be followed by or preceded by a ## operator" id="MISRAC2012-RULE_20_11-a" origId="PREPROC-16" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_12" desc="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="MISRAC2012-RULE_20_12-a" origId="PREPROC-17" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_13" desc="Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor" id="MISRAC2012-RULE_20_13-a" origId="MISRA2004-19_16" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_14" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="MISRAC2012-RULE_20_14-a" origId="MISRA2004-19_17" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_2" desc="The ', &quot;, /* or // characters shall not occur in a header file name" id="MISRAC2012-RULE_20_2-a" origId="NAMING-46" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_2" desc="The \ character should not occur in a header file name" id="MISRAC2012-RULE_20_2-b" origId="NAMING-48" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_3" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRAC2012-RULE_20_3-a" origId="MISRA-089" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_4" desc="A macro shall not be defined with the same name as a keyword in C90" id="MISRAC2012-RULE_20_4-a" origId="CODSTA-133_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_4" desc="A macro shall not be defined with the same name as a keyword in C99" id="MISRAC2012-RULE_20_4-b" origId="CODSTA-133_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_5" desc="#undef shall not be used" id="MISRAC2012-RULE_20_5-a" origId="PREPROC-25" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_6" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="MISRAC2012-RULE_20_6-a" origId="MISRA2004-19_9" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_7" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="MISRAC2012-RULE_20_7-a" origId="MISRA2004-19_10" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_8" desc="The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" id="MISRAC2012-RULE_20_8-a" origId="PREPROC-19" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_9" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="MISRAC2012-RULE_20_9-b" origId="MISRA2004-19_11_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_21_1" desc="Do not #define or #undef identifiers with names which start with underscore" id="MISRAC2012-RULE_21_1-a" origId="MISRA2004-20_1_a" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)" id="MISRAC2012-RULE_21_1-b" origId="CODSTA-92_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)" id="MISRAC2012-RULE_21_1-c" origId="CODSTA-92_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_1" desc="Do not #define nor #undef identifier 'defined'" id="MISRAC2012-RULE_21_1-d" origId="MISRA2004-20_1_e" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_10" desc="The standard header files &lt;time.h> or &lt;ctime> shall not be used" id="MISRAC2012-RULE_21_10-a" origId="MISRA2004-20_12" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_10" desc="The time handling functions and macros of the library &lt;time.h> shall not be used" id="MISRAC2012-RULE_21_10-b" origId="MISRA2004-20_12_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_10" desc="The types defined in the library &lt;time.h> shall not be used" id="MISRAC2012-RULE_21_10-c" origId="MISRA2004-20_12_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_11" desc="The standard header file &lt;tgmath.h> shall not be used" id="MISRAC2012-RULE_21_11-a" origId="CODSTA-108" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_12" desc="The features provided by &lt;fenv.h> should not be used" id="MISRAC2012-RULE_21_12-a" origId="CODSTA-109" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_12" desc="The standard header file &lt;fenv.h> shall not be used" id="MISRAC2012-RULE_21_12-b" origId="CODSTA-109_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_13" desc="Do not pass incorrect values to ctype.h library functions" id="MISRAC2012-RULE_21_13-a" origId="BD-API-CTYPE" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_14" desc="The Standard Library function memcmp shall not be used to compare null terminated strings" id="MISRAC2012-RULE_21_14-a" origId="BD-PB-MCCSTR" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_15" desc="The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types" id="MISRAC2012-RULE_21_15-a" origId="CODSTA-183" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_16" desc="The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" id="MISRAC2012-RULE_21_16-a" origId="CODSTA-184" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_17" desc="Avoid overflow due to reading a not zero terminated string" id="MISRAC2012-RULE_21_17-a" origId="BD-PB-OVERFNZT" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_21_17" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-RULE_21_17-b" origId="BD-PB-OVERFWR" sev="1" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_21_18" desc="The size_t argument passed to any function in string.h shall have an appropriate value" id="MISRAC2012-RULE_21_18-a" origId="BD-API-STRSIZE" sev="1" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_19" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="MISRAC2012-RULE_21_19-a" origId="CODSTA-185_a" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_19" desc="Strings pointed by members of the structure 'lconv' should not be modified" id="MISRAC2012-RULE_21_19-b" origId="CODSTA-185_b" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused" id="MISRAC2012-RULE_21_2-a" origId="MISRA2004-20_2" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused (C90)" id="MISRAC2012-RULE_21_2-b" origId="MISRA2004-20_2_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused (C99)" id="MISRAC2012-RULE_21_2-c" origId="MISRA2004-20_2_b" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_20" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="MISRAC2012-RULE_21_20-a" origId="BD-PB-INVRET" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_21" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_21-a" origId="SECURITY-48_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_22" desc="All arguments to any type-generic macros declared in &lt;tgmath.h> shall have appropriate essential type" id="MISRAC2012-RULE_21_22-a" origId="CODSTA-108_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_23" desc="All arguments to any multi-argument type-generic macros declared in &lt;tgmath.h> shall have the same standard type" id="MISRAC2012-RULE_21_23-a" origId="CODSTA-108_d" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_24" desc="The random number generator functions 'rand()' and 'srand()' should not be used" id="MISRAC2012-RULE_21_24-a" origId="SECURITY-02" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="12;" authUrg="1;" cat="MISRAC2012-RULE_21_3" desc="Dynamic heap memory allocation shall not be used" id="MISRAC2012-RULE_21_3-a" origId="MISRA2004-20_4" sev="2" total="12" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_4" desc="The facilities provided by &lt;setjmp.h> should not be used" id="MISRAC2012-RULE_21_4-a" origId="MISRA2004-20_7" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_4" desc="The standard header files &lt;setjmp.h> or &lt;csetjmp> shall not be used" id="MISRAC2012-RULE_21_4-b" origId="MISRA2004-20_7_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_5" desc="The standard header files &lt;signal.h> or &lt;csignal> shall not be used" id="MISRAC2012-RULE_21_5-a" origId="MISRA2004-20_8" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_5" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="MISRAC2012-RULE_21_5-b" origId="MISRA2004-20_8_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="42;" authUrg="4;" cat="MISRAC2012-RULE_21_6" desc="The Standard Library input/output functions shall not be used" id="MISRAC2012-RULE_21_6-a" origId="CODSTA-110" sev="2" total="42" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_21_7" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="MISRAC2012-RULE_21_7-a" origId="MISRA2004-20_10" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_8" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-a" origId="PB-75" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRAC2012-RULE_21_8" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-b" origId="PB-75_b" sev="2" total="4" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_8" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-c" origId="PB-75_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_9" desc="The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" id="MISRAC2012-RULE_21_9-a" origId="CODSTA-107" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="5;" authUrg="0;" cat="MISRAC2012-RULE_22_1" desc="Ensure resources are freed" id="MISRAC2012-RULE_22_1-a" origId="BD-RES-LEAKS" sev="2" total="5" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_10" desc="Properly use errno value" id="MISRAC2012-RULE_22_10-a" origId="BD-PB-ERRNO" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_2" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_22_2-a" origId="BD-RES-FREE" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_2" desc="Do not free resources using invalid pointers" id="MISRAC2012-RULE_22_2-b" origId="BD-RES-INVFREE" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_3" desc="The same file shall not be opened for read and write access at the same time on different streams" id="MISRAC2012-RULE_22_3-a" origId="BD-PB-WRRDSTR" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_4" desc="Avoid writing to a stream which has been opened as read only" id="MISRAC2012-RULE_22_4-a" origId="BD-PB-WRROS" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_5" desc="A pointer to a FILE object shall not be dereferenced" id="MISRAC2012-RULE_22_5-a" origId="CODSTA-166_a" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_5" desc="A pointer to a FILE object shall not be dereferenced by a library function" id="MISRAC2012-RULE_22_5-b" origId="CODSTA-166_b" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_6" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_22_6-a" origId="BD-RES-FREE" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_22_7" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="MISRAC2012-RULE_22_7-a" origId="BD-PB-EOFCOMP" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_8" desc="Properly use errno value" id="MISRAC2012-RULE_22_8-a" origId="BD-PB-ERRNO" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_9" desc="Properly use errno value" id="MISRAC2012-RULE_22_9-a" origId="BD-PB-ERRNO" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_1" desc="A generic selection should only be expanded from a macro" id="MISRAC2012-RULE_23_1-a" origId="CODSTA-MC-08" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_1" desc="A generic selection used in a macro definition should have a macro parameter in the controlling expression" id="MISRAC2012-RULE_23_1-b" origId="CODSTA-MC-10" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_2" desc="A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression" id="MISRAC2012-RULE_23_2-a" origId="CODSTA-MC-13" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_3" desc="A generic selection shall indicate at least one non-default association" id="MISRAC2012-RULE_23_3-a" origId="CODSTA-MC-07" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_4" desc="A generic association shall list an appropriate type" id="MISRAC2012-RULE_23_4-a" origId="CODSTA-MC-09" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_5" desc="A generic selection should not depend on implicit pointer type conversion" id="MISRAC2012-RULE_23_5-a" origId="CODSTA-MC-11" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_6" desc="The controlling expression of a generic selection shall have an essential type that matches its standard type" id="MISRAC2012-RULE_23_6-a" origId="CODSTA-MC-12" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_6" desc="Enumerated types should not be mixed with integer types in generic selections" id="MISRAC2012-RULE_23_6-b" origId="CODSTA-MC-14" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_7" desc="A generic selection that is expanded from a macro shall evaluate its argument only once" id="MISRAC2012-RULE_23_7-a" origId="CODSTA-MC-15" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_23_8" desc="The default association shall be placed first or last in the association list" id="MISRAC2012-RULE_23_8-a" origId="CODSTA-MC-06" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in &quot;else&quot; block" id="MISRAC2012-RULE_2_1-a" origId="MISRA2004-14_1_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements" id="MISRAC2012-RULE_2_1-b" origId="MISRA2004-14_1_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="MISRAC2012-RULE_2_1-c" origId="MISRA2004-14_1_c" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in switch statement" id="MISRAC2012-RULE_2_1-d" origId="MISRA2004-14_1_d" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in 'for' loop" id="MISRAC2012-RULE_2_1-e" origId="MISRA2004-14_1_e" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="MISRAC2012-RULE_2_1-f" origId="MISRA2004-14_1_f" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="MISRAC2012-RULE_2_1-g" origId="MISRA2004-14_1_g" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_2" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="MISRAC2012-RULE_2_2-a" origId="MISRA2004-14_2" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_2_2" desc="Avoid unused values" id="MISRAC2012-RULE_2_2-b" origId="BD-PB-VOVR" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_3" desc="A function should not contain unused type declarations" id="MISRAC2012-RULE_2_3-a" origId="CODSTA-175_a" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_3" desc="A source file should not contain unused type declarations" id="MISRAC2012-RULE_2_3-b" origId="CODSTA-175_b" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_4" desc="A function should not contain unused local tag declarations" id="MISRAC2012-RULE_2_4-a" origId="CODSTA-176_a" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_2_4" desc="A source file should not contain unused tag declarations" id="MISRAC2012-RULE_2_4-b" origId="CODSTA-176_b" sev="4" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_5" desc="A source file should not contain unused macro definitions" id="MISRAC2012-RULE_2_5-a" origId="CODSTA-177" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_6" desc="A function should not contain unused label declarations" id="MISRAC2012-RULE_2_6-a" origId="OPT-37" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="10;" authUrg="0;" cat="MISRAC2012-RULE_2_7" desc="There should be no unused parameters in functions" id="MISRAC2012-RULE_2_7-a" origId="OPT-38" sev="4" total="10" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_3_1" desc="The character sequence /* shall not be used within a C-style comment" id="MISRAC2012-RULE_3_1-a" origId="MISRA2004-2_3" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_3_1" desc="The character sequence // shall not be used within a C-style comment" id="MISRAC2012-RULE_3_1-b" origId="COMMENT-11" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_3_1" desc="The character sequence /* shall not be used within a C++-style comment" id="MISRAC2012-RULE_3_1-c" origId="COMMENT-12" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_3_2" desc="Line-splicing shall not be used in // comments" id="MISRAC2012-RULE_3_2-a" origId="COMMENT-13" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_4_1" desc="Octal and hexadecimal escape sequences shall be terminated" id="MISRAC2012-RULE_4_1-a" origId="CODSTA-117" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_4_2" desc="Trigraphs shall not be used" id="MISRAC2012-RULE_4_2-a" origId="MISRA2004-4_2" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_1" desc="External identifiers shall be distinct" id="MISRAC2012-RULE_5_1-a" origId="CODSTA-178" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c90)" id="MISRAC2012-RULE_5_2-a" origId="CODSTA-179_a_c90" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c99)" id="MISRAC2012-RULE_5_2-b" origId="CODSTA-179_a_c99" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the same block scope and name space shall be distinct (c90)" id="MISRAC2012-RULE_5_2-c" origId="CODSTA-179_b_c90" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the same block scope and name space shall be distinct (c99)" id="MISRAC2012-RULE_5_2-d" origId="CODSTA-179_b_c99" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_5_3" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="MISRAC2012-RULE_5_3-a" origId="MISRA2004-5_2_a" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_3" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="MISRAC2012-RULE_5_3-b" origId="MISRA2004-5_2_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of its parameters(c90)" id="MISRAC2012-RULE_5_4-a" origId="CODSTA-171_c90" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of its parameters(c99)" id="MISRAC2012-RULE_5_4-b" origId="CODSTA-171_c99" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c90)" id="MISRAC2012-RULE_5_4-c" origId="CODSTA-172_c90" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c99)" id="MISRAC2012-RULE_5_4-d" origId="CODSTA-172_c99" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_5" desc="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c90)" id="MISRAC2012-RULE_5_5-a" origId="CODSTA-170_c90" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_5" desc="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c99)" id="MISRAC2012-RULE_5_5-b" origId="CODSTA-170_c99" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="MISRAC2012-RULE_5_6" desc="Do not reuse typedef names" id="MISRAC2012-RULE_5_6-a" origId="MISRA2004-5_3_a" sev="2" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_6" desc="Do not reuse typedef names as a typedef name" id="MISRAC2012-RULE_5_6-b" origId="MISRA2004-5_3_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_7" desc="A tag name shall not be reused for other purpose within the program" id="MISRAC2012-RULE_5_7-a" origId="MISRA2004-5_4_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_7" desc="A tag name shall not be reused to define a different tag" id="MISRAC2012-RULE_5_7-b" origId="MISRA2004-5_4_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_8" desc="Identifiers that define objects or functions with external linkage shall be unique" id="MISRAC2012-RULE_5_8-a" origId="CODSTA-180" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_5_9" desc="No object or function identifier with static storage duration should be reused" id="MISRAC2012-RULE_5_9-a" origId="MISRA2004-5_5_a" sev="4" total="1" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_9" desc="No object or function identifier with static storage duration should be reused" id="MISRAC2012-RULE_5_9-b" origId="MISRA2004-5_5_b" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_6_1" desc="Bit fields shall only be defined to be of type unsigned int or signed int" id="MISRAC2012-RULE_6_1-a" origId="MISRA2004-6_4" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_6_2" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="MISRAC2012-RULE_6_2-a" origId="CODSTA-71" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_6_3" desc="A member of a union shall not be declared as a bit-field" id="MISRAC2012-RULE_6_3-a" origId="CODSTA-02_b" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_7_1" desc="Octal constants (other than zero) shall not be used" id="MISRAC2012-RULE_7_1-a" origId="MISRA2004-7_1_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_7_2" desc="A 'U' suffix shall be applied to all constants of unsigned type" id="MISRAC2012-RULE_7_2-a" origId="MISRA2004-10_6" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_7_3" desc="Use capital 'L' instead of lowercase 'l' to indicate long" id="MISRAC2012-RULE_7_3-a" origId="PORT-01" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_7_4" desc="A string literal shall not be modified" id="MISRAC2012-RULE_7_4-a" origId="PB-27" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_7_5" desc="Arguments of integer-constant macros should be decimal, octal, or hexadecimal constants with appropriate values" id="MISRAC2012-RULE_7_5-a" origId="CODSTA-220" sev="1" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_1" desc="Whenever a function is declared or defined, its type shall be explicitly stated" id="MISRAC2012-RULE_8_1-a" origId="MISRA2004-8_2_a" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_1" desc="Whenever an object is declared or defined, its type shall be explicitly stated" id="MISRAC2012-RULE_8_1-b" origId="MISRA2004-8_2_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_10" desc="An inline function shall be declared with the static storage class" id="MISRAC2012-RULE_8_10-a" origId="CODSTA-120" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_11" desc="When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation" id="MISRAC2012-RULE_8_11-a" origId="MISRA2004-8_12" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_12" desc="Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" id="MISRAC2012-RULE_8_12-a" origId="PB-58" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="15;" authUrg="0;" cat="MISRAC2012-RULE_8_13" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="MISRAC2012-RULE_8_13-a" origId="MISRA2004-16_7" sev="4" total="15" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_13" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRAC2012-RULE_8_13-b" origId="MISRA2004-16_7_b" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_14" desc="The restrict type qualifier shall not be used" id="MISRAC2012-RULE_8_14-a" origId="CODSTA-121" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_15" desc="Explicit alignment specifiers in all declarations of an object with external linkage shall be the same" id="MISRAC2012-RULE_8_15-a" origId="GLOBAL-ALIGNDECL" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_15" desc="Explicit alignment specifiers in all declarations of an object with internal linkage shall be the same" id="MISRAC2012-RULE_8_15-b" origId="CODSTA-MC-04" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_16" desc="The zero-alignment specifier should not be used in an object declaration" id="MISRAC2012-RULE_8_16-a" origId="CODSTA-MC-03" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_17" desc="A declaration of an object should contain at most one explicit alignment specifier" id="MISRAC2012-RULE_8_17-a" origId="CODSTA-MC-02" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_2" desc="Identifiers shall be given for all of the parameters in a function prototype declaration" id="MISRAC2012-RULE_8_2-a" origId="MISRA2004-16_3" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_2" desc="Function types shall have named parameters" id="MISRAC2012-RULE_8_2-b" origId="CODSTA-158" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="11;" authUrg="3;" cat="MISRAC2012-RULE_8_2" desc="Function types shall be in prototype form" id="MISRAC2012-RULE_8_2-c" origId="CODSTA-159" sev="2" total="11" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_3" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRAC2012-RULE_8_3-a" origId="MISRA2004-8_4" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_3" desc="The identifiers used in the declaration and definition of a function shall be identical" id="MISRAC2012-RULE_8_3-b" origId="MISRA2004-16_4" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_8_3" desc="All declarations of an object or function shall have compatible types" id="MISRAC2012-RULE_8_3-c" origId="GLOBAL-COMPATDECLS" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="36;" authUrg="9;" cat="MISRAC2012-RULE_8_4" desc="A declaration shall be visible when an object or function with external linkage is defined" id="MISRAC2012-RULE_8_4-a" origId="CODSTA-118" sev="2" total="36" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_4" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRAC2012-RULE_8_4-b" origId="MISRA2004-8_4" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_5" desc="An external object or function shall not have more than one non-defining declaration in translation unit" id="MISRAC2012-RULE_8_5-a" origId="CODSTA-154" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_8_6" desc="An identifier with external linkage shall have exactly one external definition" id="MISRAC2012-RULE_8_6-a" origId="GLOBAL-ONEEXTERNDEF" sev="2" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="18;" authUrg="0;" cat="MISRAC2012-RULE_8_7" desc="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" id="MISRAC2012-RULE_8_7-a" origId="GLOBAL-AVOIDEXTERN" sev="4" total="18" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_8" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="MISRAC2012-RULE_8_8-a" origId="MISRA2004-8_11" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_9" desc="Objects shall be defined at block scope if they are only accessed from within a single function" id="MISRAC2012-RULE_8_9-a" origId="MISRA2004-8_7" sev="4" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_9_1" desc="Avoid use before initialization" id="MISRAC2012-RULE_9_1-a" origId="BD-PB-NOTINIT" sev="1" total="2" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_2" desc="The initializer for an aggregate or union shall be enclosed in braces" id="MISRAC2012-RULE_9_2-a" origId="INIT-16" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_3" desc="Arrays shall not be partially initialized" id="MISRAC2012-RULE_9_3-a" origId="MISRA2004-9_2_b" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_4" desc="An element of an object shall not be initialized more than once" id="MISRAC2012-RULE_9_4-a" origId="PB-69" sev="2" total="0" />
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_5" desc="Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" id="MISRAC2012-RULE_9_5-a" origId="CODSTA-186" sev="2" total="0" />
         </RulesList>
         <SeverityList>
            <Severity authTot="6;" authUrg="0;" id="1" total="6" />
            <Severity authTot="313;" authUrg="34;" id="2" total="313" />
            <Severity authTot="170;" authUrg="16;" id="4" total="170" />
         </SeverityList>
      </Rules>
      
  <Supps />

      
  <StdViols>
    <StdViol msg="Declaration of object 'cache' does not precede its definition" ln="7" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="7" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_8_4-a" lnHash="-1730052864" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1730052864" unbViolId="75eb4f2e-df23-3eaa-8f72-26ac21b8db22" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9d1e8d8c-20dd-3ff5-bc7e-5d146d4a6129" locEndPos="9" locType="sr" urgent="true" hash="-1375949553" locEndLn="7" goals="1," />
    <StdViol msg="The object 'cache' is referenced only in the translation unit where it is defined" ln="7" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="7" sev="4" auth="root" locRef="1" rule="MISRAC2012-RULE_8_7-a" lnHash="-1730052864" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-1730052864" unbViolId="e5ad7b0a-d612-319a-84db-bdbfde968a46" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e2701a2a-f7eb-386c-9127-a093e13fb989" locEndPos="9" locType="sr" hash="-1375949553" locEndLn="7" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="9" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="1380433239" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1380433239" unbViolId="2aca47c8-1f50-3112-b600-bea0d0833b85" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7fc4469a-3066-3c6e-b45f-2b1123066cf6" locEndPos="1" locType="sr" urgent="true" hash="-1375949553" locEndLn="9" goals="1," />
    <StdViol msg="Prototype of function 'clip' does not precede function definition" ln="9" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="9" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_8_4-a" lnHash="1380433239" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1380433239" unbViolId="0d956fc4-a007-3ca6-b6e7-65fdde08b44a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0c4aa6cf-0884-3066-b703-86d261070884" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="9" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="9" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="1380433239" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1380433239" unbViolId="be4ef398-7037-3f78-89f6-31213f560204" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="733e6e54-d0c7-34b0-be67-83c3af9a1878" locEndPos="10" locType="sr" urgent="true" hash="-1375949553" locEndLn="9" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="9" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="1380433239" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1380433239" unbViolId="b4751bc7-9802-3676-b828-f127fc452d18" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cb9ce433-e974-3f76-9fe0-ee9f69062b11" locEndPos="17" locType="sr" urgent="true" hash="-1375949553" locEndLn="9" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="9" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="1380433239" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1380433239" unbViolId="f50f3ef6-58a3-3d52-bd4b-db72afa1f858" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3ed184e1-eea6-3d5c-8916-816051a37b6f" locEndPos="24" locType="sr" urgent="true" hash="-1375949553" locEndLn="9" goals="1," />
    <StdViol msg="The names of the identifiers 'h' and 'n' (line: 9 in the 'arrayOutOfBounds.c' file) differ only in the interchange of the similar characters" ln="9" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="9" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_5-a" lnHash="1380433239" rule.header="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" tool="c++test" lineHash="1380433239" unbViolId="877359b3-73e4-3d74-9172-1624e1c8214e" locStartPos="27" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="89a02158-04c6-3db8-a957-52b24dca55b7" locEndPos="28" locType="sr" urgent="true" hash="-1375949553" locEndLn="9" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="14" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="14" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="-329440608" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-329440608" unbViolId="0f47d1bf-851f-31cb-a238-5b2f1efdbcfe" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6c748784-47ed-357a-83b2-903c91c9c2e0" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="14" goals="1," />
    <StdViol msg="Prototype of function 'selectPerson' does not precede function definition" ln="18" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="18" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_8_4-a" lnHash="8759389" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="8759389" unbViolId="ca1cdf2e-c6b9-3cc6-96be-628c10c22166" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e23bdf73-b096-3058-8785-036524d7ddc5" locEndPos="9" locType="sr" urgent="true" hash="-1375949553" locEndLn="18" goals="1," />
    <StdViol msg="Function 'selectPerson' is not in prototype form" ln="18" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="18" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_1_5-c" lnHash="8759389" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="8759389" unbViolId="35dd1818-14db-3321-92a7-1ec0e0bbae3f" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d9b83826-4ffa-39a7-928d-2b0474ce9f07" locEndPos="9" locType="sr" urgent="true" hash="-1375949553" locEndLn="18" goals="1," />
    <StdViol msg="Function 'selectPerson' is not in prototype form" ln="18" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="18" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_8_2-c" lnHash="8759389" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="8759389" unbViolId="bae512ca-105a-3aa6-a5d3-e0fad28b0916" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="664a0df4-5fcc-3850-88aa-e1a045979e66" locEndPos="9" locType="sr" urgent="true" hash="-1375949553" locEndLn="18" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="20" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="20" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="521020111" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="521020111" unbViolId="bd7a5a37-1619-32c4-ad4e-9f48fc71f1f9" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d5a4f073-accd-3a8f-9f75-d72805e7a77e" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="20" goals="1," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="21" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="21" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_21_6-a" lnHash="-1553784831" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1553784831" unbViolId="22aa0365-5198-3ec4-a6c7-41a0194c3de3" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2dc2fa13-c76b-36ba-b5d1-e5efd2d5a29b" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="21" goals="1," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="21" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="21" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_17_7-a" lnHash="-1553784831" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1553784831" unbViolId="244c3aab-e7d4-3a57-8062-5a197709b556" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c2d88c47-05cf-3cf7-bda5-b06855a27bf3" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="21" goals="1," />
    <StdViol msg="Usage of 'scanf' function is not allowed" ln="22" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="22" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_21_6-a" lnHash="-1206504513" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1206504513" unbViolId="d4bd406a-e956-321c-a63f-d561275000f6" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ad321501-b056-3f67-98ba-81c85ee327ae" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="22" goals="1," />
    <StdViol msg="Unused function's &quot;scanf&quot; return value" ln="22" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="22" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_17_7-a" lnHash="-1206504513" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1206504513" unbViolId="d7877638-eedc-397d-b5f0-c1d48f19a8b4" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cdaa6027-786a-3585-9de7-69dd49dda132" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="22" goals="1," />
    <StdViol msg="Section of code should not be 'commented out'" ln="24" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="24" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_4-a" lnHash="1548891468" rule.header="Sections of code should not be &quot;commented out&quot;" tool="c++test" lineHash="1548891468" unbViolId="b1852fdb-d935-3309-9663-d24c2773a3be" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ec942f81-3e7c-306b-b809-9edd3c651ffd" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="24" goals="1," />
    <FlowViol msg="Data obtained from a console (&quot;id&quot;, possibly &lt;= -1 or >= 1000) is used to index an array Person *[1000]" ln="27" locFile="/BugDetective/arrayOutOfBounds.c" ruleSAFMsg="Call to a dangerous method" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="23" rule="MISRAC2012-DIR_4_14-a" FirstElSrcRngStartPos="0" lnHash="1552118552" ruleSCSCMsg="Tainting point" FirstElSrcRngFile="/BugDetective/arrayOutOfBounds.c" rule.header="Avoid tainted data in array indexes" FirstElSrcRngStartln="22" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1816942363" lang="cpp" violId="5659d007-047f-3473-92b6-7b36277e913b" locEndPos="0" locEndLn="28" goals="0," locStartln="27" sev="2" locRef="1" tool="c++test" lineHash="1552118552" unbViolId="c511fc76-3b2e-3993-aff6-3d32f9982484" locType="sr" hash="-1375949553" causeLocRef="1">
      <Props>
        <Prop key="Tracked variables" val="Tainted data" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="521020111" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="int id;" ElType="." rngLn="20" />
        <ElDesc lineHash="-1553784831" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="printf(&quot;Please enter person id: \n&quot;);" ElType="." rngLn="21" />
        <ElDesc lineHash="-1206504513" ln="22" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="22" srcRngEndLn="23" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="scanf(&quot;%d&quot;, &amp;id);" ElType=".C" rngLn="22">
          <Props>
            <Prop key="Tracked variables" val="id" />
          </Props>
          <Anns>
            <Ann msg="Tainting point" kind="cause" />
            <Ann msg="Tainted data: id" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1552118552" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="if (cache[id] == 0) {" ElType=".P" rngLn="27">
          <Props>
            <Prop key="Tracked variables" val="id" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: id" kind="var" />
            <Ann msg="Call to a dangerous method" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Expression of pointer type is compared with '0'" ln="27" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="27" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_11_9-a" lnHash="1552118552" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="1552118552" unbViolId="723a8595-2a2c-3be3-bebf-be3a05017cf3" locStartPos="21" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1186fa3f-d396-3e81-8dd9-9626b508b201" locEndPos="22" locType="sr" urgent="true" hash="-1375949553" locEndLn="27" goals="1," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="27" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="27" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_11_9-b" lnHash="1552118552" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="1552118552" unbViolId="9cd21274-e860-3ace-a521-bcdaea8822ff" locStartPos="21" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e7776bdd-4048-3e81-a6fc-563eeed2ff99" locEndPos="22" locType="sr" urgent="true" hash="-1375949553" locEndLn="27" goals="1," />
    <StdViol msg="Prototype of function 'clearCache' does not precede function definition" ln="33" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="33" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_8_4-a" lnHash="982887335" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="982887335" unbViolId="807d9424-6839-3770-a13b-50c475085a59" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="56eb4083-213e-3be7-8505-126e96364cdd" locEndPos="6" locType="sr" urgent="true" hash="-1375949553" locEndLn="33" goals="1," />
    <StdViol msg="The function 'clearCache' is referenced only in the translation unit where it is defined" ln="33" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="33" sev="4" auth="root" locRef="1" rule="MISRAC2012-RULE_8_7-a" lnHash="982887335" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="982887335" unbViolId="cdf4818e-6ee7-315f-8d95-d944cbf4f9d3" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="8d03d002-f4c9-385a-a7d8-067e73f28879" locEndPos="6" locType="sr" hash="-1375949553" locEndLn="33" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="33" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="33" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="982887335" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="982887335" unbViolId="ff2fb230-3962-396e-b535-8a225806e320" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="10054950-7baa-3660-b516-fb3403af2ad0" locEndPos="17" locType="sr" urgent="true" hash="-1375949553" locEndLn="33" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="33" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="33" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="982887335" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="982887335" unbViolId="58f6f4d3-09e3-3ade-874a-6f78115366be" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e18202e1-85f2-3da7-90e3-ef36868afec6" locEndPos="30" locType="sr" urgent="true" hash="-1375949553" locEndLn="33" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="35" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="35" sev="4" auth="root" locRef="1" rule="MISRAC2012-DIR_4_6-b" lnHash="1679375043" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1679375043" unbViolId="373ba67a-6c7d-3f51-ac34-f84e30e618db" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fcc6342b-3f92-36eb-b4a3-43fa7e944a51" locEndPos="5" locType="sr" urgent="true" hash="-1375949553" locEndLn="35" goals="1," />
    <FlowViol msg="Possibly accessing array &quot;cache&quot; out of bounds at index [1...1000]. Correct index(es): [0...999]" ln="37" locFile="/BugDetective/arrayOutOfBounds.c" ruleSAFMsg="Out of bounds access point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="45" rule="MISRAC2012-DIR_4_1-a" FirstElSrcRngStartPos="0" lnHash="308957226" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/arrayOutOfBounds.c" rule.header="Avoid accessing arrays out of bounds" FirstElSrcRngStartln="44" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1283572058" lang="cpp" violId="a3a2f4db-c39a-3d69-abc6-37e5e0978842" locEndPos="0" locEndLn="38" goals="0," locStartln="37" sev="2" locRef="1" tool="c++test" lineHash="308957226" unbViolId="b7024bf0-a644-3768-9ca6-ac32c391411a" locType="sr" hash="-1375949553" causeLocRef="1">
      <Props />
      <ElDescList>
        <ElDesc lineHash="-1961341245" ln="44" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="44" srcRngEndLn="45" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="void clearAllCache()" ElType=".C" rngLn="44">
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1825717159" ln="46" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="46" srcRngEndLn="47" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="clearCache(0, CACHE_SIZE /* -1 */ ); /* Uncomment to fix accessing out of bounds */" ElType="!" rngLn="46">
          <ElDescList>
            <ElDesc lineHash="1679375043" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="int i;" ElType="." rngLn="35" />
            <ElDesc lineHash="-1540506943" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="for (i = from_id; i &lt;= to_id; i++) {" ElType="." rngLn="36">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt;= to_id) (true)" kind="condEval" />
                <Ann msg="Entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="308957226" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="if (cache[i] != 0) {" ElType="." rngLn="37">
              <Anns>
                <Ann msg="Condition evaluation: (cache[i] != 0) (assuming false)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="-1540506943" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="for (i = from_id; i &lt;= to_id; i++) {" ElType="." rngLn="36">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt;= to_id) (true)" kind="condEval" />
                <Ann msg="Entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="308957226" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="if (cache[i] != 0) {" ElType=".P" rngLn="37">
              <Anns>
                <Ann msg="Out of bounds access point" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Possibly accessing array &quot;cache&quot; out of bounds at index [1...1000]. Correct index(es): [0...999]" ln="37" locFile="/BugDetective/arrayOutOfBounds.c" ruleSAFMsg="Out of bounds access point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="45" rule="MISRAC2012-RULE_18_1-a" FirstElSrcRngStartPos="0" lnHash="308957226" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/arrayOutOfBounds.c" rule.header="Avoid accessing arrays out of bounds" FirstElSrcRngStartln="44" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1016175346" lang="cpp" violId="9ac6772f-9a7f-3ccb-9ffd-74dd47af9a6e" locEndPos="0" locEndLn="38" goals="0," locStartln="37" sev="2" locRef="1" tool="c++test" lineHash="308957226" unbViolId="adb199f0-3232-39bc-ab5b-8483c974e423" locType="sr" hash="-1375949553" causeLocRef="1">
      <Props />
      <ElDescList>
        <ElDesc lineHash="-1961341245" ln="44" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="44" srcRngEndLn="45" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="void clearAllCache()" ElType=".C" rngLn="44">
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1825717159" ln="46" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="46" srcRngEndLn="47" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="clearCache(0, CACHE_SIZE /* -1 */ ); /* Uncomment to fix accessing out of bounds */" ElType="!" rngLn="46">
          <ElDescList>
            <ElDesc lineHash="1679375043" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="int i;" ElType="." rngLn="35" />
            <ElDesc lineHash="-1540506943" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="for (i = from_id; i &lt;= to_id; i++) {" ElType="." rngLn="36">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt;= to_id) (true)" kind="condEval" />
                <Ann msg="Entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="308957226" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="if (cache[i] != 0) {" ElType="." rngLn="37">
              <Anns>
                <Ann msg="Condition evaluation: (cache[i] != 0) (assuming false)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="-1540506943" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="for (i = from_id; i &lt;= to_id; i++) {" ElType="." rngLn="36">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt;= to_id) (true)" kind="condEval" />
                <Ann msg="Entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="308957226" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="-1375949553" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/arrayOutOfBounds.c" desc="if (cache[i] != 0) {" ElType=".P" rngLn="37">
              <Anns>
                <Ann msg="Out of bounds access point" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Expression of pointer type is compared with '0'" ln="37" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="37" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_11_9-a" lnHash="308957226" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="308957226" unbViolId="c68c159b-a73a-394c-a9fc-79f169490ae7" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a8fbd14e-65c4-3fe8-ba8c-b5001d734128" locEndPos="25" locType="sr" urgent="true" hash="-1375949553" locEndLn="37" goals="1," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="37" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="37" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_11_9-b" lnHash="308957226" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="308957226" unbViolId="0b2713e9-1a03-3e12-8ec4-4185ae9203b1" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="62d9e1d6-48c3-35a4-8a1a-16a17df0bbd6" locEndPos="25" locType="sr" urgent="true" hash="-1375949553" locEndLn="37" goals="1," />
    <StdViol msg="'free' function should not be used" ln="38" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="38" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_21_3-a" lnHash="1660808731" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1660808731" unbViolId="b10ad04b-4043-308b-929e-656f84bc5cbf" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a3c0b979-3303-3889-be9b-f821ef74f139" locEndPos="13" locType="sr" urgent="true" hash="-1375949553" locEndLn="38" goals="1," />
    <StdViol msg="'free' function should not be used" ln="38" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="38" sev="2" auth="root" locRef="1" rule="MISRAC2012-DIR_4_12-a" lnHash="1660808731" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1660808731" unbViolId="4bffe3fb-8109-3b1e-bfa2-374fae982aac" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e32aa4cc-5c01-3e81-a76b-be67639fe243" locEndPos="13" locType="sr" urgent="true" hash="-1375949553" locEndLn="38" goals="1," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="39" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="39" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_11_9-a" lnHash="1660096801" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="1660096801" unbViolId="b3f4e3eb-f2b9-364f-a980-7d7c491dc797" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="72542b6b-17cc-3a60-a433-e8ce5e7d506e" locEndPos="24" locType="sr" urgent="true" hash="-1375949553" locEndLn="39" goals="1," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="39" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="39" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_11_9-b" lnHash="1660096801" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="1660096801" unbViolId="d8943dd3-54ea-3fd9-994b-a33cde1fec23" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d0340173-e01c-3f77-bf8d-ef47cebecbd1" locEndPos="24" locType="sr" urgent="true" hash="-1375949553" locEndLn="39" goals="1," />
    <StdViol msg="Prototype of function 'clearAllCache' does not precede function definition" ln="44" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="44" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_8_4-a" lnHash="-1961341245" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1961341245" unbViolId="8879a3c8-16af-339e-a961-9c95c9322432" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="58ee5090-2a2c-3fbc-a69b-f7822f314773" locEndPos="6" locType="sr" urgent="true" hash="-1375949553" locEndLn="44" goals="1," />
    <StdViol msg="Function 'clearAllCache' is not in prototype form" ln="44" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="44" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_1_5-c" lnHash="-1961341245" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="-1961341245" unbViolId="9c8e2a5a-d890-3dd1-821e-a14da6faef9d" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="691c3343-ed07-3caa-a162-fa10a16fcf85" locEndPos="6" locType="sr" urgent="true" hash="-1375949553" locEndLn="44" goals="1," />
    <StdViol msg="Function 'clearAllCache' is not in prototype form" ln="44" locFile="/BugDetective/arrayOutOfBounds.c" locStartln="44" sev="2" auth="root" locRef="1" rule="MISRAC2012-RULE_8_2-c" lnHash="-1961341245" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="-1961341245" unbViolId="f0e7dd96-9f78-377f-9112-482aa60d166c" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9f2f757e-af5e-376e-9ed1-ad0a8603301c" locEndPos="6" locType="sr" urgent="true" hash="-1375949553" locEndLn="44" goals="1," />
    <StdViol msg="Declaration of object 'buffer' does not precede its definition" ln="7" locFile="/BugDetective/bufferOverflow.c" locStartln="7" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_8_4-a" lnHash="-2118839699" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-2118839699" unbViolId="f9bea13a-dfae-3321-9e0a-7695b88f2c32" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3ff7a3e9-4bcf-361d-be28-db2c81a1d0e7" locEndPos="6" locType="sr" urgent="true" hash="1082458265" locEndLn="7" goals="1," />
    <StdViol msg="The 'buffer' object is also defined in other translation units" ln="7" locFile="/BugDetective/bufferOverflow.c" locStartln="7" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_8_6-a" lnHash="-2118839699" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="-2118839699" unbViolId="1b79dfa9-a275-38f6-8e40-4130967a4d31" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="b0650ad5-a5e1-3597-b9ea-5e0917afdcf9" locEndPos="6" locType="sr" hash="1082458265" locEndLn="7" goals="0," />
    <StdViol msg="The 'buffer' object has incompatible declarations in other translation units" ln="7" locFile="/BugDetective/bufferOverflow.c" locStartln="7" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_8_3-c" lnHash="-2118839699" rule.header="All declarations of an object or function shall have compatible types" tool="c++test" lineHash="-2118839699" unbViolId="39b74486-5cee-38fc-b40e-80a13431ad88" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="a6b01b3b-f097-35ac-9bd4-d45850044e48" locEndPos="6" locType="sr" hash="1082458265" locEndLn="7" goals="0," />
    <StdViol msg="Prototype of function 'fillBuffer' does not precede function definition" ln="9" locFile="/BugDetective/bufferOverflow.c" locStartln="9" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_8_4-a" lnHash="1243569904" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1243569904" unbViolId="533e6340-6497-35ed-ad8a-efa2ef962a7c" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4d7fb7fd-3c4c-35cf-9987-acf697857437" locEndPos="6" locType="sr" urgent="true" hash="1082458265" locEndLn="9" goals="1," />
    <StdViol msg="Function 'fillBuffer' is not in prototype form" ln="9" locFile="/BugDetective/bufferOverflow.c" locStartln="9" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_1_5-c" lnHash="1243569904" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1243569904" unbViolId="322995ea-a10f-35f4-a72f-75773aebda22" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7ac6487-79e4-393e-9935-43962bc3effe" locEndPos="6" locType="sr" urgent="true" hash="1082458265" locEndLn="9" goals="1," />
    <StdViol msg="Function 'fillBuffer' is not in prototype form" ln="9" locFile="/BugDetective/bufferOverflow.c" locStartln="9" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_8_2-c" lnHash="1243569904" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1243569904" unbViolId="452b04e3-e96a-3bca-adde-848070dfd50e" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="128f7133-bdcb-3900-8bfe-7488b9908fc9" locEndPos="6" locType="sr" urgent="true" hash="1082458265" locEndLn="9" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="11" locFile="/BugDetective/bufferOverflow.c" locStartln="11" sev="4" auth="root" locRef="2" rule="MISRAC2012-DIR_4_6-b" lnHash="-664043208" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-664043208" unbViolId="cab5f949-be25-3ebe-8022-5566a3847351" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3de82eb6-21a6-3fa3-93f2-2b1aea348ab6" locEndPos="5" locType="sr" hash="1082458265" locEndLn="11" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="12" locFile="/BugDetective/bufferOverflow.c" locStartln="12" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_21_6-a" lnHash="-1303763578" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1303763578" unbViolId="467c33c8-7a88-3b42-884e-fd1d6880872c" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3d80ebec-caa7-3917-ad47-204e5e8da343" locEndPos="5" locType="sr" urgent="true" hash="1082458265" locEndLn="12" goals="1," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="12" locFile="/BugDetective/bufferOverflow.c" locStartln="12" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_17_7-a" lnHash="-1303763578" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1303763578" unbViolId="be83fa1d-14cf-32cb-8415-ac66a32f7994" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="98cf9f66-1835-3ff8-92fe-2a35a0ac8c94" locEndPos="5" locType="sr" hash="1082458265" locEndLn="12" goals="0," />
    <StdViol msg="Usage of 'scanf' function is not allowed" ln="13" locFile="/BugDetective/bufferOverflow.c" locStartln="13" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_21_6-a" lnHash="-2063599685" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-2063599685" unbViolId="5ca7490c-a07a-3ce2-9f35-0ebc8234e951" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="254ec2b6-3ada-30db-84d5-efb85ac3fc03" locEndPos="5" locType="sr" urgent="true" hash="1082458265" locEndLn="13" goals="1," />
    <StdViol msg="Unused function's &quot;scanf&quot; return value" ln="13" locFile="/BugDetective/bufferOverflow.c" locStartln="13" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_17_7-a" lnHash="-2063599685" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-2063599685" unbViolId="45a5bbf1-a5c4-3422-8984-db96e1d25303" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a4e463b6-a39f-39f7-a063-0165b3e65b28" locEndPos="5" locType="sr" hash="1082458265" locEndLn="13" goals="0," />
    <StdViol msg="Section of code should not be 'commented out'" ln="15" locFile="/BugDetective/bufferOverflow.c" locStartln="15" sev="4" auth="root" locRef="2" rule="MISRAC2012-DIR_4_4-a" lnHash="993249569" rule.header="Sections of code should not be &quot;commented out&quot;" tool="c++test" lineHash="993249569" unbViolId="9f53dd58-901b-3bc4-bebe-525c266290a5" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2dcc67a5-505d-35ca-9c4c-a5eed18b4131" locEndPos="5" locType="sr" hash="1082458265" locEndLn="15" goals="0," />
    <FlowViol msg="Overflow when writing to buffer &quot;buffer&quot; (char[999], 999 bytes large). Number of bytes written is an arbitrary value possibly >= 999" ln="21" locFile="/BugDetective/bufferOverflow.c" ruleSAFMsg="Point where the buffer overflow occurs" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="14" rule="MISRAC2012-DIR_4_14-d" FirstElSrcRngStartPos="0" lnHash="-402612242" ruleSCSCMsg="Point where number of elements to write is defined by tainting function" FirstElSrcRngFile="/BugDetective/bufferOverflow.c" rule.header="Avoid buffer write overflow from tainted data" FirstElSrcRngStartln="13" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="40924891" lang="cpp" violId="e4ce1758-086b-338a-a6c7-c556aa966290" locEndPos="0" locEndLn="22" goals="0," locStartln="21" sev="2" locRef="2" tool="c++test" lineHash="-402612242" unbViolId="122c7734-c007-3e83-8309-8d574fad270e" locType="sr" hash="1082458265" causeLocRef="2">
      <Props>
        <Prop key="Tracked variables" val="Tainted data" />
        <Prop key="Important values" val="Tainted data" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-664043208" ln="11" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="11" srcRngEndLn="12" srcRngFile="/BugDetective/bufferOverflow.c" desc="int size, character;" ElType="." rngLn="11" />
        <ElDesc lineHash="-1303763578" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/bufferOverflow.c" desc="printf(&quot;Please enter filling parameters: \n&quot;);" ElType="." rngLn="12" />
        <ElDesc lineHash="-2063599685" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/bufferOverflow.c" desc="scanf(&quot;%d%d&quot;, &amp;size, &amp;character);" ElType=".C" rngLn="13">
          <Props>
            <Prop key="Tracked variables" val="size" />
            <Prop key="Important values" val="char buffer[999]" />
          </Props>
          <Anns>
            <Ann msg="Point where number of elements to write is defined by tainting function" kind="cause" />
            <Ann msg="Tainted data: size" kind="var" />
            <Ann msg="Tainted data: char buffer[999]" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-402612242" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/bufferOverflow.c" desc="memset(buffer, character, size); /* POSSIBLE BUFFER OVERFLOW HERE */" ElType=".P" rngLn="21">
          <Props>
            <Prop key="Tracked variables" val="size" />
            <Prop key="Important values" val="char buffer[999]" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: size" kind="var" />
            <Ann msg="Tainted data: char buffer[999]" kind="var" />
            <Ann msg="Point where the buffer overflow occurs" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Unused function's &quot;memset&quot; return value" ln="21" locFile="/BugDetective/bufferOverflow.c" locStartln="21" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_17_7-a" lnHash="-402612242" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-402612242" unbViolId="3346bca0-e7c7-33bc-b6d9-ba6b5381c9af" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="34914237-d07a-34b4-97df-0e78b2ca2129" locEndPos="5" locType="sr" hash="1082458265" locEndLn="21" goals="0," />
    <StdViol msg="The argument number '3' ('essentially signed' type) is passed to the function 'memset' as a parameter with the 'essentially unsigned' type" ln="21" locFile="/BugDetective/bufferOverflow.c" locStartln="21" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_10_3-b" lnHash="-402612242" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="-402612242" unbViolId="3757637e-08b6-3011-8ebe-960992dd2aae" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="492b1c30-40f7-35a6-ba4b-d89b2ad174a5" locEndPos="31" locType="sr" urgent="true" hash="1082458265" locEndLn="21" goals="1," />
    <StdViol msg="Prototype of function 'resetBuffer' does not precede function definition" ln="24" locFile="/BugDetective/bufferOverflow.c" locStartln="24" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_8_4-a" lnHash="990130130" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="990130130" unbViolId="56388ad7-7c07-3d46-9eda-6acf5f65ccc6" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5cb321f2-fee5-3c77-987b-8304535c9f06" locEndPos="6" locType="sr" urgent="true" hash="1082458265" locEndLn="24" goals="1," />
    <StdViol msg="The function 'resetBuffer' is referenced only in the translation unit where it is defined" ln="24" locFile="/BugDetective/bufferOverflow.c" locStartln="24" sev="4" auth="root" locRef="2" rule="MISRAC2012-RULE_8_7-a" lnHash="990130130" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="990130130" unbViolId="ce111021-86d3-38b8-90c3-36c64a06fd2d" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e9c506d5-0b85-3b70-a708-9753671c2877" locEndPos="6" locType="sr" hash="1082458265" locEndLn="24" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="24" locFile="/BugDetective/bufferOverflow.c" locStartln="24" sev="4" auth="root" locRef="2" rule="MISRAC2012-DIR_4_6-b" lnHash="990130130" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="990130130" unbViolId="0b9321df-b7dc-3206-9e28-daf07b816aae" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0cb67f26-769a-3a0d-b23a-c4f18e4c2f11" locEndPos="18" locType="sr" hash="1082458265" locEndLn="24" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/BugDetective/bufferOverflow.c" locStartln="26" sev="4" auth="root" locRef="2" rule="MISRAC2012-DIR_4_6-b" lnHash="1679375043" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1679375043" unbViolId="4684d9da-14de-3bd0-a6d2-8e00c560ece7" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="305d3b28-4ef2-3639-afb6-952dacc4d0eb" locEndPos="5" locType="sr" hash="1082458265" locEndLn="26" goals="0," />
    <FlowViol msg="The size of the &quot;buffer&quot; buffer passed to the &quot;memset&quot; function is 999 bytes, which is smaller than number of bytes to process (= 1000)" ln="27" locFile="/BugDetective/bufferOverflow.c" ruleSAFMsg="Point where buffer is passed to the function" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="34" rule="MISRAC2012-RULE_21_18-a" FirstElSrcRngStartPos="0" lnHash="1283866216" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/bufferOverflow.c" rule.header="The size_t argument passed to any function in string.h shall have an appropriate value" FirstElSrcRngStartln="33" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1362558834" lang="cpp" violId="493f6e88-266a-3019-88ed-9988c840aacc" locEndPos="0" locEndLn="28" goals="0," locStartln="27" sev="1" locRef="2" tool="c++test" lineHash="1283866216" unbViolId="765266ee-5439-37d3-88a8-6455bacddb4e" locType="sr" hash="1082458265" causeLocRef="2">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1212873409" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/bufferOverflow.c" desc="resetBuffer(1000 /* BUFFER_SIZE */); /* POSSIBLE BUFFER OVERFLOW HERE */" ElType=".C" rngLn="33">
          <ElDescList>
            <ElDesc lineHash="1679375043" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/bufferOverflow.c" desc="int i;" ElType="." rngLn="26" />
            <ElDesc lineHash="1283866216" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/bufferOverflow.c" desc="memset(buffer, 0, size);" ElType=".P" rngLn="27">
              <Anns>
                <Ann msg="Point where buffer is passed to the function" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Overflow when writing to buffer &quot;buffer&quot; (char[999], 999 bytes large). Number of bytes written = 1000" ln="27" locFile="/BugDetective/bufferOverflow.c" ruleSAFMsg="Point where the buffer overflow occurs" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="28" rule="MISRAC2012-DIR_4_1-h" FirstElSrcRngStartPos="0" lnHash="1283866216" ruleSCSCMsg="Point where number of elements to write is defined" FirstElSrcRngFile="/BugDetective/bufferOverflow.c" rule.header="Avoid overflow when writing to a buffer" FirstElSrcRngStartln="27" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-334608489" lang="cpp" violId="b2ceb48c-56ea-32f3-970a-2e37f0be78ea" locEndPos="0" locEndLn="28" goals="0," locStartln="27" sev="2" locRef="2" tool="c++test" lineHash="1283866216" unbViolId="18cf8c2a-ea54-3187-8c4e-58d0a8a99c75" locType="sr" hash="1082458265" causeLocRef="2">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1212873409" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/bufferOverflow.c" desc="resetBuffer(1000 /* BUFFER_SIZE */); /* POSSIBLE BUFFER OVERFLOW HERE */" ElType="!" rngLn="33">
          <ElDescList>
            <ElDesc lineHash="1679375043" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/bufferOverflow.c" desc="int i;" ElType="." rngLn="26" />
            <ElDesc lineHash="1283866216" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/bufferOverflow.c" desc="memset(buffer, 0, size);" ElType="CP" rngLn="27">
              <Anns>
                <Ann msg="Point where number of elements to write is defined" kind="cause" />
                <Ann msg="Point where the buffer overflow occurs" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Overflow when writing to buffer &quot;buffer&quot; (char[999], 999 bytes large). Number of bytes written = 1000" ln="27" locFile="/BugDetective/bufferOverflow.c" ruleSAFMsg="Point where the buffer overflow occurs" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="28" rule="MISRAC2012-RULE_1_3-e" FirstElSrcRngStartPos="0" lnHash="1283866216" ruleSCSCMsg="Point where number of elements to write is defined" FirstElSrcRngFile="/BugDetective/bufferOverflow.c" rule.header="Avoid overflow when writing to a buffer" FirstElSrcRngStartln="27" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="81350754" lang="cpp" violId="70650358-e9cb-3a27-8c34-d55ee77a67e1" locEndPos="0" locEndLn="28" goals="0," locStartln="27" sev="2" locRef="2" tool="c++test" lineHash="1283866216" unbViolId="5aba9bbf-7e70-3467-b724-e5c7cbc65c16" locType="sr" hash="1082458265" causeLocRef="2">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1212873409" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/bufferOverflow.c" desc="resetBuffer(1000 /* BUFFER_SIZE */); /* POSSIBLE BUFFER OVERFLOW HERE */" ElType="!" rngLn="33">
          <ElDescList>
            <ElDesc lineHash="1679375043" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/bufferOverflow.c" desc="int i;" ElType="." rngLn="26" />
            <ElDesc lineHash="1283866216" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/bufferOverflow.c" desc="memset(buffer, 0, size);" ElType="CP" rngLn="27">
              <Anns>
                <Ann msg="Point where number of elements to write is defined" kind="cause" />
                <Ann msg="Point where the buffer overflow occurs" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Overflow when writing to buffer &quot;buffer&quot; (char[999], 999 bytes large). Number of bytes written = 1000" ln="27" locFile="/BugDetective/bufferOverflow.c" ruleSAFMsg="Point where the buffer overflow occurs" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="28" rule="MISRAC2012-RULE_21_17-b" FirstElSrcRngStartPos="0" lnHash="1283866216" ruleSCSCMsg="Point where number of elements to write is defined" FirstElSrcRngFile="/BugDetective/bufferOverflow.c" rule.header="Avoid overflow when writing to a buffer" FirstElSrcRngStartln="27" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-260330208" lang="cpp" violId="0a82e763-7c99-3794-821c-4c1d8abb664d" locEndPos="0" locEndLn="28" goals="0," locStartln="27" sev="1" locRef="2" tool="c++test" lineHash="1283866216" unbViolId="6af5daae-4456-35a2-bfe7-981e3091453e" locType="sr" hash="1082458265" causeLocRef="2">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1212873409" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/bufferOverflow.c" desc="resetBuffer(1000 /* BUFFER_SIZE */); /* POSSIBLE BUFFER OVERFLOW HERE */" ElType="!" rngLn="33">
          <ElDescList>
            <ElDesc lineHash="1679375043" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/bufferOverflow.c" desc="int i;" ElType="." rngLn="26" />
            <ElDesc lineHash="1283866216" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="1082458265" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/bufferOverflow.c" desc="memset(buffer, 0, size);" ElType="CP" rngLn="27">
              <Anns>
                <Ann msg="Point where number of elements to write is defined" kind="cause" />
                <Ann msg="Point where the buffer overflow occurs" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Unused function's &quot;memset&quot; return value" ln="27" locFile="/BugDetective/bufferOverflow.c" locStartln="27" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_17_7-a" lnHash="1283866216" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="1283866216" unbViolId="7f19452f-40aa-3042-9f87-b4e8554fe1f8" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bd288138-42c4-333f-85b5-0034635a8421" locEndPos="5" locType="sr" hash="1082458265" locEndLn="27" goals="0," />
    <StdViol msg="The argument number '3' ('essentially signed' type) is passed to the function 'memset' as a parameter with the 'essentially unsigned' type" ln="27" locFile="/BugDetective/bufferOverflow.c" locStartln="27" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_10_3-b" lnHash="1283866216" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="1283866216" unbViolId="03f9fe9b-1924-3fd5-b4ad-720032dd8f56" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="043d8420-259a-365f-8960-59b1d28d9cbe" locEndPos="23" locType="sr" urgent="true" hash="1082458265" locEndLn="27" goals="1," />
    <StdViol msg="Prototype of function 'resetAll' does not precede function definition" ln="30" locFile="/BugDetective/bufferOverflow.c" locStartln="30" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_8_4-a" lnHash="1718585439" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1718585439" unbViolId="5c0eb9cd-402a-38ed-8e16-182f71eb4e41" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0f70a23d-672d-339e-8192-48899452cdd3" locEndPos="6" locType="sr" urgent="true" hash="1082458265" locEndLn="30" goals="1," />
    <StdViol msg="Function 'resetAll' is not in prototype form" ln="30" locFile="/BugDetective/bufferOverflow.c" locStartln="30" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_1_5-c" lnHash="1718585439" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1718585439" unbViolId="41a7432b-0dcd-3654-8869-1a663299f3b4" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7c5a9579-c945-316e-a6d1-c4c24e682f5c" locEndPos="6" locType="sr" urgent="true" hash="1082458265" locEndLn="30" goals="1," />
    <StdViol msg="Function 'resetAll' is not in prototype form" ln="30" locFile="/BugDetective/bufferOverflow.c" locStartln="30" sev="2" auth="root" locRef="2" rule="MISRAC2012-RULE_8_2-c" lnHash="1718585439" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1718585439" unbViolId="035328d2-c8d3-3149-8d6b-7f24bf91cb54" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4f442bef-3173-33e8-b811-758a611855e8" locEndPos="6" locType="sr" hash="1082458265" locEndLn="30" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" locFile="/BugDetective/dbutil.c" locStartln="5" sev="4" auth="root" locRef="3" rule="MISRAC2012-DIR_4_6-b" lnHash="1488835897" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1488835897" unbViolId="d6821dad-5619-3c2c-ac23-1d9c28855c04" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fea24188-e577-372f-a9c9-3d0e424ade92" locEndPos="30" locType="sr" hash="-892903586" locEndLn="5" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="8" locFile="/BugDetective/dbutil.c" locStartln="8" sev="4" auth="root" locRef="3" rule="MISRAC2012-DIR_4_6-b" lnHash="932373780" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="932373780" unbViolId="76680146-a4f3-3754-90c0-f5ce1c042a6a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="60e6bb4b-b2f2-304f-8389-6df84f6a5c01" locEndPos="5" locType="sr" hash="-892903586" locEndLn="8" goals="0," />
    <StdViol msg="Provide only one exit point in 'retrievePersonFromDB' function" ln="10" locFile="/BugDetective/dbutil.c" locStartln="10" sev="4" auth="root" locRef="3" rule="MISRAC2012-RULE_15_5-a" lnHash="-1561874268" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1561874268" unbViolId="fbcbb229-cb32-3a20-a153-90427ffb64ff" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5c6cadcc-3143-3bd9-9b0a-56a90debbfff" locEndPos="9" locType="sr" hash="-892903586" locEndLn="10" goals="0," />
    <StdViol msg="Pointer to void type should not be converted to pointer to object type 'Person *'" ln="12" locFile="/BugDetective/dbutil.c" locStartln="12" sev="4" auth="root" locRef="3" rule="MISRAC2012-RULE_11_5-a" lnHash="-816996275" rule.header="A conversion should not be performed from pointer to void into pointer to object" tool="c++test" lineHash="-816996275" unbViolId="06f08bc0-8c4c-3c0e-8518-470f40bc3f8c" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2727d224-c5a1-34f0-a016-4b8d8728fb6c" locEndPos="9" locType="sr" hash="-892903586" locEndLn="12" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="12" locFile="/BugDetective/dbutil.c" locStartln="12" sev="2" auth="root" locRef="3" rule="MISRAC2012-RULE_21_3-a" lnHash="-816996275" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-816996275" unbViolId="0d86be7e-d6cf-33c2-8235-3576012939a6" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1928bec3-8964-3318-a9ca-9268a6cd7315" locEndPos="18" locType="sr" hash="-892903586" locEndLn="12" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="12" locFile="/BugDetective/dbutil.c" locStartln="12" sev="2" auth="root" locRef="3" rule="MISRAC2012-DIR_4_12-a" lnHash="-816996275" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-816996275" unbViolId="0e38cf14-b882-3318-899f-1773badf2d17" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3e320973-d322-39ee-83c6-5ce7f55be01a" locEndPos="18" locType="sr" hash="-892903586" locEndLn="12" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'retrievePersonFromDB' should be followed by a block" ln="13" locFile="/BugDetective/dbutil.c" locStartln="13" sev="2" auth="root" locRef="3" rule="MISRAC2012-RULE_15_6-b" lnHash="-413015691" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-413015691" unbViolId="98673366-250d-333c-af40-30fcfbe73e62" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e3a9e246-80bf-30d0-bbaa-1229719af5f9" locEndPos="5" locType="sr" hash="-892903586" locEndLn="13" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="13" locFile="/BugDetective/dbutil.c" locStartln="13" sev="2" auth="root" locRef="3" rule="MISRAC2012-RULE_11_9-a" lnHash="-413015691" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-413015691" unbViolId="55db39a9-fe38-39ca-b1a3-64189f855929" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6f813b07-feda-363f-8cf5-ff835e6627d1" locEndPos="14" locType="sr" hash="-892903586" locEndLn="13" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="13" locFile="/BugDetective/dbutil.c" locStartln="13" sev="2" auth="root" locRef="3" rule="MISRAC2012-RULE_11_9-b" lnHash="-413015691" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-413015691" unbViolId="e49d3ce1-8def-3273-b0f2-d71700c0b3a7" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dd2ffa0a-5c83-3883-a420-2c01f9964af8" locEndPos="14" locType="sr" hash="-892903586" locEndLn="13" goals="0," />
    <StdViol msg="Provide only one exit point in 'retrievePersonFromDB' function" ln="13" locFile="/BugDetective/dbutil.c" locStartln="13" sev="4" auth="root" locRef="3" rule="MISRAC2012-RULE_15_5-a" lnHash="-413015691" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-413015691" unbViolId="9cfc307a-aead-3b50-9d1c-5c04d72e0a78" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ed67fadc-1f3b-3f1b-a0ba-5d370304c7f0" locEndPos="17" locType="sr" hash="-892903586" locEndLn="13" goals="0," />
    <StdViol msg="The 'exit' library function should not be used" ln="13" locFile="/BugDetective/dbutil.c" locStartln="13" sev="2" auth="root" locRef="3" rule="MISRAC2012-RULE_21_8-b" lnHash="-413015691" rule.header="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" tool="c++test" lineHash="-413015691" unbViolId="e33199e5-7509-3d8c-9326-36c73829402b" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ef8d22c9-e4ff-310c-ac2f-908102aa09fe" locEndPos="17" locType="sr" hash="-892903586" locEndLn="13" goals="0," />
    <StdViol msg="Provide only one exit point in 'retrievePersonFromDB' function" ln="15" locFile="/BugDetective/dbutil.c" locStartln="15" sev="4" auth="root" locRef="3" rule="MISRAC2012-RULE_15_5-a" lnHash="-1256394053" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256394053" unbViolId="40663ff3-c957-3b75-85fa-b793d305e63c" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fb3ba0de-b68a-374c-8d3f-ec71f25dc371" locEndPos="5" locType="sr" hash="-892903586" locEndLn="15" goals="0," />
    <StdViol msg="Prototype of function 'displayPersonalInfo' does not precede function definition" ln="5" locFile="/BugDetective/divisionByZero.c" locStartln="5" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_8_4-a" lnHash="-1399767151" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1399767151" unbViolId="6117559f-ff87-339f-8e8e-6608f0d9905d" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c6ddc72f-1c8f-3fac-9c7e-d9524fc3e01e" locEndPos="6" locType="sr" hash="1923244810" locEndLn="5" goals="0," />
    <StdViol msg="The function 'displayPersonalInfo' is referenced only in the translation unit where it is defined" ln="5" locFile="/BugDetective/divisionByZero.c" locStartln="5" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_8_7-a" lnHash="-1399767151" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-1399767151" unbViolId="0b81fe89-3df2-3d25-9b74-43e5c54e8b19" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="142e2bf3-277c-30a1-b09b-56a31aca5d19" locEndPos="6" locType="sr" hash="1923244810" locEndLn="5" goals="0," />
    <StdViol msg="The names of the identifiers 'person' and 'Person' (line: 7 in the 'dbutil.h' file) differ only in capitalization" ln="5" locFile="/BugDetective/divisionByZero.c" locStartln="5" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_5-a" lnHash="-1399767151" rule.header="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" tool="c++test" lineHash="-1399767151" unbViolId="b2e4f021-0487-34c6-bbaa-2dcc82290443" locStartPos="33" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b30a3d42-566e-32e6-b551-1647b56af05c" locEndPos="34" locType="sr" hash="1923244810" locEndLn="5" goals="0," />
    <StdViol msg="Pass parameter &quot;person&quot; with const specifier" ln="5" locFile="/BugDetective/divisionByZero.c" locStartln="5" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_8_13-a" lnHash="-1399767151" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="-1399767151" unbViolId="638b13c9-2aeb-35c9-8176-2f82df39142e" locStartPos="33" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aa2cfb53-07cb-3889-8771-319008463af5" locEndPos="34" locType="sr" hash="1923244810" locEndLn="5" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="7" locFile="/BugDetective/divisionByZero.c" locStartln="7" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_6-a" lnHash="-194506379" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-194506379" unbViolId="8605c1fa-6f9a-3ba0-8008-c9c5f682ebb5" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5c90d34d-0ac4-3f62-9a70-45501cd564cd" locEndPos="5" locType="sr" hash="1923244810" locEndLn="7" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="7" locFile="/BugDetective/divisionByZero.c" locStartln="7" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_17_7-a" lnHash="-194506379" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-194506379" unbViolId="78c66b7d-770e-37c6-9991-5b671844c945" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8c8eea90-2c3d-3bfb-aa0b-854e7c4d2906" locEndPos="5" locType="sr" hash="1923244810" locEndLn="7" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="8" locFile="/BugDetective/divisionByZero.c" locStartln="8" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_6-a" lnHash="-1754501628" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1754501628" unbViolId="5b3cfe1b-68a7-3c1a-a239-114e4ec64034" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="96e06de9-aa45-396b-8e4e-e7bc9d28a467" locEndPos="5" locType="sr" hash="1923244810" locEndLn="8" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="8" locFile="/BugDetective/divisionByZero.c" locStartln="8" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_17_7-a" lnHash="-1754501628" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1754501628" unbViolId="768cdd7d-a8fd-36be-a000-2acf38024f77" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4fa3ec5b-0bd4-3cc3-84cb-0d213859e432" locEndPos="5" locType="sr" hash="1923244810" locEndLn="8" goals="0," />
    <FlowViol msg="Division by &quot;person->daysWorkedInPassedMonth&quot; which may possibly be zero" ln="9" locFile="/BugDetective/divisionByZero.c" ruleSAFMsg="Point of division by zero" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="19" rule="MISRAC2012-DIR_4_1-c" FirstElSrcRngStartPos="0" lnHash="-969021421" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/divisionByZero.c" rule.header="Avoid division by zero" FirstElSrcRngStartln="18" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1716935372" lang="cpp" violId="ea5c6b0f-7142-3a9a-81e8-00d6a55affd9" locEndPos="0" locEndLn="10" goals="0," locStartln="9" sev="2" locRef="4" tool="c++test" lineHash="-969021421" unbViolId="ba5632a2-33ac-3f45-aa2c-28192c31a1c7" locType="sr" hash="1923244810" causeLocRef="4">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1706567659" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/divisionByZero.c" desc="p->daysWorkedInPassedMonth = 0;" ElType=".C" rngLn="18">
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="417141098" ln="19" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="19" srcRngEndLn="20" srcRngFile="/BugDetective/divisionByZero.c" desc="displayPersonalInfo(p);" ElType="!" rngLn="19">
          <ElDescList>
            <ElDesc lineHash="-194506379" ln="7" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="7" srcRngEndLn="8" srcRngFile="/BugDetective/divisionByZero.c" desc="printf(&quot;Name: %s\n&quot;, person->name);" ElType="." rngLn="7" />
            <ElDesc lineHash="-1754501628" ln="8" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="8" srcRngEndLn="9" srcRngFile="/BugDetective/divisionByZero.c" desc="printf(&quot;Salary: %d\n&quot;, person->salary);" ElType="." rngLn="8" />
            <ElDesc lineHash="-969021421" ln="9" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="9" srcRngEndLn="10" srcRngFile="/BugDetective/divisionByZero.c" desc="printf(&quot;Day's pay: %d\n&quot;, person->salary/person->daysWorkedInPassedMonth);" ElType=".P" rngLn="9">
              <Anns>
                <Ann msg="Point of division by zero" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Division by &quot;person->daysWorkedInPassedMonth&quot; which may possibly be zero" ln="9" locFile="/BugDetective/divisionByZero.c" ruleSAFMsg="Point of division by zero" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="19" rule="MISRAC2012-RULE_1_3-a" FirstElSrcRngStartPos="0" lnHash="-969021421" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/divisionByZero.c" rule.header="Avoid division by zero" FirstElSrcRngStartln="18" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1904128718" lang="cpp" violId="eb50bcd9-eb7f-398e-9218-e3dcaec9723e" locEndPos="0" locEndLn="10" goals="0," locStartln="9" sev="2" locRef="4" tool="c++test" lineHash="-969021421" unbViolId="d730846d-c03e-3207-8007-7015324f2e92" locType="sr" hash="1923244810" causeLocRef="4">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1706567659" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/divisionByZero.c" desc="p->daysWorkedInPassedMonth = 0;" ElType=".C" rngLn="18">
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="417141098" ln="19" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="19" srcRngEndLn="20" srcRngFile="/BugDetective/divisionByZero.c" desc="displayPersonalInfo(p);" ElType="!" rngLn="19">
          <ElDescList>
            <ElDesc lineHash="-194506379" ln="7" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="7" srcRngEndLn="8" srcRngFile="/BugDetective/divisionByZero.c" desc="printf(&quot;Name: %s\n&quot;, person->name);" ElType="." rngLn="7" />
            <ElDesc lineHash="-1754501628" ln="8" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="8" srcRngEndLn="9" srcRngFile="/BugDetective/divisionByZero.c" desc="printf(&quot;Salary: %d\n&quot;, person->salary);" ElType="." rngLn="8" />
            <ElDesc lineHash="-969021421" ln="9" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="9" srcRngEndLn="10" srcRngFile="/BugDetective/divisionByZero.c" desc="printf(&quot;Day's pay: %d\n&quot;, person->salary/person->daysWorkedInPassedMonth);" ElType=".P" rngLn="9">
              <Anns>
                <Ann msg="Point of division by zero" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'printf' function is not allowed" ln="9" locFile="/BugDetective/divisionByZero.c" locStartln="9" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_6-a" lnHash="-969021421" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-969021421" unbViolId="5ec39ea0-c14d-3eba-9da1-125bb93824e9" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f948c35c-5301-3e75-bf2c-c582cd913d33" locEndPos="5" locType="sr" hash="1923244810" locEndLn="9" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="9" locFile="/BugDetective/divisionByZero.c" locStartln="9" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_17_7-a" lnHash="-969021421" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-969021421" unbViolId="74e021e2-4b88-34e1-8420-0e3542985a68" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2a2940f9-f3c5-32f9-9dfa-fb06c0677e4b" locEndPos="5" locType="sr" hash="1923244810" locEndLn="9" goals="0," />
    <StdViol msg="Prototype of function 'createNewPerson' does not precede function definition" ln="12" locFile="/BugDetective/divisionByZero.c" locStartln="12" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_8_4-a" lnHash="1618739657" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1618739657" unbViolId="d89e3602-b76c-3ed0-a82d-bff0a1ebb791" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1e41f705-3c36-3755-98fc-98f0241062a6" locEndPos="9" locType="sr" hash="1923244810" locEndLn="12" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="12" locFile="/BugDetective/divisionByZero.c" locStartln="12" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="1618739657" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1618739657" unbViolId="f427f4f8-91c8-37ec-a8e4-9c70622797cd" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d8db7251-2b78-3506-a685-14d58f811fb5" locEndPos="37" locType="sr" hash="1923244810" locEndLn="12" goals="0," />
    <StdViol msg="Pointer to void type should not be converted to pointer to object type 'Person *'" ln="14" locFile="/BugDetective/divisionByZero.c" locStartln="14" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_11_5-a" lnHash="457932120" rule.header="A conversion should not be performed from pointer to void into pointer to object" tool="c++test" lineHash="457932120" unbViolId="5ad9d1c6-2288-3da5-b312-d9e3a5aebccd" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0d333f70-d66a-3451-bdcd-d9fc21e3e6a3" locEndPos="13" locType="sr" hash="1923244810" locEndLn="14" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="14" locFile="/BugDetective/divisionByZero.c" locStartln="14" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_3-a" lnHash="457932120" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="457932120" unbViolId="0a56022f-bd7d-3f36-a78d-587c4c75cdb3" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="01b276de-8728-3a73-a693-1017d798b919" locEndPos="17" locType="sr" hash="1923244810" locEndLn="14" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="14" locFile="/BugDetective/divisionByZero.c" locStartln="14" sev="2" auth="root" locRef="4" rule="MISRAC2012-DIR_4_12-a" lnHash="457932120" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="457932120" unbViolId="8e638b05-f9fb-353f-9407-f4b7279c0799" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6a0655f8-d7fe-36e7-965a-9153715df5d0" locEndPos="17" locType="sr" hash="1923244810" locEndLn="14" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'createNewPerson' should be followed by a block" ln="15" locFile="/BugDetective/divisionByZero.c" locStartln="15" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_15_6-b" lnHash="-413015691" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-413015691" unbViolId="e25c3d80-7889-3d4e-ac56-8246bb9e3c4f" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0e9bbd93-01a2-39e2-8ec2-fc9cd0e892c2" locEndPos="5" locType="sr" hash="1923244810" locEndLn="15" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="15" locFile="/BugDetective/divisionByZero.c" locStartln="15" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_11_9-a" lnHash="-413015691" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-413015691" unbViolId="212fb4e8-6ec4-391a-b0c6-7ba3307371ea" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ab5690f4-b97f-3d6e-a910-667515cf4f2f" locEndPos="14" locType="sr" hash="1923244810" locEndLn="15" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="15" locFile="/BugDetective/divisionByZero.c" locStartln="15" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_11_9-b" lnHash="-413015691" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-413015691" unbViolId="41366cc4-1954-346a-817a-54eb64d542c5" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="272976b5-1d35-378f-8228-e4e069cea103" locEndPos="14" locType="sr" hash="1923244810" locEndLn="15" goals="0," />
    <StdViol msg="Provide only one exit point in 'createNewPerson' function" ln="15" locFile="/BugDetective/divisionByZero.c" locStartln="15" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_15_5-a" lnHash="-413015691" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-413015691" unbViolId="fe235e7c-a539-3a3a-ac32-92fdee7c039b" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bfbea873-a13d-360e-9832-0476cb2b4443" locEndPos="17" locType="sr" hash="1923244810" locEndLn="15" goals="0," />
    <StdViol msg="The 'exit' library function should not be used" ln="15" locFile="/BugDetective/divisionByZero.c" locStartln="15" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_8-b" lnHash="-413015691" rule.header="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" tool="c++test" lineHash="-413015691" unbViolId="6d94cab2-4f9b-39b0-be3a-ee1fcd823c44" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a979ff54-88af-3a73-a54e-e641a8bd16ad" locEndPos="17" locType="sr" hash="1923244810" locEndLn="15" goals="0," />
    <StdViol msg="Provide only one exit point in 'createNewPerson' function" ln="20" locFile="/BugDetective/divisionByZero.c" locStartln="20" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_15_5-a" lnHash="-1256394053" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256394053" unbViolId="9067ff60-900b-3337-8ad8-c4c596675b5b" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9fbec706-5798-3f06-9b0c-6135cb412e89" locEndPos="5" locType="sr" hash="1923244810" locEndLn="20" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="23" locFile="/BugDetective/divisionByZero.c" locStartln="23" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="1420344907" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1420344907" unbViolId="7dbcc306-9e01-39d8-ae18-573f927ff5cb" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="283a59b9-67d1-380d-a367-2426665e6a8f" locEndPos="1" locType="sr" hash="1923244810" locEndLn="23" goals="0," />
    <StdViol msg="Prototype of function 'calculateAverageSalary' does not precede function definition" ln="23" locFile="/BugDetective/divisionByZero.c" locStartln="23" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_8_4-a" lnHash="1420344907" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1420344907" unbViolId="f290087d-1c4f-36f6-bac1-ba76a977bc02" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7150c6c8-a365-3aae-9075-4132d343e178" locEndPos="5" locType="sr" hash="1923244810" locEndLn="23" goals="0," />
    <StdViol msg="The function 'calculateAverageSalary' is referenced only in the translation unit where it is defined" ln="23" locFile="/BugDetective/divisionByZero.c" locStartln="23" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_8_7-a" lnHash="1420344907" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="1420344907" unbViolId="2615ae3a-d12e-3f60-a2c0-a91e9c42c348" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="f5e5529a-3b4d-381e-9d4e-c964d0fdd32b" locEndPos="5" locType="sr" hash="1923244810" locEndLn="23" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="23" locFile="/BugDetective/divisionByZero.c" locStartln="23" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="1420344907" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1420344907" unbViolId="5eb72738-045a-3deb-8b91-03f8c935fb00" locStartPos="27" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="73806111-46d1-3ccc-a3df-dfa0e546b93b" locEndPos="28" locType="sr" hash="1923244810" locEndLn="23" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="25" locFile="/BugDetective/divisionByZero.c" locStartln="25" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="-306300958" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-306300958" unbViolId="0d2d842c-a74b-312b-9366-818e42379ebf" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1af66653-c1b7-3aec-a6a2-a84c99cb895f" locEndPos="5" locType="sr" hash="1923244810" locEndLn="25" goals="0," />
    <FlowViol msg="Division by &quot;numberOfEmployees&quot; which may possibly be zero" ln="26" locFile="/BugDetective/divisionByZero.c" ruleSAFMsg="Point of division by zero" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="54" rule="MISRAC2012-DIR_4_1-c" FirstElSrcRngStartPos="0" lnHash="-1503128871" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/divisionByZero.c" rule.header="Avoid division by zero" FirstElSrcRngStartln="53" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-440383681" lang="cpp" violId="6d876f0d-64a7-342a-9fd0-cb57289e544d" locEndPos="0" locEndLn="27" goals="0," locStartln="26" sev="2" locRef="4" tool="c++test" lineHash="-1503128871" unbViolId="d2fbce2a-e34b-35c0-b83e-621637a3668d" locType="sr" hash="1923244810" causeLocRef="4">
      <Props />
      <ElDescList>
        <ElDesc lineHash="2068113868" ln="53" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="53" srcRngEndLn="54" srcRngFile="/BugDetective/divisionByZero.c" desc="numberOfEmployees = processFile(file, employees);" ElType=".C" rngLn="53">
          <ElDescList>
            <ElDesc lineHash="-1256396037" ln="41" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="41" srcRngEndLn="42" srcRngFile="/BugDetective/divisionByZero.c" desc="return 0;" ElType="!" rngLn="41">
              <Anns>
                <Ann msg="Returning value: 0" kind="valEval" />
              </Anns>
            </ElDesc>
          </ElDescList>
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
            <Ann msg="Variable assignment: numberOfEmployees = processFile(file,employees) -> numberOfEmployees = 0" kind="valEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-337476011" ln="54" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="54" srcRngEndLn="55" srcRngFile="/BugDetective/divisionByZero.c" desc="processStaff(employees, numberOfEmployees);" ElType="!" rngLn="54">
          <ElDescList>
            <ElDesc lineHash="727882071" ln="29" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="29" srcRngEndLn="30" srcRngFile="/BugDetective/divisionByZero.c" desc="void processStaff(Person* employees[], int sizeOfStaff)" ElType="!" rngLn="29">
              <Anns>
                <Ann msg="Parameter value: sizeOfStaff = numberOfEmployees -> sizeOfStaff = 0" kind="valEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1679375043" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/BugDetective/divisionByZero.c" desc="int i;" ElType="." rngLn="31" />
            <ElDesc lineHash="882805155" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/divisionByZero.c" desc="for (i = 0; i &lt; sizeOfStaff; ++i) {" ElType="." rngLn="32">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; sizeOfStaff) (false)" kind="condEval" />
                <Ann msg="Not entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="-1642911173" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/divisionByZero.c" desc="calculateAverageSalary(...)" ElType="!" rngLn="35">
              <ElDescList>
                <ElDesc lineHash="1420344907" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/BugDetective/divisionByZero.c" desc="int calculateAverageSalary(int numberOfEmployees)" ElType="!" rngLn="23">
                  <Anns>
                    <Ann msg="Parameter value: numberOfEmployees = sizeOfStaff -> numberOfEmployees = 0" kind="valEval" />
                  </Anns>
                </ElDesc>
                <ElDesc lineHash="-306300958" ln="25" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="25" srcRngEndLn="26" srcRngFile="/BugDetective/divisionByZero.c" desc="int WAGE_FUND = 10000;" ElType="." rngLn="25" />
                <ElDesc lineHash="-1503128871" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/divisionByZero.c" desc="return WAGE_FUND/numberOfEmployees;" ElType=".P" rngLn="26">
                  <Anns>
                    <Ann msg="Point of division by zero" kind="point" />
                  </Anns>
                </ElDesc>
              </ElDescList>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Division by &quot;numberOfEmployees&quot; which may possibly be zero" ln="26" locFile="/BugDetective/divisionByZero.c" ruleSAFMsg="Point of division by zero" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="54" rule="MISRAC2012-RULE_1_3-a" FirstElSrcRngStartPos="0" lnHash="-1503128871" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/divisionByZero.c" rule.header="Avoid division by zero" FirstElSrcRngStartln="53" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="219631809" lang="cpp" violId="045da53d-38f7-3968-9489-2cd5ceef3ceb" locEndPos="0" locEndLn="27" goals="0," locStartln="26" sev="2" locRef="4" tool="c++test" lineHash="-1503128871" unbViolId="fd68696e-a932-390a-ab88-3895dceec1e5" locType="sr" hash="1923244810" causeLocRef="4">
      <Props />
      <ElDescList>
        <ElDesc lineHash="2068113868" ln="53" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="53" srcRngEndLn="54" srcRngFile="/BugDetective/divisionByZero.c" desc="numberOfEmployees = processFile(file, employees);" ElType=".C" rngLn="53">
          <ElDescList>
            <ElDesc lineHash="-1256396037" ln="41" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="41" srcRngEndLn="42" srcRngFile="/BugDetective/divisionByZero.c" desc="return 0;" ElType="!" rngLn="41">
              <Anns>
                <Ann msg="Returning value: 0" kind="valEval" />
              </Anns>
            </ElDesc>
          </ElDescList>
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
            <Ann msg="Variable assignment: numberOfEmployees = processFile(file,employees) -> numberOfEmployees = 0" kind="valEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-337476011" ln="54" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="54" srcRngEndLn="55" srcRngFile="/BugDetective/divisionByZero.c" desc="processStaff(employees, numberOfEmployees);" ElType="!" rngLn="54">
          <ElDescList>
            <ElDesc lineHash="727882071" ln="29" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="29" srcRngEndLn="30" srcRngFile="/BugDetective/divisionByZero.c" desc="void processStaff(Person* employees[], int sizeOfStaff)" ElType="!" rngLn="29">
              <Anns>
                <Ann msg="Parameter value: sizeOfStaff = numberOfEmployees -> sizeOfStaff = 0" kind="valEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1679375043" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/BugDetective/divisionByZero.c" desc="int i;" ElType="." rngLn="31" />
            <ElDesc lineHash="882805155" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/divisionByZero.c" desc="for (i = 0; i &lt; sizeOfStaff; ++i) {" ElType="." rngLn="32">
              <Anns>
                <Ann msg="Loop condition evaluation: (i &lt; sizeOfStaff) (false)" kind="condEval" />
                <Ann msg="Not entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="-1642911173" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/divisionByZero.c" desc="calculateAverageSalary(...)" ElType="!" rngLn="35">
              <ElDescList>
                <ElDesc lineHash="1420344907" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/BugDetective/divisionByZero.c" desc="int calculateAverageSalary(int numberOfEmployees)" ElType="!" rngLn="23">
                  <Anns>
                    <Ann msg="Parameter value: numberOfEmployees = sizeOfStaff -> numberOfEmployees = 0" kind="valEval" />
                  </Anns>
                </ElDesc>
                <ElDesc lineHash="-306300958" ln="25" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="25" srcRngEndLn="26" srcRngFile="/BugDetective/divisionByZero.c" desc="int WAGE_FUND = 10000;" ElType="." rngLn="25" />
                <ElDesc lineHash="-1503128871" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="1923244810" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/divisionByZero.c" desc="return WAGE_FUND/numberOfEmployees;" ElType=".P" rngLn="26">
                  <Anns>
                    <Ann msg="Point of division by zero" kind="point" />
                  </Anns>
                </ElDesc>
              </ElDescList>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Prototype of function 'processStaff' does not precede function definition" ln="29" locFile="/BugDetective/divisionByZero.c" locStartln="29" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_8_4-a" lnHash="727882071" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="727882071" unbViolId="3b3446b9-68d6-3cae-af08-07d91c973f4e" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b7b768bc-8528-3fd5-aaac-402cc8c23b5b" locEndPos="6" locType="sr" hash="1923244810" locEndLn="29" goals="0," />
    <StdViol msg="The function 'processStaff' is referenced only in the translation unit where it is defined" ln="29" locFile="/BugDetective/divisionByZero.c" locStartln="29" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_8_7-a" lnHash="727882071" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="727882071" unbViolId="18ace918-9a3b-349d-ae26-29ea979675eb" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="75427fd1-a48c-3906-875a-cb1372aff050" locEndPos="6" locType="sr" hash="1923244810" locEndLn="29" goals="0," />
    <StdViol msg="Pass parameter &quot;employees&quot; with const specifier" ln="29" locFile="/BugDetective/divisionByZero.c" locStartln="29" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_8_13-a" lnHash="727882071" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="727882071" unbViolId="c8455b66-bad9-3400-b5da-c3e01073fd72" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f687868f-9669-3c28-8bc7-1ef55ea652af" locEndPos="27" locType="sr" hash="1923244810" locEndLn="29" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="29" locFile="/BugDetective/divisionByZero.c" locStartln="29" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="727882071" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="727882071" unbViolId="5d8a8df3-988a-3f2a-95a8-aa2140bc5e09" locStartPos="39" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a8103a6c-8877-3814-b874-6a65090835da" locEndPos="40" locType="sr" hash="1923244810" locEndLn="29" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="31" locFile="/BugDetective/divisionByZero.c" locStartln="31" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="1679375043" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1679375043" unbViolId="60293f3b-f7d7-3c3a-9e32-18d979b32480" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7c04956b-129b-3545-a3c5-603e5d0bd77e" locEndPos="5" locType="sr" hash="1923244810" locEndLn="31" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="35" locFile="/BugDetective/divisionByZero.c" locStartln="35" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_6-a" lnHash="-1642911173" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1642911173" unbViolId="2b79137e-0783-3750-9b8c-febebc017d45" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9c0107f5-3098-3b46-a1b5-fee2a644a020" locEndPos="5" locType="sr" hash="1923244810" locEndLn="35" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="35" locFile="/BugDetective/divisionByZero.c" locStartln="35" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_17_7-a" lnHash="-1642911173" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1642911173" unbViolId="71ee8d7c-33d2-321a-8ee8-76d23f70df09" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b0fe55f1-92fa-3b6d-b329-ccc369893bad" locEndPos="5" locType="sr" hash="1923244810" locEndLn="35" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="38" locFile="/BugDetective/divisionByZero.c" locStartln="38" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="-1106684675" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1106684675" unbViolId="0b2ec93a-86f0-39aa-9611-04bb7763653b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4fb6e749-5401-370b-b684-645d1bfdc2c8" locEndPos="1" locType="sr" hash="1923244810" locEndLn="38" goals="0," />
    <StdViol msg="Prototype of function 'processFile' does not precede function definition" ln="38" locFile="/BugDetective/divisionByZero.c" locStartln="38" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_8_4-a" lnHash="-1106684675" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1106684675" unbViolId="36ba271c-1b1c-32fb-816b-c527bede0f7f" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="15828000-4469-3631-b47f-9c5dade1ff46" locEndPos="5" locType="sr" hash="1923244810" locEndLn="38" goals="0," />
    <StdViol msg="The function 'processFile' is referenced only in the translation unit where it is defined" ln="38" locFile="/BugDetective/divisionByZero.c" locStartln="38" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_8_7-a" lnHash="-1106684675" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-1106684675" unbViolId="6c1d9b44-ec1c-3263-ad25-77bfa126d2db" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="ecf44ffa-8616-3762-ad28-dd4fe51bae91" locEndPos="5" locType="sr" hash="1923244810" locEndLn="38" goals="0," />
    <StdViol msg="Pass parameter &quot;file&quot; with const specifier" ln="38" locFile="/BugDetective/divisionByZero.c" locStartln="38" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_8_13-a" lnHash="-1106684675" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="-1106684675" unbViolId="1425f092-7aab-3c6d-9a2f-cccf21db8fd3" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="59417ff5-65dc-3e70-87d8-9a8bd4b2cf5e" locEndPos="23" locType="sr" hash="1923244810" locEndLn="38" goals="0," />
    <StdViol msg="Parameter 'file' is not used in function 'processFile'" ln="38" locFile="/BugDetective/divisionByZero.c" locStartln="38" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_2_7-a" lnHash="-1106684675" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="-1106684675" unbViolId="9e5d875d-3021-3ba3-b190-bcad1ef5351b" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c78991d8-626f-3497-acf6-59392962c4b0" locEndPos="23" locType="sr" hash="1923244810" locEndLn="38" goals="0," />
    <StdViol msg="Pass parameter &quot;employees&quot; with const specifier" ln="38" locFile="/BugDetective/divisionByZero.c" locStartln="38" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_8_13-a" lnHash="-1106684675" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="-1106684675" unbViolId="be70387a-0fcc-3bea-9d57-c798a5cd6407" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c4646fda-3c22-3897-abbf-0ac978342b86" locEndPos="37" locType="sr" hash="1923244810" locEndLn="38" goals="0," />
    <StdViol msg="Parameter 'employees' is not used in function 'processFile'" ln="38" locFile="/BugDetective/divisionByZero.c" locStartln="38" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_2_7-a" lnHash="-1106684675" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="-1106684675" unbViolId="275fdc9e-8d82-3577-b3b5-ee813efb6a86" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a8a831d2-ecd5-352b-b426-3c242d33c59c" locEndPos="37" locType="sr" hash="1923244810" locEndLn="38" goals="0," />
    <StdViol msg="Function 'main' is not in prototype form" ln="44" locFile="/BugDetective/divisionByZero.c" locStartln="44" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_1_5-c" lnHash="1440699851" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1440699851" unbViolId="f43f05e1-f650-31ea-8543-f74414d2a941" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="71d0ccfe-2f5c-31af-ae46-e8aa9c48e2f5" locEndPos="5" locType="sr" hash="1923244810" locEndLn="44" goals="0," />
    <StdViol msg="Function 'main' is not in prototype form" ln="44" locFile="/BugDetective/divisionByZero.c" locStartln="44" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_8_2-c" lnHash="1440699851" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1440699851" unbViolId="c1f76f7c-4bf2-31c6-9e65-90dd36968205" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a5967352-c26d-331a-9441-3128a3e81234" locEndPos="5" locType="sr" hash="1923244810" locEndLn="44" goals="0," />
    <StdViol msg="Usage of 'fopen' function is not allowed" ln="46" locFile="/BugDetective/divisionByZero.c" locStartln="46" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_6-a" lnHash="-496689081" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-496689081" unbViolId="345253ac-d68e-3532-a1bb-6e28102d7f50" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bb303f2a-294e-3f65-8959-c64987299a43" locEndPos="18" locType="sr" hash="1923244810" locEndLn="46" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="48" locFile="/BugDetective/divisionByZero.c" locStartln="48" sev="4" auth="root" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="349814855" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="349814855" unbViolId="5e97eb6b-837a-382b-96a2-386e64506e37" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e2a11d74-a8a3-3c3a-9443-1833ca5f7740" locEndPos="5" locType="sr" hash="1923244810" locEndLn="48" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="50" locFile="/BugDetective/divisionByZero.c" locStartln="50" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_6-a" lnHash="1046019028" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="1046019028" unbViolId="f7a1aea7-b1f6-3fab-a49c-a116259aa8a0" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c024a7aa-c01b-3844-959f-a1b2ceb38c72" locEndPos="9" locType="sr" hash="1923244810" locEndLn="50" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="50" locFile="/BugDetective/divisionByZero.c" locStartln="50" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_17_7-a" lnHash="1046019028" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="1046019028" unbViolId="6ad53c2b-0e21-3a6f-9a53-305c13633307" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8fd66aa5-3754-3a24-b7c0-0e877ec71429" locEndPos="9" locType="sr" hash="1923244810" locEndLn="50" goals="0," />
    <StdViol msg="Provide only one exit point in 'main' function" ln="51" locFile="/BugDetective/divisionByZero.c" locStartln="51" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_15_5-a" lnHash="1941627674" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="1941627674" unbViolId="a789eb2b-e465-3b88-901f-476dfb918a94" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dfe125a7-0f71-322c-91fc-a37027f4c20c" locEndPos="9" locType="sr" hash="1923244810" locEndLn="51" goals="0," />
    <StdViol msg="Usage of 'fclose' function is not allowed" ln="55" locFile="/BugDetective/divisionByZero.c" locStartln="55" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_21_6-a" lnHash="191846468" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="191846468" unbViolId="6656b703-a3da-399f-bd60-f973dd820b88" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="283a4821-9fee-342e-a37b-57a9fed21152" locEndPos="5" locType="sr" hash="1923244810" locEndLn="55" goals="0," />
    <StdViol msg="Unused function's &quot;fclose&quot; return value" ln="55" locFile="/BugDetective/divisionByZero.c" locStartln="55" sev="2" auth="root" locRef="4" rule="MISRAC2012-RULE_17_7-a" lnHash="191846468" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="191846468" unbViolId="3a1e666c-4f10-3fd7-8f1d-fe87e5e5276b" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="036ef5fe-9892-30c6-94d1-dd90fa02e804" locEndPos="5" locType="sr" hash="1923244810" locEndLn="55" goals="0," />
    <StdViol msg="Provide only one exit point in 'main' function" ln="56" locFile="/BugDetective/divisionByZero.c" locStartln="56" sev="4" auth="root" locRef="4" rule="MISRAC2012-RULE_15_5-a" lnHash="-1256396037" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256396037" unbViolId="2c9b7e4e-5154-3893-9384-1cc645a340ba" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5e8208a0-4a8a-3a37-8219-0fd79abd8c52" locEndPos="5" locType="sr" hash="1923244810" locEndLn="56" goals="0," />
    <StdViol msg="Prototype of function 'printFile' does not precede function definition" ln="9" locFile="/BugDetective/fileLeaks.c" locStartln="9" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_8_4-a" lnHash="-923753648" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-923753648" unbViolId="66f14d3d-f456-359b-bc35-9f6e4a2e0fb0" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="194412cd-dc92-3f71-949b-abb5292fe2e6" locEndPos="6" locType="sr" hash="1210532432" locEndLn="9" goals="0," />
    <StdViol msg="The function 'printFile' is referenced only in the translation unit where it is defined" ln="9" locFile="/BugDetective/fileLeaks.c" locStartln="9" sev="4" auth="root" locRef="5" rule="MISRAC2012-RULE_8_7-a" lnHash="-923753648" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-923753648" unbViolId="86226446-89ab-32d8-90d1-0f147d78d631" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="a06c76f9-a521-36dd-88eb-5c3ebc1b36b6" locEndPos="6" locType="sr" hash="1210532432" locEndLn="9" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="12" locFile="/BugDetective/fileLeaks.c" locStartln="12" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="1807758733" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="1807758733" unbViolId="1dfec518-fd84-3c0d-b7b8-5f6200755acd" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d9ce05de-94e5-37c9-aea4-6be7fe0af467" locEndPos="5" locType="sr" hash="1210532432" locEndLn="12" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="12" locFile="/BugDetective/fileLeaks.c" locStartln="12" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_17_7-a" lnHash="1807758733" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="1807758733" unbViolId="94fde259-1948-390e-9e63-cfba9f26178a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b1b921c9-c794-36b4-8c3f-227dc7d9ffe6" locEndPos="5" locType="sr" hash="1210532432" locEndLn="12" goals="0," />
    <StdViol msg="The expression of the 'essentially signed' type is assigned to an object with the 'essentially character' type" ln="14" locFile="/BugDetective/fileLeaks.c" locStartln="14" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_10_3-b" lnHash="1093133731" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="1093133731" unbViolId="b1e64fe7-3d16-3c96-9eaa-b3ac321782be" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e6ff5b7f-2357-345e-97b3-c845e3992bab" locEndPos="9" locType="sr" hash="1210532432" locEndLn="14" goals="0," />
    <StdViol msg="Usage of 'fgetc' function is not allowed" ln="14" locFile="/BugDetective/fileLeaks.c" locStartln="14" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="1093133731" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="1093133731" unbViolId="f937417a-b438-3b5b-ab4d-d11622f95ca8" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="585ff7c1-40bb-3bdf-921f-ec136cd642d3" locEndPos="13" locType="sr" hash="1210532432" locEndLn="14" goals="0," />
    <FlowViol msg="The EOF macro is compared with the modified value returned by the &quot;fgetc&quot; function" ln="15" locFile="/BugDetective/fileLeaks.c" ruleSAFMsg="Comparing value with EOF" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="15" rule="MISRAC2012-RULE_22_7-a" FirstElSrcRngStartPos="0" lnHash="161967170" ruleSCSCMsg="Invoke function capable of returning EOF" FirstElSrcRngFile="/BugDetective/fileLeaks.c" rule.header="The macro EOF should be compared with the unmodified return value from the Standard Library function" FirstElSrcRngStartln="14" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="910895208" lang="cpp" violId="c8a8bc65-9e05-3830-96ee-8a6a72429189" locEndPos="0" locEndLn="16" goals="0," locStartln="15" sev="2" locRef="5" tool="c++test" lineHash="161967170" unbViolId="2113638e-429e-32b0-b74c-c2b8f488e54f" locType="sr" hash="1210532432" causeLocRef="5">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1093133731" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/fileLeaks.c" desc="fgetc(...)" ElType=".C" rngLn="14">
          <Anns>
            <Ann msg="Invoke function capable of returning EOF" kind="cause" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1093133731" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/fileLeaks.c" desc="c = fgetc(file);" ElType="!" rngLn="14">
          <Anns>
            <Ann msg="Casting int -> char" kind="comment" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="161967170" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/fileLeaks.c" desc="if (c!=EOF) {" ElType=".P" rngLn="15">
          <Anns>
            <Ann msg="Casting char -> int" kind="comment" />
            <Ann msg="Comparing value with EOF" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Operands of the '!=' operator have different essential types: 'char' and 'signed char'" ln="15" locFile="/BugDetective/fileLeaks.c" locStartln="15" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_10_4-a" lnHash="161967170" rule.header="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" tool="c++test" lineHash="161967170" unbViolId="349c1937-6576-374d-b535-9eaf3b61f073" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="58f0ddfe-020f-31cf-bbd4-9a71c178e612" locEndPos="13" locType="sr" hash="1210532432" locEndLn="15" goals="0," />
    <FlowViol msg="Data obtained from a file (&quot;c&quot;) is printed on a console" ln="16" locFile="/BugDetective/fileLeaks.c" ruleSAFMsg="Call to a dangerous method" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="15" rule="MISRAC2012-DIR_4_14-k" FirstElSrcRngStartPos="0" lnHash="-1245723280" ruleSCSCMsg="Tainting point" FirstElSrcRngFile="/BugDetective/fileLeaks.c" rule.header="Avoid printing tainted data on the output console" FirstElSrcRngStartln="14" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="729845392" lang="cpp" violId="8e181b91-073e-3365-9c39-f8a71a94f69e" locEndPos="0" locEndLn="17" goals="0," locStartln="16" sev="2" locRef="5" tool="c++test" lineHash="-1245723280" unbViolId="88ec4147-f344-35bb-9c71-f18fb25735e5" locType="sr" hash="1210532432" causeLocRef="5">
      <Props>
        <Prop key="Tracked variables" val="Tainted data" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-695983806" ln="11" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="11" srcRngEndLn="12" srcRngFile="/BugDetective/fileLeaks.c" desc="char c;" ElType="." rngLn="11" />
        <ElDesc lineHash="1807758733" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/fileLeaks.c" desc="printf(&quot;Reading file contents:\n\n&quot;);" ElType="." rngLn="12" />
        <ElDesc lineHash="66462730" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/fileLeaks.c" desc="while(1) {" ElType="." rngLn="13">
          <Anns>
            <Ann msg="Loop condition evaluation: 1 (true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1093133731" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/fileLeaks.c" desc="fgetc(...)" ElType=".C" rngLn="14">
          <Props>
            <Prop key="Tracked variables" val="fgetc(...)" />
          </Props>
          <Anns>
            <Ann msg="Tainting point" kind="cause" />
            <Ann msg="Tainted data: fgetc(...)" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1093133731" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/fileLeaks.c" desc="c = fgetc(file);" ElType="!" rngLn="14" />
        <ElDesc lineHash="161967170" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/fileLeaks.c" desc="if (c!=EOF) {" ElType="." rngLn="15">
          <Props>
            <Prop key="Tracked variables" val="c" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: c" kind="var" />
            <Ann msg="Condition evaluation: (c != -1) (assuming true)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1245723280" ln="16" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="16" srcRngEndLn="17" srcRngFile="/BugDetective/fileLeaks.c" desc="printf(&quot;%c&quot;, c);" ElType=".P" rngLn="16">
          <Props>
            <Prop key="Tracked variables" val="c" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: c" kind="var" />
            <Ann msg="Call to a dangerous method" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'printf' function is not allowed" ln="16" locFile="/BugDetective/fileLeaks.c" locStartln="16" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="-1245723280" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1245723280" unbViolId="a63fe805-e7bb-3fc1-aa28-e9a61bb6e9e8" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="baebe761-4ab5-34b9-97af-7caebd617551" locEndPos="13" locType="sr" hash="1210532432" locEndLn="16" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="16" locFile="/BugDetective/fileLeaks.c" locStartln="16" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_17_7-a" lnHash="-1245723280" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1245723280" unbViolId="af673983-187b-3705-9971-5cc71bb5c752" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="57e7fe29-8334-3afe-bd7d-318991c49575" locEndPos="13" locType="sr" hash="1210532432" locEndLn="16" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="23" locFile="/BugDetective/fileLeaks.c" locStartln="23" sev="4" auth="root" locRef="5" rule="MISRAC2012-DIR_4_6-b" lnHash="460532493" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="460532493" unbViolId="9efc9f9b-2a25-3229-a654-074ae21dbd30" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="16489cca-69fb-3cee-b70f-588886b2b30f" locEndPos="1" locType="sr" hash="1210532432" locEndLn="23" goals="0," />
    <StdViol msg="Prototype of function 'displayFileContent' does not precede function definition" ln="23" locFile="/BugDetective/fileLeaks.c" locStartln="23" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_8_4-a" lnHash="460532493" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="460532493" unbViolId="5250282d-72ab-348e-b65c-bbb1d5296b49" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c6980e15-763a-3bd9-b4d0-b19df09e0e1c" locEndPos="5" locType="sr" hash="1210532432" locEndLn="23" goals="0," />
    <StdViol msg="Function 'displayFileContent' is not in prototype form" ln="23" locFile="/BugDetective/fileLeaks.c" locStartln="23" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_1_5-c" lnHash="460532493" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="460532493" unbViolId="4fa58fde-5495-30ea-83b3-7bdd60bf66e6" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b5bba8de-357e-333e-87e7-e805ef56fb08" locEndPos="5" locType="sr" hash="1210532432" locEndLn="23" goals="0," />
    <StdViol msg="Function 'displayFileContent' is not in prototype form" ln="23" locFile="/BugDetective/fileLeaks.c" locStartln="23" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_8_2-c" lnHash="460532493" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="460532493" unbViolId="08ff2de8-cb64-3652-91e8-f998453ed724" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b5a6be14-fcc0-3fb9-a4a6-eb86bcfb7b8f" locEndPos="5" locType="sr" hash="1210532432" locEndLn="23" goals="0," />
    <StdViol msg="Usage of 'fopen' function is not allowed" ln="26" locFile="/BugDetective/fileLeaks.c" locStartln="26" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="663570683" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="663570683" unbViolId="9d7c7116-5702-3a92-a3a2-d4dca4a0a94a" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0ec817bb-976c-3118-a3a5-aa0477df3a64" locEndPos="12" locType="sr" hash="1210532432" locEndLn="26" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="28" locFile="/BugDetective/fileLeaks.c" locStartln="28" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="1046019028" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="1046019028" unbViolId="d7da30b0-bc56-3a1e-9eab-48ae8e825fea" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ac2cea23-fef4-3ccb-8613-bd05b58c3cf5" locEndPos="9" locType="sr" hash="1210532432" locEndLn="28" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="28" locFile="/BugDetective/fileLeaks.c" locStartln="28" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_17_7-a" lnHash="1046019028" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="1046019028" unbViolId="8cc81b0f-9f95-3d7c-bf7e-173426db4140" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="83a83291-968e-318c-89d4-eb1a60f0749c" locEndPos="9" locType="sr" hash="1210532432" locEndLn="28" goals="0," />
    <StdViol msg="Provide only one exit point in 'displayFileContent' function" ln="29" locFile="/BugDetective/fileLeaks.c" locStartln="29" sev="4" auth="root" locRef="5" rule="MISRAC2012-RULE_15_5-a" lnHash="1941627674" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="1941627674" unbViolId="6e6f9717-d0f4-36db-9eac-21a924b8e4db" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d1590c15-46f5-3e38-94ca-0a53fb8de973" locEndPos="9" locType="sr" hash="1210532432" locEndLn="29" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="31" locFile="/BugDetective/fileLeaks.c" locStartln="31" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="-1833015213" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1833015213" unbViolId="a32cf850-00d3-35f9-87c2-2cc3c549ff58" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8ddc06c8-d69a-33e5-b0b5-463caec19284" locEndPos="5" locType="sr" hash="1210532432" locEndLn="31" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="31" locFile="/BugDetective/fileLeaks.c" locStartln="31" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_17_7-a" lnHash="-1833015213" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1833015213" unbViolId="666cd381-6221-339a-bfbd-8964772fccb0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="338109b5-a048-37fe-964c-5dc377308620" locEndPos="5" locType="sr" hash="1210532432" locEndLn="31" goals="0," />
    <StdViol msg="Section of code should not be 'commented out'" ln="33" locFile="/BugDetective/fileLeaks.c" locStartln="33" sev="4" auth="root" locRef="5" rule="MISRAC2012-DIR_4_4-a" lnHash="-1879695220" rule.header="Sections of code should not be &quot;commented out&quot;" tool="c++test" lineHash="-1879695220" unbViolId="5e7c61fa-f064-37ac-9d1f-aeff3b73f8fc" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="56388dbf-5725-35be-a28e-bc4d509fd527" locEndPos="5" locType="sr" hash="1210532432" locEndLn="33" goals="0," />
    <StdViol msg="Provide only one exit point in 'displayFileContent' function" ln="35" locFile="/BugDetective/fileLeaks.c" locStartln="35" sev="4" auth="root" locRef="5" rule="MISRAC2012-RULE_15_5-a" lnHash="-1256396037" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256396037" unbViolId="5ed731d2-3c77-301c-a048-a009f1f3ee9f" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="23dc817b-42df-3fd0-a49d-67a2379a285d" locEndPos="5" locType="sr" hash="1210532432" locEndLn="35" goals="0," />
    <FlowViol msg="File not closed: file" ln="36" locFile="/BugDetective/fileLeaks.c" ruleSAFMsg="Point where opened file is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="27" rule="MISRAC2012-RULE_22_1-a" FirstElSrcRngStartPos="0" lnHash="125" ruleSCSCMsg="Point where file is opened" FirstElSrcRngFile="/BugDetective/fileLeaks.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="26" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1573681103" lang="cpp" violId="5ee20a8a-1348-3433-8c29-3230148692c0" locEndPos="0" locEndLn="37" goals="0," locStartln="36" sev="2" locRef="5" tool="c++test" lineHash="125" unbViolId="7acc7129-4909-31b8-af27-c75f9eff3992" locType="sr" hash="1210532432" causeLocRef="5">
      <Props>
        <Prop key="Tracked variables" val="Opened file" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-1954950279" ln="25" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="25" srcRngEndLn="26" srcRngFile="/BugDetective/fileLeaks.c" desc="FILE *file;" ElType="." rngLn="25" />
        <ElDesc lineHash="663570683" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/fileLeaks.c" desc="file = fopen(&quot;myfile.txt&quot;, &quot;r&quot;);" ElType=".C" rngLn="26">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Point where file is opened" kind="cause" />
            <Ann msg="Opened file: file" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1958866940" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/fileLeaks.c" desc="if (file==NULL) {" ElType="." rngLn="27">
          <Anns>
            <Ann msg="Condition evaluation: (file == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1833015213" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/BugDetective/fileLeaks.c" desc="printf(&quot;File successfully opened.\n\n&quot;);" ElType="." rngLn="31" />
        <ElDesc lineHash="178811885" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/fileLeaks.c" desc="printFile(file);" ElType="." rngLn="32">
          <ElDescList>
            <ElDesc lineHash="-695983806" ln="11" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="11" srcRngEndLn="12" srcRngFile="/BugDetective/fileLeaks.c" desc="char c;" ElType="." rngLn="11">
              <Props>
                <Prop key="Tracked variables" val="file" />
              </Props>
              <Anns>
                <Ann msg="Opened file: file" kind="var" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1807758733" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/fileLeaks.c" desc="printf(&quot;Reading file contents:\n\n&quot;);" ElType="." rngLn="12" />
            <ElDesc lineHash="66462730" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/fileLeaks.c" desc="while(1) {" ElType="." rngLn="13">
              <Anns>
                <Ann msg="Loop condition evaluation: 1 (true)" kind="condEval" />
                <Ann msg="Entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1093133731" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/fileLeaks.c" desc="c = fgetc(file);" ElType="." rngLn="14" />
            <ElDesc lineHash="161967170" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/fileLeaks.c" desc="if (c!=EOF) {" ElType="." rngLn="15">
              <Anns>
                <Ann msg="Condition evaluation: (c != -1) (assuming false)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="207609628" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/fileLeaks.c" desc="break;" ElType="." rngLn="18">
              <Anns>
                <Ann msg="Exit the loop" kind="condEval" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
        <ElDesc lineHash="-1256396037" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/fileLeaks.c" desc="return 0;" ElType="." rngLn="35" />
        <ElDesc lineHash="125" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/fileLeaks.c" desc="}" ElType=".P" rngLn="36">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Opened file: file" kind="var" />
            <Ann msg="Point where opened file is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="File not closed: file" ln="36" locFile="/BugDetective/fileLeaks.c" ruleSAFMsg="Point where opened file is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="27" rule="MISRAC2012-DIR_4_13-a" FirstElSrcRngStartPos="0" lnHash="125" ruleSCSCMsg="Point where file is opened" FirstElSrcRngFile="/BugDetective/fileLeaks.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="26" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1573681103" lang="cpp" violId="7e1c8d5c-bc6d-3faf-974f-8b8d61326bdf" locEndPos="0" locEndLn="37" goals="0," locStartln="36" sev="4" locRef="5" tool="c++test" lineHash="125" unbViolId="81a865c7-cfc9-3321-a984-9fad0be7fc54" locType="sr" hash="1210532432" causeLocRef="5">
      <Props>
        <Prop key="Tracked variables" val="Opened file" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-1954950279" ln="25" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="25" srcRngEndLn="26" srcRngFile="/BugDetective/fileLeaks.c" desc="FILE *file;" ElType="." rngLn="25" />
        <ElDesc lineHash="663570683" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/fileLeaks.c" desc="file = fopen(&quot;myfile.txt&quot;, &quot;r&quot;);" ElType=".C" rngLn="26">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Point where file is opened" kind="cause" />
            <Ann msg="Opened file: file" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1958866940" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/fileLeaks.c" desc="if (file==NULL) {" ElType="." rngLn="27">
          <Anns>
            <Ann msg="Condition evaluation: (file == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1833015213" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/BugDetective/fileLeaks.c" desc="printf(&quot;File successfully opened.\n\n&quot;);" ElType="." rngLn="31" />
        <ElDesc lineHash="178811885" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/fileLeaks.c" desc="printFile(file);" ElType="." rngLn="32">
          <ElDescList>
            <ElDesc lineHash="-695983806" ln="11" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="11" srcRngEndLn="12" srcRngFile="/BugDetective/fileLeaks.c" desc="char c;" ElType="." rngLn="11">
              <Props>
                <Prop key="Tracked variables" val="file" />
              </Props>
              <Anns>
                <Ann msg="Opened file: file" kind="var" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1807758733" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/fileLeaks.c" desc="printf(&quot;Reading file contents:\n\n&quot;);" ElType="." rngLn="12" />
            <ElDesc lineHash="66462730" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/fileLeaks.c" desc="while(1) {" ElType="." rngLn="13">
              <Anns>
                <Ann msg="Loop condition evaluation: 1 (true)" kind="condEval" />
                <Ann msg="Entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1093133731" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/fileLeaks.c" desc="c = fgetc(file);" ElType="." rngLn="14" />
            <ElDesc lineHash="161967170" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/fileLeaks.c" desc="if (c!=EOF) {" ElType="." rngLn="15">
              <Anns>
                <Ann msg="Condition evaluation: (c != -1) (assuming false)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="207609628" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/fileLeaks.c" desc="break;" ElType="." rngLn="18">
              <Anns>
                <Ann msg="Exit the loop" kind="condEval" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
        <ElDesc lineHash="-1256396037" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/fileLeaks.c" desc="return 0;" ElType="." rngLn="35" />
        <ElDesc lineHash="125" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/fileLeaks.c" desc="}" ElType=".P" rngLn="36">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Opened file: file" kind="var" />
            <Ann msg="Point where opened file is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="38" locFile="/BugDetective/fileLeaks.c" locStartln="38" sev="4" auth="root" locRef="5" rule="MISRAC2012-DIR_4_6-b" lnHash="820955547" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="820955547" unbViolId="f9119d57-5683-3d1c-b286-946760eb6efc" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d53618cc-6922-31ef-b65b-a820cb778fd5" locEndPos="1" locType="sr" hash="1210532432" locEndLn="38" goals="0," />
    <StdViol msg="Prototype of function 'displayContentOfSeveralFiles' does not precede function definition" ln="38" locFile="/BugDetective/fileLeaks.c" locStartln="38" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_8_4-a" lnHash="820955547" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="820955547" unbViolId="173b99d0-5f70-360f-926e-2a07679ad2cb" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="34c0119e-4536-39b8-ab67-8c7a68cb3556" locEndPos="5" locType="sr" hash="1210532432" locEndLn="38" goals="0," />
    <StdViol msg="Function 'displayContentOfSeveralFiles' is not in prototype form" ln="38" locFile="/BugDetective/fileLeaks.c" locStartln="38" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_1_5-c" lnHash="820955547" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="820955547" unbViolId="3960cd8b-4e1d-337f-b0e7-44db2c16d8e4" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="656ecee8-6755-3cd8-9183-8451ae4e4ac3" locEndPos="5" locType="sr" hash="1210532432" locEndLn="38" goals="0," />
    <StdViol msg="Function 'displayContentOfSeveralFiles' is not in prototype form" ln="38" locFile="/BugDetective/fileLeaks.c" locStartln="38" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_8_2-c" lnHash="820955547" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="820955547" unbViolId="2b135603-8c3c-329e-b3b3-3c51e5e9c937" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c64120f1-e7db-3847-907c-95351171ca73" locEndPos="5" locType="sr" hash="1210532432" locEndLn="38" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="40" locFile="/BugDetective/fileLeaks.c" locStartln="40" sev="4" auth="root" locRef="5" rule="MISRAC2012-DIR_4_6-b" lnHash="1104249178" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1104249178" unbViolId="bd3adb6e-f9b6-3e80-830e-09f26ca982de" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f446d8c8-96bb-3eb7-969c-2dfb5292e947" locEndPos="5" locType="sr" hash="1210532432" locEndLn="40" goals="0," />
    <StdViol msg="String literal is assigned to pointer to non-const object: names" ln="41" locFile="/BugDetective/fileLeaks.c" locStartln="41" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_7_4-a" lnHash="930469328" rule.header="A string literal shall not be modified" tool="c++test" lineHash="930469328" unbViolId="784ccc71-2d43-36d9-8301-0226a14aa553" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dc32ced3-aecf-392b-b8bc-42c6b7374d37" locEndPos="18" locType="sr" hash="1210532432" locEndLn="41" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="46" locFile="/BugDetective/fileLeaks.c" locStartln="46" sev="4" auth="root" locRef="5" rule="MISRAC2012-DIR_4_6-b" lnHash="1679375043" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1679375043" unbViolId="eb8ec0e6-4e80-32ed-88e9-0b630109d8eb" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="81e1bbcf-1b7e-3279-8acc-5cabe2fc7952" locEndPos="5" locType="sr" hash="1210532432" locEndLn="46" goals="0," />
    <FlowViol msg="File not closed: file" ln="49" locFile="/BugDetective/fileLeaks.c" ruleSAFMsg="Point where opened file is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="50" rule="MISRAC2012-RULE_22_1-a" FirstElSrcRngStartPos="0" lnHash="1237972298" ruleSCSCMsg="Point where file is opened" FirstElSrcRngFile="/BugDetective/fileLeaks.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="49" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="603044296" lang="cpp" violId="e5110ded-0f50-3e4f-9c9f-ca7119789c60" locEndPos="0" locEndLn="50" goals="0," locStartln="49" sev="2" locRef="5" tool="c++test" lineHash="1237972298" unbViolId="afadea47-6ff9-3d34-a72b-74e5cf09873a" locType="sr" hash="1210532432" causeLocRef="5">
      <Props>
        <Prop key="Tracked variables" val="Opened file" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1104249178" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/fileLeaks.c" desc="int ARRSIZE = 3;" ElType="." rngLn="40" />
        <ElDesc lineHash="1679375043" ln="46" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="46" srcRngEndLn="47" srcRngFile="/BugDetective/fileLeaks.c" desc="int i;" ElType="." rngLn="46" />
        <ElDesc lineHash="-587502381" ln="47" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="47" srcRngEndLn="48" srcRngFile="/BugDetective/fileLeaks.c" desc="FILE *file = NULL;" ElType="." rngLn="47" />
        <ElDesc lineHash="1072446173" ln="48" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="48" srcRngEndLn="49" srcRngFile="/BugDetective/fileLeaks.c" desc="for (i = 0; i &lt; ARRSIZE; ++i) {" ElType="." rngLn="48">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; ARRSIZE) (true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1237972298" ln="49" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="49" srcRngEndLn="50" srcRngFile="/BugDetective/fileLeaks.c" desc="file = fopen(names[i], &quot;r&quot;);" ElType=".C" rngLn="49">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Point where file is opened" kind="cause" />
            <Ann msg="Opened file: file" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1109565686" ln="50" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="50" srcRngEndLn="51" srcRngFile="/BugDetective/fileLeaks.c" desc="if(file==NULL) {" ElType="." rngLn="50">
          <Anns>
            <Ann msg="Condition evaluation: (file == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="887323629" ln="54" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="54" srcRngEndLn="55" srcRngFile="/BugDetective/fileLeaks.c" desc="printFile(file);" ElType="." rngLn="54">
          <ElDescList>
            <ElDesc lineHash="-695983806" ln="11" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="11" srcRngEndLn="12" srcRngFile="/BugDetective/fileLeaks.c" desc="char c;" ElType="." rngLn="11">
              <Props>
                <Prop key="Tracked variables" val="file" />
              </Props>
              <Anns>
                <Ann msg="Opened file: file" kind="var" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1807758733" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/fileLeaks.c" desc="printf(&quot;Reading file contents:\n\n&quot;);" ElType="." rngLn="12" />
            <ElDesc lineHash="66462730" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/fileLeaks.c" desc="while(1) {" ElType="." rngLn="13">
              <Anns>
                <Ann msg="Loop condition evaluation: 1 (true)" kind="condEval" />
                <Ann msg="Entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1093133731" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/fileLeaks.c" desc="c = fgetc(file);" ElType="." rngLn="14" />
            <ElDesc lineHash="161967170" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/fileLeaks.c" desc="if (c!=EOF) {" ElType="." rngLn="15">
              <Anns>
                <Ann msg="Condition evaluation: (c != -1) (assuming false)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="207609628" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/fileLeaks.c" desc="break;" ElType="." rngLn="18">
              <Anns>
                <Ann msg="Exit the loop" kind="condEval" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
        <ElDesc lineHash="1072446173" ln="48" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="48" srcRngEndLn="49" srcRngFile="/BugDetective/fileLeaks.c" desc="for (i = 0; i &lt; ARRSIZE; ++i) {" ElType="." rngLn="48">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; ARRSIZE) (assuming true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1237972298" ln="49" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="49" srcRngEndLn="50" srcRngFile="/BugDetective/fileLeaks.c" desc="file = fopen(names[i], &quot;r&quot;);" ElType=".P" rngLn="49">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Opened file: file" kind="var" />
            <Ann msg="Point where opened file is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="File not closed: file" ln="49" locFile="/BugDetective/fileLeaks.c" ruleSAFMsg="Point where opened file is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="50" rule="MISRAC2012-DIR_4_13-a" FirstElSrcRngStartPos="0" lnHash="1237972298" ruleSCSCMsg="Point where file is opened" FirstElSrcRngFile="/BugDetective/fileLeaks.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="49" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="603044296" lang="cpp" violId="0ce8d365-aca5-31c3-a527-bb9c18131e25" locEndPos="0" locEndLn="50" goals="0," locStartln="49" sev="4" locRef="5" tool="c++test" lineHash="1237972298" unbViolId="f386805e-cfd6-3a43-80e0-e25aa8e881eb" locType="sr" hash="1210532432" causeLocRef="5">
      <Props>
        <Prop key="Tracked variables" val="Opened file" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1104249178" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/fileLeaks.c" desc="int ARRSIZE = 3;" ElType="." rngLn="40" />
        <ElDesc lineHash="1679375043" ln="46" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="46" srcRngEndLn="47" srcRngFile="/BugDetective/fileLeaks.c" desc="int i;" ElType="." rngLn="46" />
        <ElDesc lineHash="-587502381" ln="47" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="47" srcRngEndLn="48" srcRngFile="/BugDetective/fileLeaks.c" desc="FILE *file = NULL;" ElType="." rngLn="47" />
        <ElDesc lineHash="1072446173" ln="48" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="48" srcRngEndLn="49" srcRngFile="/BugDetective/fileLeaks.c" desc="for (i = 0; i &lt; ARRSIZE; ++i) {" ElType="." rngLn="48">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; ARRSIZE) (true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1237972298" ln="49" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="49" srcRngEndLn="50" srcRngFile="/BugDetective/fileLeaks.c" desc="file = fopen(names[i], &quot;r&quot;);" ElType=".C" rngLn="49">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Point where file is opened" kind="cause" />
            <Ann msg="Opened file: file" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1109565686" ln="50" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="50" srcRngEndLn="51" srcRngFile="/BugDetective/fileLeaks.c" desc="if(file==NULL) {" ElType="." rngLn="50">
          <Anns>
            <Ann msg="Condition evaluation: (file == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="887323629" ln="54" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="54" srcRngEndLn="55" srcRngFile="/BugDetective/fileLeaks.c" desc="printFile(file);" ElType="." rngLn="54">
          <ElDescList>
            <ElDesc lineHash="-695983806" ln="11" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="11" srcRngEndLn="12" srcRngFile="/BugDetective/fileLeaks.c" desc="char c;" ElType="." rngLn="11">
              <Props>
                <Prop key="Tracked variables" val="file" />
              </Props>
              <Anns>
                <Ann msg="Opened file: file" kind="var" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1807758733" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/fileLeaks.c" desc="printf(&quot;Reading file contents:\n\n&quot;);" ElType="." rngLn="12" />
            <ElDesc lineHash="66462730" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/fileLeaks.c" desc="while(1) {" ElType="." rngLn="13">
              <Anns>
                <Ann msg="Loop condition evaluation: 1 (true)" kind="condEval" />
                <Ann msg="Entering the loop" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1093133731" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/fileLeaks.c" desc="c = fgetc(file);" ElType="." rngLn="14" />
            <ElDesc lineHash="161967170" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/fileLeaks.c" desc="if (c!=EOF) {" ElType="." rngLn="15">
              <Anns>
                <Ann msg="Condition evaluation: (c != -1) (assuming false)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="207609628" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/fileLeaks.c" desc="break;" ElType="." rngLn="18">
              <Anns>
                <Ann msg="Exit the loop" kind="condEval" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
        <ElDesc lineHash="1072446173" ln="48" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="48" srcRngEndLn="49" srcRngFile="/BugDetective/fileLeaks.c" desc="for (i = 0; i &lt; ARRSIZE; ++i) {" ElType="." rngLn="48">
          <Anns>
            <Ann msg="Loop condition evaluation: (i &lt; ARRSIZE) (assuming true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1237972298" ln="49" srcRngStartPos="0" srcRngEndPos="0" locRef="5" locType="sr" srcRnghash="1210532432" srcRngStartln="49" srcRngEndLn="50" srcRngFile="/BugDetective/fileLeaks.c" desc="file = fopen(names[i], &quot;r&quot;);" ElType=".P" rngLn="49">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Opened file: file" kind="var" />
            <Ann msg="Point where opened file is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'fopen' function is not allowed" ln="49" locFile="/BugDetective/fileLeaks.c" locStartln="49" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="1237972298" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="1237972298" unbViolId="02f5fd97-5105-3242-8599-de4ab1fdf41e" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="641ec8a0-4f72-3b14-b833-d8660f87a10e" locEndPos="16" locType="sr" hash="1210532432" locEndLn="49" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="51" locFile="/BugDetective/fileLeaks.c" locStartln="51" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="247264212" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="247264212" unbViolId="ad55e127-ec3b-3ebf-87af-78d1c5cb81b1" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ee438fd0-4775-373d-9a84-da421c5ed313" locEndPos="13" locType="sr" hash="1210532432" locEndLn="51" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="51" locFile="/BugDetective/fileLeaks.c" locStartln="51" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_17_7-a" lnHash="247264212" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="247264212" unbViolId="d72db30b-3802-3734-80fa-8afce2912ca9" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cde88dff-e6d3-3f7b-b354-f995c315dd62" locEndPos="13" locType="sr" hash="1210532432" locEndLn="51" goals="0," />
    <StdViol msg="Provide only one exit point in 'displayContentOfSeveralFiles' function" ln="52" locFile="/BugDetective/fileLeaks.c" locStartln="52" sev="4" auth="root" locRef="5" rule="MISRAC2012-RULE_15_5-a" lnHash="1117575962" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="1117575962" unbViolId="1e3a2d4a-eb1e-3fdf-9e91-5529ae069f80" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b5413224-2c8f-37d7-b068-045b92f7d806" locEndPos="13" locType="sr" hash="1210532432" locEndLn="52" goals="0," />
    <StdViol msg="Usage of 'fclose' function is not allowed" ln="57" locFile="/BugDetective/fileLeaks.c" locStartln="57" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_21_6-a" lnHash="191846468" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="191846468" unbViolId="2a92b37e-56da-3390-b366-3d4309747ee9" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="64887dbe-475d-387b-b488-1cf20f194cd0" locEndPos="5" locType="sr" hash="1210532432" locEndLn="57" goals="0," />
    <StdViol msg="Unused function's &quot;fclose&quot; return value" ln="57" locFile="/BugDetective/fileLeaks.c" locStartln="57" sev="2" auth="root" locRef="5" rule="MISRAC2012-RULE_17_7-a" lnHash="191846468" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="191846468" unbViolId="37c5fb7d-a827-30eb-9c29-62b28fb2678a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4b2efde0-9cde-3fff-8421-1ee8bb4a9fd4" locEndPos="5" locType="sr" hash="1210532432" locEndLn="57" goals="0," />
    <StdViol msg="Provide only one exit point in 'displayContentOfSeveralFiles' function" ln="58" locFile="/BugDetective/fileLeaks.c" locStartln="58" sev="4" auth="root" locRef="5" rule="MISRAC2012-RULE_15_5-a" lnHash="-1256396037" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256396037" unbViolId="078f78d8-cfbc-3023-88e6-97e2a074eeab" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ee912cda-7e08-3090-93dc-a10ba76e0a3b" locEndPos="5" locType="sr" hash="1210532432" locEndLn="58" goals="0," />
    <StdViol msg="Declaration of object 'buffer' does not precede its definition" ln="8" locFile="/BugDetective/integerOverflow.c" locStartln="8" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_8_4-a" lnHash="-2118839699" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-2118839699" unbViolId="58337e9c-a9a8-328c-bd07-4efc1231aca5" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2d9ceda0-2981-3186-a5a9-e5890b9df1d3" locEndPos="6" locType="sr" hash="-1197576192" locEndLn="8" goals="0," />
    <StdViol msg="The 'buffer' object is also defined in other translation units" ln="8" locFile="/BugDetective/integerOverflow.c" locStartln="8" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_8_6-a" lnHash="-2118839699" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="-2118839699" unbViolId="b36506b2-83b1-3949-ac0f-bba47bc3211d" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="097db555-bf00-3902-9fd1-3d0d59195502" locEndPos="6" locType="sr" hash="-1197576192" locEndLn="8" goals="0," />
    <StdViol msg="The 'buffer' object has incompatible declarations in other translation units" ln="8" locFile="/BugDetective/integerOverflow.c" locStartln="8" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_8_3-c" lnHash="-2118839699" rule.header="All declarations of an object or function shall have compatible types" tool="c++test" lineHash="-2118839699" unbViolId="c1fa051c-1ce5-33f9-8ea8-9e00c23646c3" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="9e68eb20-deb3-3f41-9923-616f4e566e39" locEndPos="6" locType="sr" hash="-1197576192" locEndLn="8" goals="0," />
    <StdViol msg="Prototype of function 'decode' does not precede function definition" ln="10" locFile="/BugDetective/integerOverflow.c" locStartln="10" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_8_4-a" lnHash="-754790912" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-754790912" unbViolId="c6c283fe-a5bf-30e7-a8e8-6b65fb61032b" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c31cc42b-5e0a-3c38-bb4f-ad4ed210fcaf" locEndPos="6" locType="sr" hash="-1197576192" locEndLn="10" goals="0," />
    <StdViol msg="The function 'decode' is referenced only in the translation unit where it is defined" ln="10" locFile="/BugDetective/integerOverflow.c" locStartln="10" sev="4" auth="root" locRef="6" rule="MISRAC2012-RULE_8_7-a" lnHash="-754790912" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-754790912" unbViolId="3e552862-1b4a-3e38-83cd-688b3d35ec87" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="ea6085fe-fd13-3368-ad6f-206d8f732f69" locEndPos="6" locType="sr" hash="-1197576192" locEndLn="10" goals="0," />
    <StdViol msg="Prototype of function 'readMessage' does not precede function definition" ln="16" locFile="/BugDetective/integerOverflow.c" locStartln="16" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_8_4-a" lnHash="-1484703711" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1484703711" unbViolId="4d4a84a7-357a-308e-9295-62f60f083b15" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c7c0371d-4c00-343c-a66d-046443343476" locEndPos="7" locType="sr" hash="-1197576192" locEndLn="16" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="16" locFile="/BugDetective/integerOverflow.c" locStartln="16" sev="4" auth="root" locRef="6" rule="MISRAC2012-DIR_4_6-b" lnHash="-1484703711" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1484703711" unbViolId="2c9443f2-fb43-3f2f-958a-9b38650e13d0" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f1c4eb69-448f-327c-ae0b-1065dc59df22" locEndPos="19" locType="sr" hash="-1197576192" locEndLn="16" goals="0," />
    <StdViol msg="Pass parameter &quot;header&quot; with const specifier" ln="16" locFile="/BugDetective/integerOverflow.c" locStartln="16" sev="4" auth="root" locRef="6" rule="MISRAC2012-RULE_8_13-a" lnHash="-1484703711" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="-1484703711" unbViolId="e73b1d77-84cc-37c6-b2d3-9064bdac0cd7" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="75d83202-27b1-3813-b808-9450f2b56180" locEndPos="37" locType="sr" hash="-1197576192" locEndLn="16" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="16" locFile="/BugDetective/integerOverflow.c" locStartln="16" sev="4" auth="root" locRef="6" rule="MISRAC2012-DIR_4_6-b" lnHash="-1484703711" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1484703711" unbViolId="df045a80-7e78-3f26-82d8-942f74c86a9e" locStartPos="44" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92102d54-eaa8-3cb0-8d00-543372be3f49" locEndPos="45" locType="sr" hash="-1197576192" locEndLn="16" goals="0," />
    <StdViol msg="Parameter 'len' is not used in function 'readMessage'" ln="16" locFile="/BugDetective/integerOverflow.c" locStartln="16" sev="4" auth="root" locRef="6" rule="MISRAC2012-RULE_2_7-a" lnHash="-1484703711" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="-1484703711" unbViolId="47f5258a-4c04-326b-8898-37399fc54182" locStartPos="48" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="75121054-6dc9-376c-9c8b-56046ba65c94" locEndPos="49" locType="sr" hash="-1197576192" locEndLn="16" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="18" locFile="/BugDetective/integerOverflow.c" locStartln="18" sev="4" auth="root" locRef="6" rule="MISRAC2012-DIR_4_6-b" lnHash="-728176747" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-728176747" unbViolId="7dd29821-c0ad-3aa6-b766-0681e85f846f" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b503f2eb-95ed-3f2f-9f1c-333ce7486854" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="18" goals="0," />
    <StdViol msg="The basic numerical type 'long' should not be used" ln="19" locFile="/BugDetective/integerOverflow.c" locStartln="19" sev="4" auth="root" locRef="6" rule="MISRAC2012-DIR_4_6-b" lnHash="1710618239" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1710618239" unbViolId="6b826bba-9e3a-3138-81b6-75b9bc5364ad" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="205618ed-7ad4-3500-9ca0-4ab71c1cd7c1" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="19" goals="0," />
    <StdViol msg="Unused function's &quot;recv&quot; return value" ln="23" locFile="/BugDetective/integerOverflow.c" locStartln="23" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_17_7-a" lnHash="762177369" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="762177369" unbViolId="09899712-c56e-33d3-9254-4bf887eed4f3" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6137497f-211d-3933-aa45-d60359033f9f" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="23" goals="0," />
    <StdViol msg="Usage of 'atol' function is not allowed" ln="24" locFile="/BugDetective/integerOverflow.c" locStartln="24" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_21_7-a" lnHash="63245237" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="63245237" unbViolId="7d6c233a-a409-3124-befa-9e0ea88ba842" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1347436f-b497-37ff-a95b-0b6ce6fb29de" locEndPos="12" locType="sr" hash="-1197576192" locEndLn="24" goals="0," />
    <StdViol msg="The expression of the 'essentially unsigned' type is assigned to an object with the 'essentially signed' type" ln="25" locFile="/BugDetective/integerOverflow.c" locStartln="25" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_10_3-b" lnHash="1998902284" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="1998902284" unbViolId="1c2636bc-177b-359f-9bfc-780f72ccfec6" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2f39cb3d-3b0a-3250-ab04-aa2784890f2e" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="25" goals="0," />
    <StdViol msg="The expression of the 'essentially signed' type is assigned to an object with the 'essentially unsigned' type" ln="26" locFile="/BugDetective/integerOverflow.c" locStartln="26" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_10_3-b" lnHash="-295809370" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="-295809370" unbViolId="56b89239-5b90-3d3d-8ae6-742428be8c0d" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="58380086-a9ad-3b08-9549-6bd8c349b000" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="26" goals="0," />
    <StdViol msg="Operands of the '+=' operator have different essential types: 'unsigned long' and 'long'" ln="27" locFile="/BugDetective/integerOverflow.c" locStartln="27" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_10_4-a" lnHash="-1332386784" rule.header="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" tool="c++test" lineHash="-1332386784" unbViolId="44db8437-53ed-331d-a308-8325e8d0c8aa" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="87f3144a-fd58-31ee-b542-b540248bcd85" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="27" goals="0," />
    <FlowViol msg="Usage of possibly overflowed/underflowed value: total_len" ln="29" locFile="/BugDetective/integerOverflow.c" ruleSAFMsg="Point of using possibly overflowed/underflowed value" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="24" rule="MISRAC2012-DIR_4_14-b" FirstElSrcRngStartPos="0" lnHash="-711727233" ruleSCSCMsg="Point where value is defined by tainting function" FirstElSrcRngFile="/BugDetective/integerOverflow.c" rule.header="Protect against integer overflow/underflow from tainted data" FirstElSrcRngStartln="23" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1907083985" lang="cpp" violId="da33150a-c284-3d03-8e70-e83cec21f73e" locEndPos="0" locEndLn="30" goals="0," locStartln="29" sev="2" locRef="6" tool="c++test" lineHash="-711727233" unbViolId="592aefe3-0848-3810-bdf8-4718be75f8fb" locType="sr" hash="-1197576192" causeLocRef="6">
      <Props>
        <Prop key="Tracked variables" val="Tainted data" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-728176747" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/integerOverflow.c" desc="int i, header_len;" ElType="." rngLn="18" />
        <ElDesc lineHash="1710618239" ln="19" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="19" srcRngEndLn="20" srcRngFile="/BugDetective/integerOverflow.c" desc="long msg_len;" ElType="." rngLn="19" />
        <ElDesc lineHash="184186530" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/BugDetective/integerOverflow.c" desc="size_t total_len;" ElType="." rngLn="20" />
        <ElDesc lineHash="339000195" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/integerOverflow.c" desc="char *msg;" ElType="." rngLn="21" />
        <ElDesc lineHash="762177369" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/BugDetective/integerOverflow.c" desc="recv(socket, buffer, BUFFER_SIZE, MSG_NOSIGNAL);" ElType=".C" rngLn="23">
          <Props>
            <Prop key="Tracked variables" val="buffer[]" />
          </Props>
          <Anns>
            <Ann msg="Point where value is defined by tainting function" kind="cause" />
            <Ann msg="Tainted data: buffer[]" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="63245237" ln="24" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="24" srcRngEndLn="25" srcRngFile="/BugDetective/integerOverflow.c" desc="msg_len = atol(buffer);" ElType="!" rngLn="24" />
        <ElDesc lineHash="1998902284" ln="25" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="25" srcRngEndLn="26" srcRngFile="/BugDetective/integerOverflow.c" desc="header_len = strlen(header);" ElType="." rngLn="25">
          <Props>
            <Prop key="Tracked variables" val="msg_len" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: msg_len" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-295809370" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/integerOverflow.c" desc="total_len = header_len;" ElType="." rngLn="26" />
        <ElDesc lineHash="-1332386784" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/integerOverflow.c" desc="total_len += msg_len; /* POSSIBLE INTEGER OVERFLOW HERE */" ElType="!" rngLn="27">
          <Anns>
            <Ann msg="Point of possible overflow/underflow" kind="info" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-711727233" ln="29" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="29" srcRngEndLn="30" srcRngFile="/BugDetective/integerOverflow.c" desc="malloc(...)" ElType=".P" rngLn="29">
          <Props>
            <Prop key="Tracked variables" val="total_len" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: total_len" kind="var" />
            <Ann msg="Point of using possibly overflowed/underflowed value" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Pointer to void type should not be converted to pointer to object type 'char *'" ln="29" locFile="/BugDetective/integerOverflow.c" locStartln="29" sev="4" auth="root" locRef="6" rule="MISRAC2012-RULE_11_5-a" lnHash="-711727233" rule.header="A conversion should not be performed from pointer to void into pointer to object" tool="c++test" lineHash="-711727233" unbViolId="0fb49275-706a-3bb0-8f77-adc6c4da501b" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bea9de37-ba60-37cc-ae86-1dde3ce1b76d" locEndPos="8" locType="sr" hash="-1197576192" locEndLn="29" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="29" locFile="/BugDetective/integerOverflow.c" locStartln="29" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_21_3-a" lnHash="-711727233" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-711727233" unbViolId="97f1787a-7882-3d61-bb58-f56823c91a6a" locStartPos="14" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f7b1c8a-5dd8-3316-a7d3-6b83a64924cf" locEndPos="15" locType="sr" hash="-1197576192" locEndLn="29" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="29" locFile="/BugDetective/integerOverflow.c" locStartln="29" sev="2" auth="root" locRef="6" rule="MISRAC2012-DIR_4_12-a" lnHash="-711727233" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-711727233" unbViolId="714a0882-d576-3713-a8fe-e41346b30764" locStartPos="14" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8dbbf701-26b5-3445-b2b8-adad8c9b665a" locEndPos="15" locType="sr" hash="-1197576192" locEndLn="29" goals="0," />
    <StdViol msg="Provide only one exit point in 'readMessage' function" ln="31" locFile="/BugDetective/integerOverflow.c" locStartln="31" sev="4" auth="root" locRef="6" rule="MISRAC2012-RULE_15_5-a" lnHash="-1688062501" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1688062501" unbViolId="39e9f37e-2cf9-3e9a-adf7-910ff535dc34" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="85ce5d2b-dc59-3bc1-8951-cbbfb9a9c513" locEndPos="3" locType="sr" hash="-1197576192" locEndLn="31" goals="0," />
    <StdViol msg="Function with pointer return type returns '0'" ln="31" locFile="/BugDetective/integerOverflow.c" locStartln="31" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_11_9-a" lnHash="-1688062501" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-1688062501" unbViolId="d7d42cd4-7fc1-33d6-9a2c-bffd86a8c6da" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aae0c0ef-5ee0-3491-93fe-9b7ea51fb8a7" locEndPos="10" locType="sr" hash="-1197576192" locEndLn="31" goals="0," />
    <StdViol msg="Function with pointer return type returns '0'" ln="31" locFile="/BugDetective/integerOverflow.c" locStartln="31" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_11_9-b" lnHash="-1688062501" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-1688062501" unbViolId="d483bcb9-8b78-3901-8257-5dada9c1ce71" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6d712781-9662-3558-b6d0-526f4a5d1150" locEndPos="10" locType="sr" hash="-1197576192" locEndLn="31" goals="0," />
    <StdViol msg="Unused function's &quot;strcpy&quot; return value" ln="34" locFile="/BugDetective/integerOverflow.c" locStartln="34" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_17_7-a" lnHash="191649072" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="191649072" unbViolId="54fe21f4-95ea-3218-9cae-7a5daa52747b" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9488157d-66fe-3587-bb1a-aae93f18615f" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="34" goals="0," />
    <StdViol msg="Unused function's &quot;recv&quot; return value" ln="36" locFile="/BugDetective/integerOverflow.c" locStartln="36" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_17_7-a" lnHash="1570251949" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="1570251949" unbViolId="d34ae3e9-8485-390b-956b-5a6caacb9926" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0617e0f6-3c77-34c5-8be6-6221997b185a" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="36" goals="0," />
    <StdViol msg="The variable 'msg' used as the left hand side operand of the '+' operator has a pointer type" ln="36" locFile="/BugDetective/integerOverflow.c" locStartln="36" sev="4" auth="root" locRef="6" rule="MISRAC2012-RULE_18_4-a" lnHash="1570251949" rule.header="The +, -, += and -= operators should not be applied to an expression of pointer type" tool="c++test" lineHash="1570251949" unbViolId="c78ea038-7424-3bf3-bc22-ef0bd1e5ccdc" locStartPos="14" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1067bb8b-733c-3307-af2e-c3550e393205" locEndPos="15" locType="sr" hash="-1197576192" locEndLn="36" goals="0," />
    <StdViol msg="The argument number '3' ('essentially signed' type) is passed to the function 'recv' as a parameter with the 'essentially unsigned' type" ln="36" locFile="/BugDetective/integerOverflow.c" locStartln="36" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_10_3-b" lnHash="1570251949" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="1570251949" unbViolId="12ffada7-1c65-39d5-b488-3dd96a257263" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="673dfde6-677c-312c-9158-d891dbf1ab5f" locEndPos="30" locType="sr" hash="-1197576192" locEndLn="36" goals="0," />
    <FlowViol msg="Usage of possibly overflowed/underflowed value: total_len" ln="38" locFile="/BugDetective/integerOverflow.c" ruleSAFMsg="Point of using possibly overflowed/underflowed value" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="24" rule="MISRAC2012-DIR_4_14-b" FirstElSrcRngStartPos="0" lnHash="-1145053432" ruleSCSCMsg="Point where value is defined by tainting function" FirstElSrcRngFile="/BugDetective/integerOverflow.c" rule.header="Protect against integer overflow/underflow from tainted data" FirstElSrcRngStartln="23" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1363473727" lang="cpp" violId="71e1cfa8-9416-3780-9966-bee69c40b159" locEndPos="0" locEndLn="39" goals="0," locStartln="38" sev="2" locRef="6" tool="c++test" lineHash="-1145053432" unbViolId="40c22748-e4cb-3b01-b9ec-a9505dde3fd2" locType="sr" hash="-1197576192" causeLocRef="6">
      <Props>
        <Prop key="Tracked variables" val="Tainted data" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-728176747" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/integerOverflow.c" desc="int i, header_len;" ElType="." rngLn="18" />
        <ElDesc lineHash="1710618239" ln="19" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="19" srcRngEndLn="20" srcRngFile="/BugDetective/integerOverflow.c" desc="long msg_len;" ElType="." rngLn="19" />
        <ElDesc lineHash="184186530" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/BugDetective/integerOverflow.c" desc="size_t total_len;" ElType="." rngLn="20" />
        <ElDesc lineHash="339000195" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/integerOverflow.c" desc="char *msg;" ElType="." rngLn="21" />
        <ElDesc lineHash="762177369" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/BugDetective/integerOverflow.c" desc="recv(socket, buffer, BUFFER_SIZE, MSG_NOSIGNAL);" ElType=".C" rngLn="23">
          <Props>
            <Prop key="Tracked variables" val="buffer[]" />
          </Props>
          <Anns>
            <Ann msg="Point where value is defined by tainting function" kind="cause" />
            <Ann msg="Tainted data: buffer[]" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="63245237" ln="24" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="24" srcRngEndLn="25" srcRngFile="/BugDetective/integerOverflow.c" desc="msg_len = atol(buffer);" ElType="!" rngLn="24" />
        <ElDesc lineHash="1998902284" ln="25" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="25" srcRngEndLn="26" srcRngFile="/BugDetective/integerOverflow.c" desc="header_len = strlen(header);" ElType="." rngLn="25">
          <Props>
            <Prop key="Tracked variables" val="msg_len" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: msg_len" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-295809370" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/integerOverflow.c" desc="total_len = header_len;" ElType="." rngLn="26" />
        <ElDesc lineHash="-1332386784" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/integerOverflow.c" desc="total_len += msg_len; /* POSSIBLE INTEGER OVERFLOW HERE */" ElType="!" rngLn="27">
          <Anns>
            <Ann msg="Point of possible overflow/underflow" kind="info" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-711727233" ln="29" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="29" srcRngEndLn="30" srcRngFile="/BugDetective/integerOverflow.c" desc="msg = (char*)malloc(total_len); /* VIOLATION, USAGE OF OVERFLOWED VALUE */" ElType="." rngLn="29">
          <Props>
            <Prop key="Tracked variables" val="total_len" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: total_len" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="37614934" ln="30" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="30" srcRngEndLn="31" srcRngFile="/BugDetective/integerOverflow.c" desc="if (!msg) {" ElType="." rngLn="30">
          <Anns>
            <Ann msg="Condition evaluation: !msg (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="191649072" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/integerOverflow.c" desc="strcpy(msg, header);" ElType="." rngLn="34" />
        <ElDesc lineHash="1570251949" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/integerOverflow.c" desc="recv(socket, msg + msg_len, msg_len, MSG_NOSIGNAL);" ElType="." rngLn="36" />
        <ElDesc lineHash="-1145053432" ln="38" srcRngStartPos="0" srcRngEndPos="0" locRef="6" locType="sr" srcRnghash="-1197576192" srcRngStartln="38" srcRngEndLn="39" srcRngFile="/BugDetective/integerOverflow.c" desc="for (i = header_len; i &lt; total_len; i++) { /* VIOLATION, USAGE OF OVERFLOWED VALUE */" ElType=".P" rngLn="38">
          <Props>
            <Prop key="Tracked variables" val="total_len" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: total_len" kind="var" />
            <Ann msg="Point of using possibly overflowed/underflowed value" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Operands of the '&lt;' operator have different essential types: 'int' and 'unsigned long'" ln="38" locFile="/BugDetective/integerOverflow.c" locStartln="38" sev="2" auth="root" locRef="6" rule="MISRAC2012-RULE_10_4-a" lnHash="-1145053432" rule.header="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" tool="c++test" lineHash="-1145053432" unbViolId="7533e2d8-b8be-382b-949d-0dc64f0b2dc6" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="22a9c6f2-7548-3c50-93c6-af05eae4083a" locEndPos="23" locType="sr" hash="-1197576192" locEndLn="38" goals="0," />
    <StdViol msg="Provide only one exit point in 'readMessage' function" ln="41" locFile="/BugDetective/integerOverflow.c" locStartln="41" sev="4" auth="root" locRef="6" rule="MISRAC2012-RULE_15_5-a" lnHash="-382891487" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-382891487" unbViolId="2406b8de-06be-3923-87c5-f04fd89b8ce5" locStartPos="1" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8e046061-07d9-3ab5-a8f3-5e4a39bdb7e7" locEndPos="2" locType="sr" hash="-1197576192" locEndLn="41" goals="0," />
    <StdViol msg="Prototype of function 'storePerson' does not precede function definition" ln="5" locFile="/BugDetective/memoryLeaks.c" locStartln="5" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_8_4-a" lnHash="658091286" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="658091286" unbViolId="877eee2e-70a0-3dbb-995a-439b7bde77f4" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b33c8e9c-9cb9-3f2f-8f10-0527c6de39dd" locEndPos="6" locType="sr" hash="1502549011" locEndLn="5" goals="0," />
    <StdViol msg="The function 'storePerson' is referenced only in the translation unit where it is defined" ln="5" locFile="/BugDetective/memoryLeaks.c" locStartln="5" sev="4" auth="root" locRef="7" rule="MISRAC2012-RULE_8_7-a" lnHash="658091286" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="658091286" unbViolId="8cc6522f-9d25-3513-ad22-6169247f4a59" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="7399b52d-7ff7-3560-8553-78e05d8e29c4" locEndPos="6" locType="sr" hash="1502549011" locEndLn="5" goals="0," />
    <StdViol msg="Pass parameter &quot;p&quot; with const specifier" ln="5" locFile="/BugDetective/memoryLeaks.c" locStartln="5" sev="4" auth="root" locRef="7" rule="MISRAC2012-RULE_8_13-a" lnHash="658091286" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="658091286" unbViolId="7de97c82-0f6b-3ce0-8df5-6b9a3442894d" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4061cceb-6b9a-38d1-8512-f8992c9a6431" locEndPos="26" locType="sr" hash="1502549011" locEndLn="5" goals="0," />
    <StdViol msg="Parameter 'p' is not used in function 'storePerson'" ln="5" locFile="/BugDetective/memoryLeaks.c" locStartln="5" sev="4" auth="root" locRef="7" rule="MISRAC2012-RULE_2_7-a" lnHash="658091286" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="658091286" unbViolId="a5535713-51c8-3402-92ff-970ab22813d2" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="df7aee5f-11e0-3f55-bcc2-7f75b6821107" locEndPos="26" locType="sr" hash="1502549011" locEndLn="5" goals="0," />
    <StdViol msg="Prototype of function 'printPersonInfo' does not precede function definition" ln="10" locFile="/BugDetective/memoryLeaks.c" locStartln="10" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_8_4-a" lnHash="-1442826185" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1442826185" unbViolId="8325ccf5-7c5f-3232-84d9-265c2c44ce48" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="006476ad-0153-3897-937f-5ea38096ba17" locEndPos="6" locType="sr" hash="1502549011" locEndLn="10" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="14" locFile="/BugDetective/memoryLeaks.c" locStartln="14" sev="4" auth="root" locRef="7" rule="MISRAC2012-DIR_4_6-b" lnHash="-785260158" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-785260158" unbViolId="07ef0886-e959-353b-96a8-18b901d559f3" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ae3c0754-08b0-3374-a963-0cdae53b4e83" locEndPos="5" locType="sr" hash="1502549011" locEndLn="14" goals="0," />
    <StdViol msg="Usage of 'fgets' function is not allowed" ln="16" locFile="/BugDetective/memoryLeaks.c" locStartln="16" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_21_6-a" lnHash="-526658767" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-526658767" unbViolId="03963476-90a3-37fd-9801-3259b572e277" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="987de917-18f1-3e0a-b637-1e0c236b503a" locEndPos="13" locType="sr" hash="1502549011" locEndLn="16" goals="0," />
    <StdViol msg="Pointer to void type should not be converted to pointer to object type 'Person *'" ln="18" locFile="/BugDetective/memoryLeaks.c" locStartln="18" sev="4" auth="root" locRef="7" rule="MISRAC2012-RULE_11_5-a" lnHash="-1212191400" rule.header="A conversion should not be performed from pointer to void into pointer to object" tool="c++test" lineHash="-1212191400" unbViolId="76039662-d0ac-362c-98a0-7d66a09d8c20" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7942c0fc-8dd8-33d9-afeb-8eed2e3e5013" locEndPos="21" locType="sr" hash="1502549011" locEndLn="18" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="18" locFile="/BugDetective/memoryLeaks.c" locStartln="18" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_21_3-a" lnHash="-1212191400" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-1212191400" unbViolId="29e859ed-f73e-3328-aa70-86b3deb0a4c8" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f7c1fac9-e356-3017-90ed-f9d17f518b0d" locEndPos="25" locType="sr" hash="1502549011" locEndLn="18" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="18" locFile="/BugDetective/memoryLeaks.c" locStartln="18" sev="2" auth="root" locRef="7" rule="MISRAC2012-DIR_4_12-a" lnHash="-1212191400" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-1212191400" unbViolId="9840f6b9-dab0-3764-b92e-873800e30ff2" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="00da1afb-5c6c-3586-8234-ec2655797cc8" locEndPos="25" locType="sr" hash="1502549011" locEndLn="18" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'printPersonInfo' should be followed by a block" ln="19" locFile="/BugDetective/memoryLeaks.c" locStartln="19" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_15_6-b" lnHash="-812912267" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-812912267" unbViolId="518e1368-3a09-3bf9-a3c5-826ea9f4f01e" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="629c10ad-6650-3f10-8d14-1115919b7449" locEndPos="13" locType="sr" hash="1502549011" locEndLn="19" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="19" locFile="/BugDetective/memoryLeaks.c" locStartln="19" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_11_9-a" lnHash="-812912267" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-812912267" unbViolId="5b8cebbe-433e-3dee-b920-af64a8351e89" locStartPos="21" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7f9e2f14-1e2a-394f-994b-5ec6ebfaf052" locEndPos="22" locType="sr" hash="1502549011" locEndLn="19" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="19" locFile="/BugDetective/memoryLeaks.c" locStartln="19" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_11_9-b" lnHash="-812912267" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-812912267" unbViolId="31d6e013-1640-37bd-af62-3e5c29712b72" locStartPos="21" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c7c9cdf2-d1f5-3cad-9d2b-7cb9863af09d" locEndPos="22" locType="sr" hash="1502549011" locEndLn="19" goals="0," />
    <StdViol msg="Function 'exit' should be called at the end of the 'printPersonInfo' function" ln="19" locFile="/BugDetective/memoryLeaks.c" locStartln="19" sev="4" auth="root" locRef="7" rule="MISRAC2012-RULE_15_5-a" lnHash="-812912267" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-812912267" unbViolId="40a6e92a-d204-3d8f-829f-7e590f84a99d" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fc79c088-cf32-3e9d-bef1-87c024dc3ffa" locEndPos="25" locType="sr" hash="1502549011" locEndLn="19" goals="0," />
    <StdViol msg="The 'exit' library function should not be used" ln="19" locFile="/BugDetective/memoryLeaks.c" locStartln="19" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_21_8-b" lnHash="-812912267" rule.header="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" tool="c++test" lineHash="-812912267" unbViolId="3e4c0878-5590-3ba7-bf08-434c20332af9" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="33b3f67f-dfef-3b15-8606-7145e4e94836" locEndPos="25" locType="sr" hash="1502549011" locEndLn="19" goals="0," />
    <StdViol msg="The '++' operator should cause the only side effect in an expression" ln="20" locFile="/BugDetective/memoryLeaks.c" locStartln="20" sev="4" auth="root" locRef="7" rule="MISRAC2012-RULE_13_3-a" lnHash="1899725753" rule.header="A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects" tool="c++test" lineHash="1899725753" unbViolId="b3b14cab-2d02-3139-8829-22179e21c390" locStartPos="28" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d7918c53-96c9-38b1-ac55-bcb81ebbbeb0" locEndPos="29" locType="sr" hash="1502549011" locEndLn="20" goals="0," />
    <StdViol msg="Section of code should not be 'commented out'" ln="24" locFile="/BugDetective/memoryLeaks.c" locStartln="24" sev="4" auth="root" locRef="7" rule="MISRAC2012-DIR_4_4-a" lnHash="1183887968" rule.header="Sections of code should not be &quot;commented out&quot;" tool="c++test" lineHash="1183887968" unbViolId="ae61aa24-d2b4-3ecf-bf13-3f74707566de" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="df85ae88-299c-381f-8a0c-c175d3c62f52" locEndPos="13" locType="sr" hash="1502549011" locEndLn="24" goals="0," />
    <FlowViol msg="Memory not deallocated: p" ln="26" locFile="/BugDetective/memoryLeaks.c" ruleSAFMsg="Point where allocated memory is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="19" rule="MISRAC2012-RULE_22_1-a" FirstElSrcRngStartPos="0" lnHash="2099466359" ruleSCSCMsg="Point where memory is allocated" FirstElSrcRngFile="/BugDetective/memoryLeaks.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="18" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="585789567" lang="cpp" violId="1353d956-4f5e-319e-a01f-aeec55595ac4" locEndPos="0" locEndLn="27" goals="0," locStartln="26" sev="2" locRef="7" tool="c++test" lineHash="2099466359" unbViolId="2c8f4c19-72b5-349d-87c5-4c692757c17a" locType="sr" hash="1502549011" causeLocRef="7">
      <Props>
        <Prop key="Tracked variables" val="Allocated memory" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-100714984" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/memoryLeaks.c" desc="char *c;" ElType="." rngLn="12" />
        <ElDesc lineHash="39827869" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/memoryLeaks.c" desc="char buf[100];" ElType="." rngLn="13" />
        <ElDesc lineHash="-785260158" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/memoryLeaks.c" desc="int id = 0;" ElType="." rngLn="14" />
        <ElDesc lineHash="66462730" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/memoryLeaks.c" desc="while(1) {" ElType="." rngLn="15">
          <Anns>
            <Ann msg="Loop condition evaluation: 1 (true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-526658767" ln="16" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="16" srcRngEndLn="17" srcRngFile="/BugDetective/memoryLeaks.c" desc="c = fgets(buf, 100, file);" ElType="." rngLn="16" />
        <ElDesc lineHash="301978179" ln="17" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="17" srcRngEndLn="18" srcRngFile="/BugDetective/memoryLeaks.c" desc="if (c!=NULL) {" ElType="." rngLn="17">
          <Anns>
            <Ann msg="Condition evaluation: (c != 0) (assuming true)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1212191400" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/memoryLeaks.c" desc="malloc(...)" ElType=".C" rngLn="18">
          <Props>
            <Prop key="Tracked variables" val="malloc(...)" />
          </Props>
          <Anns>
            <Ann msg="Point where memory is allocated" kind="cause" />
            <Ann msg="Allocated memory: malloc(...)" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1212191400" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/memoryLeaks.c" desc="Person* p = malloc(sizeof(Person));" ElType="!" rngLn="18" />
        <ElDesc lineHash="-812912267" ln="19" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="19" srcRngEndLn="20" srcRngFile="/BugDetective/memoryLeaks.c" desc="if (p == 0) exit(1);" ElType="." rngLn="19">
          <Props>
            <Prop key="Tracked variables" val="p" />
          </Props>
          <Anns>
            <Ann msg="Allocated memory: p" kind="var" />
            <Ann msg="Condition evaluation: (p == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1899725753" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/BugDetective/memoryLeaks.c" desc="p->personalId = ++id;" ElType="." rngLn="20" />
        <ElDesc lineHash="-217028449" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/memoryLeaks.c" desc="p->name = buf;" ElType="." rngLn="21" />
        <ElDesc lineHash="-2076993264" ln="22" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="22" srcRngEndLn="23" srcRngFile="/BugDetective/memoryLeaks.c" desc="storePerson(p);" ElType="." rngLn="22" />
        <ElDesc lineHash="2099466359" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/memoryLeaks.c" desc="} else {" ElType=".P" rngLn="26">
          <Props>
            <Prop key="Tracked variables" val="p" />
          </Props>
          <Anns>
            <Ann msg="Allocated memory: p" kind="var" />
            <Ann msg="Point where allocated memory is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Memory not deallocated: p" ln="26" locFile="/BugDetective/memoryLeaks.c" ruleSAFMsg="Point where allocated memory is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="19" rule="MISRAC2012-DIR_4_13-a" FirstElSrcRngStartPos="0" lnHash="2099466359" ruleSCSCMsg="Point where memory is allocated" FirstElSrcRngFile="/BugDetective/memoryLeaks.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="18" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="585789567" lang="cpp" violId="24523ce2-32a6-35cb-aae2-a3d5a243c37f" locEndPos="0" locEndLn="27" goals="0," locStartln="26" sev="4" locRef="7" tool="c++test" lineHash="2099466359" unbViolId="696a209d-1a3e-3d5f-8c4b-0ab78503a9fd" locType="sr" hash="1502549011" causeLocRef="7">
      <Props>
        <Prop key="Tracked variables" val="Allocated memory" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-100714984" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/memoryLeaks.c" desc="char *c;" ElType="." rngLn="12" />
        <ElDesc lineHash="39827869" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/memoryLeaks.c" desc="char buf[100];" ElType="." rngLn="13" />
        <ElDesc lineHash="-785260158" ln="14" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="14" srcRngEndLn="15" srcRngFile="/BugDetective/memoryLeaks.c" desc="int id = 0;" ElType="." rngLn="14" />
        <ElDesc lineHash="66462730" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/memoryLeaks.c" desc="while(1) {" ElType="." rngLn="15">
          <Anns>
            <Ann msg="Loop condition evaluation: 1 (true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-526658767" ln="16" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="16" srcRngEndLn="17" srcRngFile="/BugDetective/memoryLeaks.c" desc="c = fgets(buf, 100, file);" ElType="." rngLn="16" />
        <ElDesc lineHash="301978179" ln="17" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="17" srcRngEndLn="18" srcRngFile="/BugDetective/memoryLeaks.c" desc="if (c!=NULL) {" ElType="." rngLn="17">
          <Anns>
            <Ann msg="Condition evaluation: (c != 0) (assuming true)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1212191400" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/memoryLeaks.c" desc="malloc(...)" ElType=".C" rngLn="18">
          <Props>
            <Prop key="Tracked variables" val="malloc(...)" />
          </Props>
          <Anns>
            <Ann msg="Point where memory is allocated" kind="cause" />
            <Ann msg="Allocated memory: malloc(...)" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1212191400" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/memoryLeaks.c" desc="Person* p = malloc(sizeof(Person));" ElType="!" rngLn="18" />
        <ElDesc lineHash="-812912267" ln="19" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="19" srcRngEndLn="20" srcRngFile="/BugDetective/memoryLeaks.c" desc="if (p == 0) exit(1);" ElType="." rngLn="19">
          <Props>
            <Prop key="Tracked variables" val="p" />
          </Props>
          <Anns>
            <Ann msg="Allocated memory: p" kind="var" />
            <Ann msg="Condition evaluation: (p == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1899725753" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/BugDetective/memoryLeaks.c" desc="p->personalId = ++id;" ElType="." rngLn="20" />
        <ElDesc lineHash="-217028449" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/memoryLeaks.c" desc="p->name = buf;" ElType="." rngLn="21" />
        <ElDesc lineHash="-2076993264" ln="22" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="22" srcRngEndLn="23" srcRngFile="/BugDetective/memoryLeaks.c" desc="storePerson(p);" ElType="." rngLn="22" />
        <ElDesc lineHash="2099466359" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/memoryLeaks.c" desc="} else {" ElType=".P" rngLn="26">
          <Props>
            <Prop key="Tracked variables" val="p" />
          </Props>
          <Anns>
            <Ann msg="Allocated memory: p" kind="var" />
            <Ann msg="Point where allocated memory is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Prototype of function 'simpleLeakInCycle' does not precede function definition" ln="32" locFile="/BugDetective/memoryLeaks.c" locStartln="32" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_8_4-a" lnHash="1704975937" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1704975937" unbViolId="4327fc43-33fd-3be2-847b-b27b54c79f35" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e7d8398a-3233-3d9e-bb06-5a4a19edb181" locEndPos="6" locType="sr" hash="1502549011" locEndLn="32" goals="0," />
    <StdViol msg="Function 'simpleLeakInCycle' is not in prototype form" ln="32" locFile="/BugDetective/memoryLeaks.c" locStartln="32" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_1_5-c" lnHash="1704975937" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1704975937" unbViolId="c95d78be-d0de-395e-8dda-ff45b37454ce" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f731626d-0a9a-37c2-8ce4-1c05ca08eb7e" locEndPos="6" locType="sr" hash="1502549011" locEndLn="32" goals="0," />
    <StdViol msg="Function 'simpleLeakInCycle' is not in prototype form" ln="32" locFile="/BugDetective/memoryLeaks.c" locStartln="32" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_8_2-c" lnHash="1704975937" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1704975937" unbViolId="790a5a12-7e37-3afa-8f85-d24b1f266dc8" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="28c0a8aa-aa46-3247-9561-9590437135c5" locEndPos="6" locType="sr" hash="1502549011" locEndLn="32" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="34" locFile="/BugDetective/memoryLeaks.c" locStartln="34" sev="4" auth="root" locRef="7" rule="MISRAC2012-DIR_4_6-b" lnHash="221640208" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="221640208" unbViolId="dbd894ae-e2d6-3118-9f94-3cf1dcd771a7" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1878a0f8-d483-3545-9705-7903f6108ab4" locEndPos="5" locType="sr" hash="1502549011" locEndLn="34" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="35" locFile="/BugDetective/memoryLeaks.c" locStartln="35" sev="4" auth="root" locRef="7" rule="MISRAC2012-DIR_4_6-b" lnHash="1125267983" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1125267983" unbViolId="2cab11d8-8bfb-3cea-b572-9285da50ac40" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d736f99d-f940-34ae-a510-781748ad5f0d" locEndPos="5" locType="sr" hash="1502549011" locEndLn="35" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="36" locFile="/BugDetective/memoryLeaks.c" locStartln="36" sev="4" auth="root" locRef="7" rule="MISRAC2012-DIR_4_6-b" lnHash="22113273" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="22113273" unbViolId="1b1148ae-cc73-377e-a19c-01c1fd571e94" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="503a4b69-80bc-3a42-8b27-fb79a889e2a5" locEndPos="5" locType="sr" hash="1502549011" locEndLn="36" goals="0," />
    <FlowViol msg="Memory not deallocated: pointer" ln="40" locFile="/BugDetective/memoryLeaks.c" ruleSAFMsg="Point where allocated memory is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="41" rule="MISRAC2012-RULE_22_1-a" FirstElSrcRngStartPos="0" lnHash="-334359523" ruleSCSCMsg="Point where memory is allocated" FirstElSrcRngFile="/BugDetective/memoryLeaks.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="40" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="525280961" lang="cpp" violId="9640f34c-5f7a-3951-a9ed-e94190622e32" locEndPos="0" locEndLn="41" goals="0," locStartln="40" sev="2" locRef="7" tool="c++test" lineHash="-334359523" unbViolId="5af519f0-fce3-335f-953e-1c734ed4f729" locType="sr" hash="1502549011" causeLocRef="7">
      <Props>
        <Prop key="Tracked variables" val="Allocated memory" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="221640208" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/memoryLeaks.c" desc="int count = 0;" ElType="." rngLn="34" />
        <ElDesc lineHash="1125267983" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/memoryLeaks.c" desc="int LOOPS = 100;" ElType="." rngLn="35" />
        <ElDesc lineHash="22113273" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/memoryLeaks.c" desc="int MAXSIZE = 100;" ElType="." rngLn="36" />
        <ElDesc lineHash="-1239722706" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/memoryLeaks.c" desc="char *pointer = NULL;" ElType="." rngLn="37" />
        <ElDesc lineHash="-1318212244" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/memoryLeaks.c" desc="for(count=0; count &lt; LOOPS; count++) {" ElType="." rngLn="39">
          <Anns>
            <Ann msg="Loop condition evaluation: (count &lt; LOOPS) (true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-334359523" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/memoryLeaks.c" desc="malloc(...)" ElType=".C" rngLn="40">
          <Props>
            <Prop key="Tracked variables" val="malloc(...)" />
          </Props>
          <Anns>
            <Ann msg="Point where memory is allocated" kind="cause" />
            <Ann msg="Allocated memory: malloc(...)" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-334359523" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/memoryLeaks.c" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" ElType="!" rngLn="40" />
        <ElDesc lineHash="-1318212244" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/memoryLeaks.c" desc="for(count=0; count &lt; LOOPS; count++) {" ElType="." rngLn="39">
          <Props>
            <Prop key="Tracked variables" val="pointer" />
          </Props>
          <Anns>
            <Ann msg="Allocated memory: pointer" kind="var" />
            <Ann msg="Loop condition evaluation: (count &lt; LOOPS) (assuming true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-334359523" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/memoryLeaks.c" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" ElType=".P" rngLn="40">
          <Props>
            <Prop key="Tracked variables" val="pointer" />
          </Props>
          <Anns>
            <Ann msg="Allocated memory: pointer" kind="var" />
            <Ann msg="Point where allocated memory is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Memory not deallocated: pointer" ln="40" locFile="/BugDetective/memoryLeaks.c" ruleSAFMsg="Point where allocated memory is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="41" rule="MISRAC2012-DIR_4_13-a" FirstElSrcRngStartPos="0" lnHash="-334359523" ruleSCSCMsg="Point where memory is allocated" FirstElSrcRngFile="/BugDetective/memoryLeaks.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="40" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="525280961" lang="cpp" violId="10c2c769-7708-3945-a4ad-cbd3f8bc6e88" locEndPos="0" locEndLn="41" goals="0," locStartln="40" sev="4" locRef="7" tool="c++test" lineHash="-334359523" unbViolId="f1dab215-b7d5-3ee5-a2c5-c42308fa420b" locType="sr" hash="1502549011" causeLocRef="7">
      <Props>
        <Prop key="Tracked variables" val="Allocated memory" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="221640208" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/memoryLeaks.c" desc="int count = 0;" ElType="." rngLn="34" />
        <ElDesc lineHash="1125267983" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/memoryLeaks.c" desc="int LOOPS = 100;" ElType="." rngLn="35" />
        <ElDesc lineHash="22113273" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/memoryLeaks.c" desc="int MAXSIZE = 100;" ElType="." rngLn="36" />
        <ElDesc lineHash="-1239722706" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/memoryLeaks.c" desc="char *pointer = NULL;" ElType="." rngLn="37" />
        <ElDesc lineHash="-1318212244" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/memoryLeaks.c" desc="for(count=0; count &lt; LOOPS; count++) {" ElType="." rngLn="39">
          <Anns>
            <Ann msg="Loop condition evaluation: (count &lt; LOOPS) (true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-334359523" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/memoryLeaks.c" desc="malloc(...)" ElType=".C" rngLn="40">
          <Props>
            <Prop key="Tracked variables" val="malloc(...)" />
          </Props>
          <Anns>
            <Ann msg="Point where memory is allocated" kind="cause" />
            <Ann msg="Allocated memory: malloc(...)" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-334359523" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/memoryLeaks.c" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" ElType="!" rngLn="40" />
        <ElDesc lineHash="-1318212244" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/memoryLeaks.c" desc="for(count=0; count &lt; LOOPS; count++) {" ElType="." rngLn="39">
          <Props>
            <Prop key="Tracked variables" val="pointer" />
          </Props>
          <Anns>
            <Ann msg="Allocated memory: pointer" kind="var" />
            <Ann msg="Loop condition evaluation: (count &lt; LOOPS) (assuming true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-334359523" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/memoryLeaks.c" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" ElType=".P" rngLn="40">
          <Props>
            <Prop key="Tracked variables" val="pointer" />
          </Props>
          <Anns>
            <Ann msg="Allocated memory: pointer" kind="var" />
            <Ann msg="Point where allocated memory is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Pointer to void type should not be converted to pointer to object type 'char *'" ln="40" locFile="/BugDetective/memoryLeaks.c" locStartln="40" sev="4" auth="root" locRef="7" rule="MISRAC2012-RULE_11_5-a" lnHash="-334359523" rule.header="A conversion should not be performed from pointer to void into pointer to object" tool="c++test" lineHash="-334359523" unbViolId="80ddfe60-35e8-3bb6-a26a-573affb47b2e" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d89fc323-441c-31d9-8e7d-263ccf7efca0" locEndPos="19" locType="sr" hash="1502549011" locEndLn="40" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="40" locFile="/BugDetective/memoryLeaks.c" locStartln="40" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_21_3-a" lnHash="-334359523" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-334359523" unbViolId="6bb381f6-4f2a-36fc-b34b-ef4f29e4877d" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4734e761-4ed5-3f44-b213-f25bbf4d9b37" locEndPos="27" locType="sr" hash="1502549011" locEndLn="40" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="40" locFile="/BugDetective/memoryLeaks.c" locStartln="40" sev="2" auth="root" locRef="7" rule="MISRAC2012-DIR_4_12-a" lnHash="-334359523" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-334359523" unbViolId="494c2ef1-2e98-3d5e-86a2-0778d704fa3c" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="640e05e1-d77f-3cd8-82e8-0d22a3615cf3" locEndPos="27" locType="sr" hash="1502549011" locEndLn="40" goals="0," />
    <StdViol msg="Operands of the '*' operator have different essential types: 'unsigned long' and 'int'" ln="40" locFile="/BugDetective/memoryLeaks.c" locStartln="40" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_10_4-a" lnHash="-334359523" rule.header="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" tool="c++test" lineHash="-334359523" unbViolId="a4163e6a-9f01-3e80-8be3-ebcb2e6761cb" locStartPos="33" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ab9a3561-acda-3a21-955f-2bbbbd054f32" locEndPos="34" locType="sr" hash="1502549011" locEndLn="40" goals="0," />
    <FlowViol msg="Value returned from method &quot;malloc&quot; should be checked" ln="44" locFile="/BugDetective/memoryLeaks.c" ruleSAFMsg="Point by which returned value should be checked" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="41" rule="MISRAC2012-DIR_4_7-b" FirstElSrcRngStartPos="0" lnHash="-1712628621" ruleSCSCMsg="Method call" FirstElSrcRngFile="/BugDetective/memoryLeaks.c" rule.header="Always check the returned value of non-void function" FirstElSrcRngStartln="40" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1381748893" lang="cpp" violId="84979ff9-a4a5-39cd-b1d2-33410420ce82" locEndPos="0" locEndLn="45" goals="0," locStartln="44" sev="2" locRef="7" tool="c++test" lineHash="-1712628621" unbViolId="e24a22f5-beb2-3e5f-9b9c-a991de486ec3" locType="sr" hash="1502549011" causeLocRef="7">
      <Props />
      <ElDescList>
        <ElDesc lineHash="221640208" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/memoryLeaks.c" desc="int count = 0;" ElType="." rngLn="34" />
        <ElDesc lineHash="1125267983" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/memoryLeaks.c" desc="int LOOPS = 100;" ElType="." rngLn="35" />
        <ElDesc lineHash="22113273" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/memoryLeaks.c" desc="int MAXSIZE = 100;" ElType="." rngLn="36" />
        <ElDesc lineHash="-1239722706" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/memoryLeaks.c" desc="char *pointer = NULL;" ElType="." rngLn="37" />
        <ElDesc lineHash="-1318212244" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/memoryLeaks.c" desc="for(count=0; count &lt; LOOPS; count++) {" ElType="." rngLn="39">
          <Anns>
            <Ann msg="Loop condition evaluation: (count &lt; LOOPS) (true)" kind="condEval" />
            <Ann msg="Entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-334359523" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/memoryLeaks.c" desc="malloc(...)" ElType=".C" rngLn="40">
          <Anns>
            <Ann msg="Method call" kind="cause" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-334359523" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/memoryLeaks.c" desc="pointer = (char *)malloc(sizeof(char) * MAXSIZE);" ElType="." rngLn="40" />
        <ElDesc lineHash="-1318212244" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/memoryLeaks.c" desc="for(count=0; count &lt; LOOPS; count++) {" ElType="." rngLn="39">
          <Anns>
            <Ann msg="Loop condition evaluation: (count &lt; LOOPS) (assuming false)" kind="condEval" />
            <Ann msg="Not entering the loop" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1712628621" ln="44" srcRngStartPos="0" srcRngEndPos="0" locRef="7" locType="sr" srcRnghash="1502549011" srcRngStartln="44" srcRngEndLn="45" srcRngFile="/BugDetective/memoryLeaks.c" desc="free(pointer);" ElType=".P" rngLn="44">
          <Anns>
            <Ann msg="Point by which returned value should be checked" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="'free' function should not be used" ln="44" locFile="/BugDetective/memoryLeaks.c" locStartln="44" sev="2" auth="root" locRef="7" rule="MISRAC2012-RULE_21_3-a" lnHash="-1712628621" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-1712628621" unbViolId="0a306819-3c9d-3b39-aa90-3815745a7bec" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="05878ca7-0150-39b6-a694-65dc421a915e" locEndPos="5" locType="sr" hash="1502549011" locEndLn="44" goals="0," />
    <StdViol msg="'free' function should not be used" ln="44" locFile="/BugDetective/memoryLeaks.c" locStartln="44" sev="2" auth="root" locRef="7" rule="MISRAC2012-DIR_4_12-a" lnHash="-1712628621" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="-1712628621" unbViolId="2ce00a0c-b334-3383-a528-a7ad28438813" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0ac62af8-054c-3a1a-99b5-5301ae47af0e" locEndPos="5" locType="sr" hash="1502549011" locEndLn="44" goals="0," />
    <StdViol msg="Prototype of function 'storePersonToFile' does not precede function definition" ln="10" locFile="/BugDetective/nullPointerDeref.c" locStartln="10" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_8_4-a" lnHash="801076108" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="801076108" unbViolId="8ee3545e-2153-3c1b-8976-2656f153e761" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="84f8a0eb-605f-3588-af25-483f383c85b7" locEndPos="6" locType="sr" hash="522847191" locEndLn="10" goals="0," />
    <StdViol msg="The function 'storePersonToFile' is referenced only in the translation unit where it is defined" ln="10" locFile="/BugDetective/nullPointerDeref.c" locStartln="10" sev="4" auth="root" locRef="8" rule="MISRAC2012-RULE_8_7-a" lnHash="801076108" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="801076108" unbViolId="f7629374-661c-3efb-ae32-cbe97bc64e2a" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="6c80db34-9ef8-3d9a-bda5-729ac5f6d85a" locEndPos="6" locType="sr" hash="522847191" locEndLn="10" goals="0," />
    <StdViol msg="The names of the identifiers 'person' and 'Person' (line: 7 in the 'dbutil.h' file) differ only in capitalization" ln="10" locFile="/BugDetective/nullPointerDeref.c" locStartln="10" sev="4" auth="root" locRef="8" rule="MISRAC2012-DIR_4_5-a" lnHash="801076108" rule.header="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" tool="c++test" lineHash="801076108" unbViolId="d127f5e6-769c-3c1d-b9ef-5a3b66e703b9" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7e2d02f-4f7d-36ac-9a31-ed29681312cb" locEndPos="32" locType="sr" hash="522847191" locEndLn="10" goals="0," />
    <StdViol msg="Pass parameter &quot;person&quot; with const specifier" ln="10" locFile="/BugDetective/nullPointerDeref.c" locStartln="10" sev="4" auth="root" locRef="8" rule="MISRAC2012-RULE_8_13-a" lnHash="801076108" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="801076108" unbViolId="8eed0a79-f616-34a5-9819-b5b6970fcdb8" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="efdb65c5-d6da-306c-8b5d-ad5df3dabf2d" locEndPos="32" locType="sr" hash="522847191" locEndLn="10" goals="0," />
    <FlowViol msg="&quot;person&quot; may possibly be null" ln="13" locFile="/BugDetective/nullPointerDeref.c" ruleSAFMsg="Null pointer dereferencing point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="11" rule="MISRAC2012-DIR_4_1-b" FirstElSrcRngStartPos="0" lnHash="650531314" ruleSCSCMsg="Source of null value" FirstElSrcRngFile="/BugDetective/dbutil.c" rule.header="Avoid null pointer dereferencing" FirstElSrcRngStartln="10" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-289034743" lang="cpp" violId="2d137259-8f2a-399b-92e2-b44636ce5466" locEndPos="0" locEndLn="14" goals="0," locStartln="13" sev="2" locRef="8" tool="c++test" lineHash="650531314" unbViolId="e46702aa-c2e1-3d97-a8f7-9069bf631064" locType="sr" hash="522847191" causeLocRef="3">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1374140990" ln="22" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="22" srcRngEndLn="23" srcRngFile="/BugDetective/nullPointerDeref.c" desc="Person* p = retrievePersonFromDB(id);" ElType="!" rngLn="22">
          <ElDescList>
            <ElDesc lineHash="1041656438" ln="7" srcRngStartPos="0" srcRngEndPos="0" locRef="3" locType="sr" srcRnghash="-892903586" srcRngStartln="7" srcRngEndLn="8" srcRngFile="/BugDetective/dbutil.c" desc="Person* p;" ElType="." rngLn="7" />
            <ElDesc lineHash="932373780" ln="8" srcRngStartPos="0" srcRngEndPos="0" locRef="3" locType="sr" srcRnghash="-892903586" srcRngStartln="8" srcRngEndLn="9" srcRngFile="/BugDetective/dbutil.c" desc="int MIN_ID = 1;" ElType="." rngLn="8" />
            <ElDesc lineHash="1035623864" ln="9" srcRngStartPos="0" srcRngEndPos="0" locRef="3" locType="sr" srcRnghash="-892903586" srcRngStartln="9" srcRngEndLn="10" srcRngFile="/BugDetective/dbutil.c" desc="if (id &lt; MIN_ID) {" ElType="." rngLn="9">
              <Anns>
                <Ann msg="Condition evaluation: (id &lt; MIN_ID) (assuming true)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="-1561874268" ln="10" srcRngStartPos="0" srcRngEndPos="0" locRef="3" locType="sr" srcRnghash="-892903586" srcRngStartln="10" srcRngEndLn="11" srcRngFile="/BugDetective/dbutil.c" desc="return NULL;" ElType=".C" rngLn="10">
              <Anns>
                <Ann msg="Source of null value" kind="cause" />
                <Ann msg="Null value carrier: &lt;returned value of retrievePersonFromDB()>" kind="comment" />
              </Anns>
            </ElDesc>
          </ElDescList>
          <Anns>
            <Ann msg="Null value carrier: &lt;returned value of retrievePersonFromDB()> -> p" kind="comment" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1906410249" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/BugDetective/nullPointerDeref.c" desc="storePersonToFile(p, file);" ElType="!" rngLn="23">
          <ElDescList>
            <ElDesc lineHash="801076108" ln="10" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="10" srcRngEndLn="11" srcRngFile="/BugDetective/nullPointerDeref.c" desc="void storePersonToFile(Person *person, FILE* file)" ElType="!" rngLn="10">
              <Anns>
                <Ann msg="Null value carrier: p -> person" kind="comment" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="1027984352" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/nullPointerDeref.c" desc="if (file!=NULL) {" ElType="." rngLn="12">
              <Anns>
                <Ann msg="Condition evaluation: (file != 0) (assuming true)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="650531314" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/nullPointerDeref.c" desc="fprintf(file, &quot;Id: %d Name: %s References:%s\n&quot;," ElType=".P" rngLn="13">
              <Anns>
                <Ann msg="Null value carrier: person" kind="comment" />
                <Ann msg="Null pointer dereferencing point" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
          <Anns>
            <Ann msg="Null value carrier: p" kind="comment" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'fprintf' function is not allowed" ln="13" locFile="/BugDetective/nullPointerDeref.c" locStartln="13" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_21_6-a" lnHash="650531314" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="650531314" unbViolId="35e8444a-22cc-39b3-bf75-9d3d477ec048" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ee68297b-72d5-3f21-949b-d30916f1e4d6" locEndPos="9" locType="sr" hash="522847191" locEndLn="13" goals="0," />
    <StdViol msg="Unused function's &quot;fprintf&quot; return value" ln="13" locFile="/BugDetective/nullPointerDeref.c" locStartln="13" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_17_7-a" lnHash="650531314" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="650531314" unbViolId="959739bc-18f1-3a51-90cc-21fb9ab8f0ae" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4f563fe5-d278-3bc5-acb7-9774517c9360" locEndPos="9" locType="sr" hash="522847191" locEndLn="13" goals="0," />
    <FlowViol msg="&quot;file&quot; may possibly be null" ln="17" locFile="/BugDetective/nullPointerDeref.c" ruleSAFMsg="Null pointer dereferencing point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="13" rule="MISRAC2012-DIR_4_1-b" FirstElSrcRngStartPos="0" lnHash="191846468" ruleSCSCMsg="Source of null value" FirstElSrcRngFile="/BugDetective/nullPointerDeref.c" rule.header="Avoid null pointer dereferencing" FirstElSrcRngStartln="12" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1368694412" lang="cpp" violId="46768a50-64f5-3468-a810-660d394b79ea" locEndPos="0" locEndLn="18" goals="0," locStartln="17" sev="2" locRef="8" tool="c++test" lineHash="191846468" unbViolId="7bb863fd-3c51-3682-9461-719854debcdf" locType="sr" hash="522847191" causeLocRef="8">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1027984352" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/BugDetective/nullPointerDeref.c" desc="if (file!=NULL) {" ElType=".C" rngLn="12">
          <Anns>
            <Ann msg="Source of null value" kind="cause" />
            <Ann msg="Null value carrier: file" kind="comment" />
            <Ann msg="Condition evaluation: (file != 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="191846468" ln="17" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="17" srcRngEndLn="18" srcRngFile="/BugDetective/nullPointerDeref.c" desc="fclose(file);" ElType=".P" rngLn="17">
          <Anns>
            <Ann msg="Null value carrier: file" kind="comment" />
            <Ann msg="Null pointer dereferencing point" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'fclose' function is not allowed" ln="17" locFile="/BugDetective/nullPointerDeref.c" locStartln="17" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_21_6-a" lnHash="191846468" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="191846468" unbViolId="a9c6404f-5b5a-3a58-b75c-061e7860ab77" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="05967b21-6c5e-362e-978a-04b4b4a6aab0" locEndPos="5" locType="sr" hash="522847191" locEndLn="17" goals="0," />
    <StdViol msg="Unused function's &quot;fclose&quot; return value" ln="17" locFile="/BugDetective/nullPointerDeref.c" locStartln="17" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_17_7-a" lnHash="191846468" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="191846468" unbViolId="efdab573-1068-3dc2-a624-1bce83b7a934" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="263ff17a-279e-3444-b7de-1a8aabf8ebc2" locEndPos="5" locType="sr" hash="522847191" locEndLn="17" goals="0," />
    <StdViol msg="Prototype of function 'copyPersonToFile' does not precede function definition" ln="20" locFile="/BugDetective/nullPointerDeref.c" locStartln="20" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_8_4-a" lnHash="331968032" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="331968032" unbViolId="ce9ce40e-c14c-36b1-b3c2-5386b20bb6fd" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b75ac078-bfca-3783-9244-a3b49378eefc" locEndPos="6" locType="sr" hash="522847191" locEndLn="20" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="20" locFile="/BugDetective/nullPointerDeref.c" locStartln="20" sev="4" auth="root" locRef="8" rule="MISRAC2012-DIR_4_6-b" lnHash="331968032" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="331968032" unbViolId="7b58b092-63ae-3e44-9f4c-797da8d475a2" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8369e5d7-3461-3089-a790-700c8a370e1a" locEndPos="23" locType="sr" hash="522847191" locEndLn="20" goals="0," />
    <StdViol msg="'free' function should not be used" ln="24" locFile="/BugDetective/nullPointerDeref.c" locStartln="24" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_21_3-a" lnHash="1220665574" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1220665574" unbViolId="6abb674d-600f-3b65-a879-34e81ba8de74" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="571af314-e0ad-3706-a681-50d74a5050d5" locEndPos="5" locType="sr" hash="522847191" locEndLn="24" goals="0," />
    <StdViol msg="'free' function should not be used" ln="24" locFile="/BugDetective/nullPointerDeref.c" locStartln="24" sev="2" auth="root" locRef="8" rule="MISRAC2012-DIR_4_12-a" lnHash="1220665574" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1220665574" unbViolId="828cbb86-8624-3c9d-91e6-c535222c7d1b" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6b094770-4d1d-304f-803b-d2f749ba0c37" locEndPos="5" locType="sr" hash="522847191" locEndLn="24" goals="0," />
    <StdViol msg="Prototype of function 'createPerson' does not precede function definition" ln="27" locFile="/BugDetective/nullPointerDeref.c" locStartln="27" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_8_4-a" lnHash="1311475257" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1311475257" unbViolId="7e5c0002-9612-382b-8bc0-6270017f7d8b" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5707f841-b8ad-3549-b476-4e9fe9558b3e" locEndPos="9" locType="sr" hash="522847191" locEndLn="27" goals="0," />
    <StdViol msg="The function 'createPerson' is referenced only in the translation unit where it is defined" ln="27" locFile="/BugDetective/nullPointerDeref.c" locStartln="27" sev="4" auth="root" locRef="8" rule="MISRAC2012-RULE_8_7-a" lnHash="1311475257" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="1311475257" unbViolId="679b9fe3-42f2-3643-843e-1fd772f865a6" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="1c3bb1f4-84ba-37b5-8017-afb84f3bb43e" locEndPos="9" locType="sr" hash="522847191" locEndLn="27" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="27" locFile="/BugDetective/nullPointerDeref.c" locStartln="27" sev="4" auth="root" locRef="8" rule="MISRAC2012-DIR_4_6-b" lnHash="1311475257" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1311475257" unbViolId="d0d3c50c-23fc-3b73-b0c9-5e6b3ae128f8" locStartPos="21" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="81048832-62cd-3129-a91e-ba62a4294284" locEndPos="22" locType="sr" hash="522847191" locEndLn="27" goals="0," />
    <StdViol msg="Pointer to void type should not be converted to pointer to object type 'Person *'" ln="29" locFile="/BugDetective/nullPointerDeref.c" locStartln="29" sev="4" auth="root" locRef="8" rule="MISRAC2012-RULE_11_5-a" lnHash="457932120" rule.header="A conversion should not be performed from pointer to void into pointer to object" tool="c++test" lineHash="457932120" unbViolId="ed02e183-3f48-33d7-9fa4-2cffd3801d09" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="43b2b57b-a827-3d43-8ae4-262ac19cf6dd" locEndPos="13" locType="sr" hash="522847191" locEndLn="29" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="29" locFile="/BugDetective/nullPointerDeref.c" locStartln="29" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_21_3-a" lnHash="457932120" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="457932120" unbViolId="6ccab3a5-0d5b-3b3f-9a0d-35eda707d4a0" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c5e721b2-e8fe-3c9f-aeb7-e20596f9c1ff" locEndPos="17" locType="sr" hash="522847191" locEndLn="29" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="29" locFile="/BugDetective/nullPointerDeref.c" locStartln="29" sev="2" auth="root" locRef="8" rule="MISRAC2012-DIR_4_12-a" lnHash="457932120" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="457932120" unbViolId="6ddaa15b-da9b-3a46-a7ed-365048fccfca" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b52e6b99-c210-3722-9c56-e927cb4aea03" locEndPos="17" locType="sr" hash="522847191" locEndLn="29" goals="0," />
    <FlowViol msg="&quot;p&quot; may possibly be null" ln="30" locFile="/BugDetective/nullPointerDeref.c" ruleSAFMsg="Null pointer dereferencing point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="30" rule="MISRAC2012-DIR_4_1-b" FirstElSrcRngStartPos="0" lnHash="1708187001" ruleSCSCMsg="Source of null value" FirstElSrcRngFile="/BugDetective/nullPointerDeref.c" rule.header="Avoid null pointer dereferencing" FirstElSrcRngStartln="29" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="541566912" lang="cpp" violId="ab6d7f6e-4ae2-3751-a9d9-55e1c354301d" locEndPos="0" locEndLn="31" goals="0," locStartln="30" sev="2" locRef="8" tool="c++test" lineHash="1708187001" unbViolId="f7a20f84-e830-33ba-831e-ef50cef2be09" locType="sr" hash="522847191" causeLocRef="8">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="457932120" ln="29" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="29" srcRngEndLn="30" srcRngFile="/BugDetective/nullPointerDeref.c" desc="Person* p = malloc(sizeof(Person));" ElType=".C" rngLn="29">
          <Anns>
            <Ann msg="Source of null value" kind="cause" />
            <Ann msg="Null value carrier: malloc(...)" kind="comment" />
            <Ann msg="Null value carrier: malloc(...) -> p" kind="comment" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1708187001" ln="30" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="30" srcRngEndLn="31" srcRngFile="/BugDetective/nullPointerDeref.c" desc="p->name = name;" ElType=".P" rngLn="30">
          <Anns>
            <Ann msg="Null value carrier: p" kind="comment" />
            <Ann msg="Null pointer dereferencing point" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Prototype of function 'init' does not precede function definition" ln="36" locFile="/BugDetective/nullPointerDeref.c" locStartln="36" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_8_4-a" lnHash="1199394333" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1199394333" unbViolId="0eae00e4-a618-35bf-bfa3-ce13a59b37e9" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ddd4f99d-0b90-3641-83f1-43c6e039dbac" locEndPos="6" locType="sr" hash="522847191" locEndLn="36" goals="0," />
    <StdViol msg="Function 'init' is not in prototype form" ln="36" locFile="/BugDetective/nullPointerDeref.c" locStartln="36" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_1_5-c" lnHash="1199394333" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1199394333" unbViolId="78556c5a-1411-3135-9b59-1aec1305b891" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="440e44ad-c72d-38a2-99c7-8c8eae2825d0" locEndPos="6" locType="sr" hash="522847191" locEndLn="36" goals="0," />
    <StdViol msg="Function 'init' is not in prototype form" ln="36" locFile="/BugDetective/nullPointerDeref.c" locStartln="36" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_8_2-c" lnHash="1199394333" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="1199394333" unbViolId="b8b83632-7e16-3e15-9336-73ef9c27580e" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="700ba54e-cef1-3ccc-8310-a19a3db47c56" locEndPos="6" locType="sr" hash="522847191" locEndLn="36" goals="0," />
    <StdViol msg="String literal &quot;Alice&quot; is passed to function 'createPerson' as pointer to non-const object" ln="39" locFile="/BugDetective/nullPointerDeref.c" locStartln="39" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_7_4-a" lnHash="961893567" rule.header="A string literal shall not be modified" tool="c++test" lineHash="961893567" unbViolId="379fc0d5-3f1c-3140-b318-2e6a2da60b02" locStartPos="32" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a4994c94-c58c-3ada-803d-184ff1678f58" locEndPos="33" locType="sr" hash="522847191" locEndLn="39" goals="0," />
    <FlowViol msg="Value of &quot;c&quot; is never used" ln="40" locFile="/BugDetective/nullPointerDeref.c" ruleSAFMsg="Point where value is declared" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="41" rule="MISRAC2012-RULE_2_2-b" FirstElSrcRngStartPos="0" lnHash="1175606183" ruleSCSCMsg="Point where value is declared" FirstElSrcRngFile="/BugDetective/nullPointerDeref.c" rule.header="Avoid unused values" FirstElSrcRngStartln="40" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-2055826223" lang="cpp" violId="5e62d322-975c-37b7-97d7-cea1357f1c06" locEndPos="0" locEndLn="41" goals="0," locStartln="40" sev="2" locRef="8" tool="c++test" lineHash="1175606183" unbViolId="f0bdb725-ce31-3738-9333-0f1b90fccb36" locType="sr" hash="522847191" causeLocRef="8">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1175606183" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/nullPointerDeref.c" desc="c = *p->reference;" ElType="CP" rngLn="40">
          <Anns>
            <Ann msg="Point where value is declared" kind="cause" />
            <Ann msg="Point where value is declared" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;p->reference&quot; may possibly be null" ln="40" locFile="/BugDetective/nullPointerDeref.c" ruleSAFMsg="Null pointer dereferencing point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="40" rule="MISRAC2012-DIR_4_1-b" FirstElSrcRngStartPos="0" lnHash="1175606183" ruleSCSCMsg="Source of null value" FirstElSrcRngFile="/BugDetective/nullPointerDeref.c" rule.header="Avoid null pointer dereferencing" FirstElSrcRngStartln="39" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1881455769" lang="cpp" violId="c4a50213-effe-33ad-9e39-ae781c76324b" locEndPos="0" locEndLn="41" goals="0," locStartln="40" sev="2" locRef="8" tool="c++test" lineHash="1175606183" unbViolId="212f8d8a-9ced-35cc-a13f-a3860246e83e" locType="sr" hash="522847191" causeLocRef="8">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-695983806" ln="38" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="38" srcRngEndLn="39" srcRngFile="/BugDetective/nullPointerDeref.c" desc="char c;" ElType="." rngLn="38" />
        <ElDesc lineHash="961893567" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/nullPointerDeref.c" desc="Person* p = createPerson(7, &quot;Alice&quot;, NULL);" ElType=".C" rngLn="39">
          <ElDescList>
            <ElDesc lineHash="1311475257" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/nullPointerDeref.c" desc="Person* createPerson(int id, char* name, char* ref)" ElType="!" rngLn="27">
              <Anns>
                <Ann msg="Null value carrier: &lt;parameter #3 of createPerson()> -> ref" kind="comment" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="457932120" ln="29" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="29" srcRngEndLn="30" srcRngFile="/BugDetective/nullPointerDeref.c" desc="Person* p = malloc(sizeof(Person));" ElType="." rngLn="29" />
            <ElDesc lineHash="1708187001" ln="30" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="30" srcRngEndLn="31" srcRngFile="/BugDetective/nullPointerDeref.c" desc="p->name = name;" ElType="." rngLn="30" />
            <ElDesc lineHash="2093147993" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/BugDetective/nullPointerDeref.c" desc="p->personalId = id;" ElType="." rngLn="31" />
            <ElDesc lineHash="708220577" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/nullPointerDeref.c" desc="p->reference = ref;" ElType="!" rngLn="32">
              <Anns>
                <Ann msg="Null value carrier: ref -> p->reference" kind="comment" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="-1256394053" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/nullPointerDeref.c" desc="return p;" ElType="." rngLn="33">
              <Anns>
                <Ann msg="Null value carrier: &lt;returned value of createPerson()>->reference, p->reference" kind="comment" />
              </Anns>
            </ElDesc>
          </ElDescList>
          <Anns>
            <Ann msg="Source of null value" kind="cause" />
            <Ann msg="Null value carrier: &lt;parameter #3 of createPerson()>" kind="comment" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1175606183" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="8" locType="sr" srcRnghash="522847191" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/nullPointerDeref.c" desc="c = *p->reference;" ElType=".P" rngLn="40">
          <Anns>
            <Ann msg="Null value carrier: p->reference" kind="comment" />
            <Ann msg="Null pointer dereferencing point" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="'free' function should not be used" ln="41" locFile="/BugDetective/nullPointerDeref.c" locStartln="41" sev="2" auth="root" locRef="8" rule="MISRAC2012-RULE_21_3-a" lnHash="1220665574" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1220665574" unbViolId="2cc021f5-3401-3d6d-84dc-5f762c590adc" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="16fd5a1d-f5be-353b-a21a-406aa3a61d6b" locEndPos="5" locType="sr" hash="522847191" locEndLn="41" goals="0," />
    <StdViol msg="'free' function should not be used" ln="41" locFile="/BugDetective/nullPointerDeref.c" locStartln="41" sev="2" auth="root" locRef="8" rule="MISRAC2012-DIR_4_12-a" lnHash="1220665574" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1220665574" unbViolId="fab07a9a-7252-32a0-876f-cab1646d21fc" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2d7e4a60-1489-338b-85b2-a4dfc1568c28" locEndPos="5" locType="sr" hash="522847191" locEndLn="41" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="3" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="3" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="33709887" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="33709887" unbViolId="405add75-4649-36e5-a2e5-154d4464ab83" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="710f1349-551f-3f07-8ebf-66fe1242e078" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="3" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="4" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="4" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="-448347338" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-448347338" unbViolId="a86427fe-bb55-323b-bb50-c3524e8bf254" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5b7566f8-35f4-3e78-83e6-598cfe34abd5" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="4" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="6" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="6" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="486072932" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="486072932" unbViolId="296d4a1c-eb33-3db4-9364-b305e13da0fb" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="05d2dd45-db1e-3534-902f-e92dd1922598" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="6" goals="0," />
    <StdViol msg="Test of a value against zero should be made explicit" ln="7" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="7" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_14_4-a" lnHash="1669491884" rule.header="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" tool="c++test" lineHash="1669491884" unbViolId="ae271d56-23d1-3b5e-8b46-87ec7e254682" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6ecf1ab2-bc49-39ac-95d7-1dfacdd4a4d3" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="7" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'helper1' should be followed by a block" ln="7" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="7" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="1669491884" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="1669491884" unbViolId="8b7c6d58-7138-3fe4-a56b-bd558f1fe9ab" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="58113ea7-5ab3-38d5-b11c-2a5b83b57326" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="7" goals="0," />
    <StdViol msg="Provide only one exit point in 'helper1' function" ln="8" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="8" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="1941627643" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="1941627643" unbViolId="645d33c3-67f1-37e2-9c75-316cc65a5253" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a3b246b8-fbd3-3656-bd7d-bdd69e23f80e" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="8" goals="0," />
    <FlowViol msg="&quot;x&quot; may possibly be null" ln="9" locFile="/BugDetective/nullPointerDerefBenchmark.c" ruleSAFMsg="Null pointer dereferencing point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="70" rule="MISRAC2012-DIR_4_1-b" FirstElSrcRngStartPos="0" lnHash="-293575299" ruleSCSCMsg="Source of null value" FirstElSrcRngFile="/BugDetective/nullPointerDerefBenchmark.c" rule.header="Avoid null pointer dereferencing" FirstElSrcRngStartln="69" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="203144837" lang="cpp" violId="32a3f071-4e7b-3b61-bcca-f36d853b99fe" locEndPos="0" locEndLn="10" goals="0," locStartln="9" sev="2" locRef="9" tool="c++test" lineHash="-293575299" unbViolId="c4558e11-05b8-3720-9646-c81f09de061f" locType="sr" hash="-1583021683" causeLocRef="9">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="2035137398" ln="69" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="69" srcRngEndLn="70" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="x = 0;" ElType=".C" rngLn="69">
          <Anns>
            <Ann msg="Source of null value" kind="cause" />
            <Ann msg="Null value carrier: x" kind="comment" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1669491884" ln="70" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="70" srcRngEndLn="71" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="if (b)" ElType="." rngLn="70">
          <Anns>
            <Ann msg="Condition evaluation: (b != 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="963008959" ln="72" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="72" srcRngEndLn="73" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="helper1(...)" ElType="!" rngLn="72">
          <ElDescList>
            <ElDesc lineHash="1669491884" ln="7" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="7" srcRngEndLn="8" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="if (b)" ElType="." rngLn="7">
              <Anns>
                <Ann msg="Condition evaluation: (b != 0) (false)" kind="condEval" />
              </Anns>
            </ElDesc>
            <ElDesc lineHash="-293575299" ln="9" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="9" srcRngEndLn="10" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="return *x;" ElType=".P" rngLn="9">
              <Anns>
                <Ann msg="Null value carrier: x" kind="comment" />
                <Ann msg="Null pointer dereferencing point" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Provide only one exit point in 'helper1' function" ln="9" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="9" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="-293575299" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-293575299" unbViolId="b1e85f76-88eb-3b39-8ad6-e24ef4121881" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="77ccfd51-0f5e-304f-90fa-1cac3832acc2" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="9" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="12" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="12" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="-1879067395" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1879067395" unbViolId="103ddfbf-2f3e-34e8-b4d9-2ca56b6b0571" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="14c1a261-70f6-3691-8d3f-4176f3e3a655" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="12" goals="0," />
    <StdViol msg="Function 'helper2' is not in prototype form" ln="12" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="12" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_1_5-c" lnHash="-1879067395" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="-1879067395" unbViolId="18e60b82-e34c-32a8-981f-d3555027b933" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d1131ee8-7f0c-388f-b98a-2801199d2866" locEndPos="12" locType="sr" hash="-1583021683" locEndLn="12" goals="0," />
    <StdViol msg="Function 'helper2' is not in prototype form" ln="12" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="12" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_8_2-c" lnHash="-1879067395" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="-1879067395" unbViolId="cdd38e38-c82e-3548-b1db-4c31d28a9d7b" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f8c31751-be86-3762-804e-398f9f51dbbe" locEndPos="12" locType="sr" hash="-1583021683" locEndLn="12" goals="0," />
    <FlowViol msg="&quot;x&quot; may possibly be null" ln="13" locFile="/BugDetective/nullPointerDerefBenchmark.c" ruleSAFMsg="Null pointer dereferencing point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="77" rule="MISRAC2012-DIR_4_1-b" FirstElSrcRngStartPos="0" lnHash="-293575299" ruleSCSCMsg="Source of null value" FirstElSrcRngFile="/BugDetective/nullPointerDerefBenchmark.c" rule.header="Avoid null pointer dereferencing" FirstElSrcRngStartln="76" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-577794662" lang="cpp" violId="185f1367-415b-306b-913a-54238fefdf69" locEndPos="0" locEndLn="14" goals="0," locStartln="13" sev="2" locRef="9" tool="c++test" lineHash="-293575299" unbViolId="e7b3580d-3632-3e09-8a7b-f473f0a1e966" locType="sr" hash="-1583021683" causeLocRef="9">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="2035137398" ln="76" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="76" srcRngEndLn="77" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="x = 0;" ElType=".C" rngLn="76">
          <Anns>
            <Ann msg="Source of null value" kind="cause" />
            <Ann msg="Null value carrier: x" kind="comment" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="862376838" ln="77" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="77" srcRngEndLn="78" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="helper2()" ElType="!" rngLn="77">
          <ElDescList>
            <ElDesc lineHash="-293575299" ln="13" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="13" srcRngEndLn="14" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="return *x;" ElType=".P" rngLn="13">
              <Anns>
                <Ann msg="Null value carrier: x" kind="comment" />
                <Ann msg="Null pointer dereferencing point" kind="point" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="16" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="16" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="-1092426674" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1092426674" unbViolId="3ee7ba67-2f3f-3774-ad31-8c9211561806" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="43eb40fe-26ad-3528-a4d3-2cdd0ab8af31" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="16" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="16" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="16" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="-1092426674" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1092426674" unbViolId="5f8cadcf-daa2-3bf7-9e50-b026f4813b8b" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a58e667f-e4ad-312a-8d53-3964346280ad" locEndPos="30" locType="sr" hash="-1583021683" locEndLn="16" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="17" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="17" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="2035137398" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="499a2957-54aa-3fb1-8f99-a74ae84ade9c" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="262d5ebe-7067-3394-b648-f9d59358ef69" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="17" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="17" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="17" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="2035137398" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="1915fc16-810c-3143-8f55-05ea4964aefe" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="20163b7c-a9fa-3248-9442-26d281b3cfc0" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="17" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'noFalseViolation1' should be followed by a block" ln="18" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="18" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="67403740" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="67403740" unbViolId="22e8949a-1a58-3907-9b78-5f3ed280f48d" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="38ea6c58-160e-3c32-b68e-db1cb1728549" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="18" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'noFalseViolation1' should be followed by a block" ln="20" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="20" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="67403864" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="67403864" unbViolId="01a35bb8-8539-397d-abc8-66d47e1820e1" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="337b1005-1e84-30ad-8bcf-820a097c0d52" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="20" goals="0," />
    <StdViol msg="Provide only one exit point in 'noFalseViolation1' function" ln="21" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="21" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="60910973" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="60910973" unbViolId="1ea1c4f5-9ae5-38ce-a6df-807331b109ea" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5c04840a-4d0a-3c02-b6a4-369f668c1b3d" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="21" goals="0," />
    <StdViol msg="Provide only one exit point in 'noFalseViolation1' function" ln="22" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="22" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="-1256396037" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256396037" unbViolId="7c73cd39-f47e-35f7-b654-3ee5e0961a47" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="017a2907-b78f-3fe2-9982-0f22ad96bd0c" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="22" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="25" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="25" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="281611792" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="281611792" unbViolId="fb24bca1-780e-3ed3-9a4f-10cae168b5ec" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eebd84e8-f233-3481-a518-19367627aa50" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="25" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="26" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="26" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="2035137398" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="fd7f93fb-b5e1-371a-9460-4a5e5487ab62" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3232478a-7f80-3c1f-90e9-937de4ba234a" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="26" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="26" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="26" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="2035137398" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="e7ebeed3-bc3c-38b8-a7a0-236fa856a015" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a38dbda1-727a-3b8f-99c8-0fa853e255cd" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="26" goals="0," />
    <StdViol msg="Test of a value against zero should be made explicit" ln="27" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="27" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_14_4-a" lnHash="1669491884" rule.header="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" tool="c++test" lineHash="1669491884" unbViolId="01c0ef31-9d8d-3224-949b-a82ebd2ed336" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="08ab1163-c87b-3858-9da3-7079ad50b595" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="27" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'noFalseViolation2' should be followed by a block" ln="27" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="27" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="1669491884" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="1669491884" unbViolId="5e6f5be9-191b-387e-8bde-f7e9224d0dfa" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="85f0428a-9c6e-3419-8e33-39bff71fa6c3" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="27" goals="0," />
    <StdViol msg="Test of a value against zero should be made explicit" ln="29" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="29" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_14_4-a" lnHash="1669491884" rule.header="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" tool="c++test" lineHash="1669491884" unbViolId="8bf4b828-7776-394a-a75e-f92e60911ae5" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="016493f0-f011-3213-a406-e523642f08ce" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="29" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'noFalseViolation2' should be followed by a block" ln="29" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="29" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="1669491884" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="1669491884" unbViolId="6db4b762-c4f3-36b0-8ff8-e4f9af0aef76" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="572df44d-d4a4-3971-85da-148dd4c944e6" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="29" goals="0," />
    <StdViol msg="Provide only one exit point in 'noFalseViolation2' function" ln="30" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="30" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="60910973" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="60910973" unbViolId="4934ce19-6325-33ef-877d-67f5b427f5cd" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="77ca27dc-3205-32d3-a84a-1a5f3be8abae" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="30" goals="0," />
    <StdViol msg="Provide only one exit point in 'noFalseViolation2' function" ln="31" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="31" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="-1256396037" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256396037" unbViolId="0b68279f-6c5c-3bd4-95e2-fee26dd88d15" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3a472804-1bd6-3769-a884-33f99cc29b09" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="31" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="34" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="34" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="-1515339567" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1515339567" unbViolId="f016b8bd-991a-38cf-945f-c62afb42f20e" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c2696f93-3d81-3121-be69-6a6dbce86079" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="34" goals="0," />
    <StdViol msg="Parameter 'b' is not used in function 'noFalseViolation3'" ln="34" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="34" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_2_7-a" lnHash="-1515339567" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="-1515339567" unbViolId="3a95a281-53ea-3d50-af62-92f80e241b6e" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0e239465-2d27-3435-94ca-61d0c4280413" locEndPos="35" locType="sr" hash="-1583021683" locEndLn="34" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="35" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="35" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="-299073094" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-299073094" unbViolId="d4514aa5-9761-397f-8118-288091cfb8d6" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3f85c6f7-4297-39ec-9d94-c922b3c9e78b" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="35" goals="0," />
    <StdViol msg="Variable 'y' of pointer type is initialized with '0'" ln="35" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="35" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="-299073094" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-299073094" unbViolId="25e16b4e-65b1-3993-b74e-bef36cfe847e" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3d296839-0672-3704-8987-972049b538a6" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="35" goals="0," />
    <StdViol msg="Variable 'y' of pointer type is initialized with '0'" ln="35" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="35" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="-299073094" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-299073094" unbViolId="8e16dea0-fa6c-3894-b1a1-bcd55a2b6efd" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="268e58f2-d5b3-3ed7-9c31-6127c33dc001" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="35" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'noFalseViolation3' should be followed by a block" ln="36" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="36" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="1828542768" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="1828542768" unbViolId="fc4b0968-2932-342c-b411-f1534ebdd344" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="61bbcc6b-e2c8-3e36-aa76-c904f419460a" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="36" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="36" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="36" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="1828542768" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="1828542768" unbViolId="ad8cb521-ab91-3900-989d-7213379715b8" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="811d9054-6d64-3538-8950-3571789f4792" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="36" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="36" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="36" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="1828542768" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="1828542768" unbViolId="f15f6c7c-79df-37bc-9e55-e73f5a6b260f" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="882f333d-aec7-31d7-8487-8200a92f958d" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="36" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'noFalseViolation3' should be followed by a block" ln="38" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="38" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="-1578920847" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-1578920847" unbViolId="c80709a7-daa8-39eb-8d18-4b852214270c" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7437c4b4-5e00-315b-bbac-2e9854404fb9" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="38" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="38" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="38" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="-1578920847" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-1578920847" unbViolId="5b99a973-7daf-300d-95de-7dd574803243" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="499ae8ed-624a-33bd-9b2a-f6ab39e2bd70" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="38" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="38" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="38" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="-1578920847" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-1578920847" unbViolId="f2087263-35e5-3cc2-9b03-ff5441c47869" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8317752b-9ac6-3916-8b16-415cbe11f5c8" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="38" goals="0," />
    <StdViol msg="Provide only one exit point in 'noFalseViolation3' function" ln="39" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="39" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="-1025324299" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1025324299" unbViolId="7411b27e-b28a-317b-b46b-2b988589791c" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="83300be0-db1a-367a-9909-5848409e7571" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="39" goals="0," />
    <StdViol msg="Provide only one exit point in 'noFalseViolation3' function" ln="41" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="41" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="1941627643" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="1941627643" unbViolId="002a249a-252a-303e-bdfd-1e37b11f8253" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="973efd68-4547-3cc8-aff4-e27c2b79cd77" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="41" goals="0," />
    <StdViol msg="An 'else' statement in a function 'noFalseViolation3' shall be followed by a block " ln="41" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="41" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="1941627643" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="1941627643" unbViolId="6e8868c5-f0d8-30a6-9784-2397de3f7076" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d70ca98a-1ee8-3cd8-985e-2e1992bb07f1" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="41" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="44" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="808430744" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="808430744" unbViolId="7d38e292-e7c0-33ec-bd1c-d65e4e27ba91" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a4a90c0f-280e-3fcb-9d4c-b5e6dace0450" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="44" goals="0," />
    <StdViol msg="Parameter 'b' is not used in function 'trueViolation'" ln="44" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="44" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_2_7-a" lnHash="808430744" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="808430744" unbViolId="14268874-ab2d-3897-8188-5d8f0316fb7e" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="44a43b54-88d8-3b92-9b58-a54ec2a80f91" locEndPos="31" locType="sr" hash="-1583021683" locEndLn="44" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="45" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="45" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="-299073094" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-299073094" unbViolId="ad5e3723-8a8c-3b34-ab34-5e440949a8bc" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d1e36fab-b548-3285-8bc8-511078a8e942" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="45" goals="0," />
    <StdViol msg="Variable 'y' of pointer type is initialized with '0'" ln="45" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="45" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="-299073094" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-299073094" unbViolId="26be72a2-e546-3c9a-86ca-314d83d994a7" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dd873a9d-ac2f-353f-bf9e-deb05fabc87e" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="45" goals="0," />
    <StdViol msg="Variable 'y' of pointer type is initialized with '0'" ln="45" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="45" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="-299073094" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-299073094" unbViolId="4a58c02c-d33e-39a5-9adb-3a1fb6f9b7d4" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2551c2b2-f338-33c8-8ad3-170e857db275" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="45" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'trueViolation' should be followed by a block" ln="46" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="46" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="1828542768" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="1828542768" unbViolId="afa9ea1b-368d-3ec2-92c9-5be697279fd0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6dc865d5-3dc1-3c20-8bbe-f25469f28df9" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="46" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="46" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="46" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="1828542768" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="1828542768" unbViolId="a490f08c-d590-3152-b8fc-35a9eb18ad38" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8fee7740-cabe-3796-b16c-03051ca4ea19" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="46" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="46" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="46" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="1828542768" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="1828542768" unbViolId="c6f89189-fff3-35be-9820-2798e704b95b" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3e5ed849-2fe8-3e13-8104-2cb0ad3f0b0b" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="46" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'trueViolation' should be followed by a block" ln="48" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="48" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="-1578920847" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-1578920847" unbViolId="59d305e9-14af-3796-b382-c63407d2573e" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="36b937bb-bc5e-3717-b235-1c02b4476e59" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="48" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="48" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="48" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="-1578920847" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-1578920847" unbViolId="840ee8a0-3fc3-3f92-a317-31953d312160" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d9b39d1c-d6fc-3ee6-b84d-9fc0c24acdda" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="48" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="48" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="48" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="-1578920847" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-1578920847" unbViolId="15be58b9-8172-3a6c-ac02-4bab116f2ee8" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4bdb490b-8b7a-3a15-8f5b-d0c5126c6fc8" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="48" goals="0," />
    <StdViol msg="Provide only one exit point in 'trueViolation' function" ln="49" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="49" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="-1025324299" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1025324299" unbViolId="6776a9c0-012e-3dae-b694-d7707fd27a59" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1e51cf3c-bc69-383f-9dbe-c3122943980b" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="49" goals="0," />
    <FlowViol msg="&quot;x&quot; may possibly be null" ln="51" locFile="/BugDetective/nullPointerDerefBenchmark.c" ruleSAFMsg="Null pointer dereferencing point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="47" rule="MISRAC2012-DIR_4_1-b" FirstElSrcRngStartPos="0" lnHash="60910973" ruleSCSCMsg="Source of null value" FirstElSrcRngFile="/BugDetective/nullPointerDerefBenchmark.c" rule.header="Avoid null pointer dereferencing" FirstElSrcRngStartln="46" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1823566354" lang="cpp" violId="2f52d4f8-f41d-39fc-8121-9cbe2f2308d5" locEndPos="0" locEndLn="52" goals="0," locStartln="51" sev="2" locRef="9" tool="c++test" lineHash="60910973" unbViolId="7de0d92c-59e8-31ee-82a1-99334f825790" locType="sr" hash="-1583021683" causeLocRef="9">
      <Props>
        <Prop key="Tracked variables" val="Null value carrier" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-299073094" ln="45" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="45" srcRngEndLn="46" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="int* y = 0;" ElType="." rngLn="45" />
        <ElDesc lineHash="1828542768" ln="46" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="46" srcRngEndLn="47" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="if (x != 0)" ElType=".C" rngLn="46">
          <Anns>
            <Ann msg="Source of null value" kind="cause" />
            <Ann msg="Null value carrier: x" kind="comment" />
            <Ann msg="Condition evaluation: (x != 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1578920847" ln="48" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="48" srcRngEndLn="49" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="if (y != 0)" ElType="." rngLn="48">
          <Anns>
            <Ann msg="Condition evaluation: (y != 0) (false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="60910973" ln="51" srcRngStartPos="0" srcRngEndPos="0" locRef="9" locType="sr" srcRnghash="-1583021683" srcRngStartln="51" srcRngEndLn="52" srcRngFile="/BugDetective/nullPointerDerefBenchmark.c" desc="return *x;" ElType=".P" rngLn="51">
          <Anns>
            <Ann msg="Null value carrier: x" kind="comment" />
            <Ann msg="Null pointer dereferencing point" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Provide only one exit point in 'trueViolation' function" ln="51" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="51" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_15_5-a" lnHash="60910973" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="60910973" unbViolId="8c177b4e-6166-38b8-996b-59ed8dc85164" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="70197ab6-2411-37b3-8082-24002e3f561c" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="51" goals="0," />
    <StdViol msg="An 'else' statement in a function 'trueViolation' shall be followed by a block " ln="51" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="51" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="60910973" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="60910973" unbViolId="50f85474-c161-34f1-b02d-4a182367f2a7" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="82b65f90-a596-3198-83b5-a428444dabdf" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="51" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="54" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="54" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="1351025868" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1351025868" unbViolId="3d06bf21-188f-33c2-afc6-7bf0537ee4ff" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d0cd9da5-32d6-3d25-9c62-1a8f4f6c4b95" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="54" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="55" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="55" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="2035137398" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="294c5c69-7aaa-3e87-8cee-62410893fa02" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4a652989-030a-3077-9508-ce0b815d2d7f" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="55" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="55" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="55" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="2035137398" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="37a167ee-ef74-3675-9ed2-6b1f4e5e64f2" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bf985e7d-79fc-3c1d-8c47-f1bec26188e6" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="55" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'functionCall_noFalseViolation1' should be followed by a block" ln="56" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="56" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="214580195" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="214580195" unbViolId="b3fe0619-28c6-3ff2-8414-bec2b75cdf91" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="442926a5-e77f-3079-ac3f-652d9fa07ed0" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="56" goals="0," />
    <StdViol msg="The operand of the logical negation operator '!' should have essentially Boolean type" ln="56" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="56" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_10_1-a" lnHash="214580195" rule.header="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" tool="c++test" lineHash="214580195" unbViolId="25156927-3c93-3844-b376-d779eba0c8c6" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fc399bdb-4a64-376b-9f16-20b3df2be854" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="56" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="62" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="62" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="1083234322" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1083234322" unbViolId="4f31cad2-84b1-3d21-a044-3ba99bee24f2" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e52bb2a5-3c05-334c-b45b-37168871d3c4" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="62" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="62" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="62" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="1083234322" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1083234322" unbViolId="d772c5a4-4037-358a-8b2e-c6ea0390ad27" locStartPos="42" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9ae5bd4b-f4d0-3a65-8569-cf32a0747695" locEndPos="43" locType="sr" hash="-1583021683" locEndLn="62" goals="0," />
    <StdViol msg="Identifier 'x' is hiding an identifier from global or namespace scope" ln="62" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="62" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_5_3-a" lnHash="1083234322" rule.header="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" tool="c++test" lineHash="1083234322" unbViolId="47c6fd25-2cc4-36de-ae37-be3e5369cec2" locStartPos="47" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="00f6a379-b293-3145-bd29-5a6ccd6dbf56" locEndPos="48" locType="sr" hash="-1583021683" locEndLn="62" goals="0," />
    <StdViol msg="Identifier 'x' is already used as static object or function identifier" ln="62" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="62" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_5_9-a" lnHash="1083234322" rule.header="No object or function identifier with static storage duration should be reused" tool="c++test" lineHash="1083234322" unbViolId="54bba31c-9f8c-3a14-86de-35ad9c466d82" locStartPos="47" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d5a4d027-e49b-3983-8a6c-e3d88bfed8e8" locEndPos="48" locType="sr" hash="-1583021683" locEndLn="62" goals="0," />
    <StdViol msg="Pass parameter &quot;x&quot; with const specifier" ln="62" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="62" sev="4" auth="root" locRef="9" rule="MISRAC2012-RULE_8_13-a" lnHash="1083234322" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="1083234322" unbViolId="bbdac761-3fe3-311f-857f-ce1a20abd74a" locStartPos="47" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="918c64ff-a83c-39f1-801f-71d82b9ef586" locEndPos="48" locType="sr" hash="-1583021683" locEndLn="62" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'functionCall_noFalseViolation2' should be followed by a block" ln="63" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="63" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="288550511" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="288550511" unbViolId="3c15c553-cd47-3080-bfac-12297597566a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1460b4f4-db04-3091-84c4-3b414e30cf44" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="63" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="63" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="63" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="288550511" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="288550511" unbViolId="a6aa1f9e-d755-3903-8faf-8418d579ff8a" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8399205c-e84c-39f2-8e79-a272c02d7bb6" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="63" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="63" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="63" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="288550511" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="288550511" unbViolId="5a57cff6-3351-3abc-b06b-50ab046ee8df" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="12b77f26-5bc7-3aae-91b1-a9fb741b50f8" locEndPos="14" locType="sr" hash="-1583021683" locEndLn="63" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="64" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="64" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_21_6-a" lnHash="-363037902" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-363037902" unbViolId="331f2383-a4b2-3295-866d-24f55da306e1" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e5f15e3a-00a2-386a-ae91-ee74cab965ca" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="64" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="64" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="64" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_17_7-a" lnHash="-363037902" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-363037902" unbViolId="b74a940a-86c1-3a94-8694-0ab8409118b6" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cc5b897a-d341-3866-b1e8-8ad9e55e9bbf" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="64" goals="0," />
    <StdViol msg="Prototype of function 'helper2' does not precede function call" ln="65" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="65" sev="1" auth="root" locRef="9" rule="MISRAC2012-RULE_17_3-a" lnHash="862376838" rule.header="Functions shall always have visible prototype at the function call" tool="c++test" lineHash="862376838" unbViolId="c0fc9264-d8ad-383f-b87a-4c3db8dbbe58" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f1342fb7-c1c0-3c6b-8bd5-a54fba7ef55a" locEndPos="12" locType="sr" hash="-1583021683" locEndLn="65" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="68" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="68" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="866754692" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="866754692" unbViolId="52c56854-0c01-3843-a3ec-97604e23371e" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="396c287b-4f75-38ed-b182-26da54927d28" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="68" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="69" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="69" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="2035137398" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="d41ec883-ae99-32f1-9842-1e7a3c6f2523" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fb1ba8d8-07dc-36fb-871c-b2fe91c8141f" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="69" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="69" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="69" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="2035137398" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="0df33595-f650-3afd-b00b-54dcf8883189" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6d79299e-0dc2-3831-b8b6-b8ec048be697" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="69" goals="0," />
    <StdViol msg="Test of a value against zero should be made explicit" ln="70" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="70" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_14_4-a" lnHash="1669491884" rule.header="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" tool="c++test" lineHash="1669491884" unbViolId="00d7c2a1-9316-361e-818c-ac6d946e4904" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3f099e29-4741-3da4-8aa8-6bf98e39bf69" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="70" goals="0," />
    <StdViol msg="Conditional statement 'if' in a function 'functionCall_trueViolation1' should be followed by a block" ln="70" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="70" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_15_6-b" lnHash="1669491884" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="1669491884" unbViolId="8dbf0aaa-e264-34d0-8a0d-1b5cc36f1a9d" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="19046113-a9f3-3f99-941b-0e43433a3c7b" locEndPos="5" locType="sr" hash="-1583021683" locEndLn="70" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="75" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="75" sev="4" auth="root" locRef="9" rule="MISRAC2012-DIR_4_6-b" lnHash="-1323201763" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1323201763" unbViolId="2e7ca45a-a198-3d96-b60c-27aa9106f297" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cd4405da-a37f-340c-80a7-509e9fdd293c" locEndPos="8" locType="sr" hash="-1583021683" locEndLn="75" goals="0," />
    <StdViol msg="Function 'functionCall_trueViolation2' is not in prototype form" ln="75" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="75" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_1_5-c" lnHash="-1323201763" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="-1323201763" unbViolId="3041f01c-4156-3dc9-9ab5-3b6037d41353" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e0854998-3a07-3c7c-b068-38a577f9e706" locEndPos="12" locType="sr" hash="-1583021683" locEndLn="75" goals="0," />
    <StdViol msg="Function 'functionCall_trueViolation2' is not in prototype form" ln="75" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="75" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_8_2-c" lnHash="-1323201763" rule.header="Function types shall be in prototype form" tool="c++test" lineHash="-1323201763" unbViolId="e9dfaa94-fd86-3118-af3e-7b148bd97189" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a380fe60-5a1a-366a-a55d-431fb5cf7d52" locEndPos="12" locType="sr" hash="-1583021683" locEndLn="75" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="76" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="76" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-a" lnHash="2035137398" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="24ee47d2-5836-3f0f-b4dd-3bc8df1e947d" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8a810122-06ea-3edd-8007-5851257518a6" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="76" goals="0," />
    <StdViol msg="'0' is assigned to expression of pointer type" ln="76" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="76" sev="2" auth="root" locRef="9" rule="MISRAC2012-RULE_11_9-b" lnHash="2035137398" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="2035137398" unbViolId="9853c4a2-12d7-32cb-9814-a2355b8ca18c" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9a551daa-1275-3e8f-aa85-8d5fd7d940e0" locEndPos="9" locType="sr" hash="-1583021683" locEndLn="76" goals="0," />
    <StdViol msg="Prototype of function 'helper2' does not precede function call" ln="77" locFile="/BugDetective/nullPointerDerefBenchmark.c" locStartln="77" sev="1" auth="root" locRef="9" rule="MISRAC2012-RULE_17_3-a" lnHash="862376838" rule.header="Functions shall always have visible prototype at the function call" tool="c++test" lineHash="862376838" unbViolId="d7f68cce-8195-304b-8c44-156c5845d083" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f556172c-7cac-377e-a959-90f10a07374b" locEndPos="12" locType="sr" hash="-1583021683" locEndLn="77" goals="0," />
    <StdViol msg="Parameter 'StatementHandle' is not used in function 'SQLExecDirect'" ln="6" locFile="/BugDetective/sql.c" locStartln="6" sev="4" auth="root" locRef="10" rule="MISRAC2012-RULE_2_7-a" lnHash="971653406" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="971653406" unbViolId="851beeb4-d468-3082-9d65-cf0b38b7597a" locStartPos="33" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="48069afe-2583-3814-abaa-d41e1d8d1778" locEndPos="34" locType="sr" hash="1115766966" locEndLn="6" goals="0," />
    <StdViol msg="Pass parameter &quot;StatementText&quot; with const specifier" ln="7" locFile="/BugDetective/sql.c" locStartln="7" sev="4" auth="root" locRef="10" rule="MISRAC2012-RULE_8_13-a" lnHash="7512296" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="7512296" unbViolId="94c6fe00-1b00-3095-a244-3d05c5c52691" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="901c2f36-8cee-3828-a6ee-45de4e591fc9" locEndPos="21" locType="sr" hash="1115766966" locEndLn="7" goals="0," />
    <StdViol msg="Parameter 'StatementText' is not used in function 'SQLExecDirect'" ln="7" locFile="/BugDetective/sql.c" locStartln="7" sev="4" auth="root" locRef="10" rule="MISRAC2012-RULE_2_7-a" lnHash="7512296" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="7512296" unbViolId="588c2a05-7f75-3c05-a03d-505fec393b9c" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2ac20e78-6af2-30b2-b2f8-2d7bb6e7944b" locEndPos="21" locType="sr" hash="1115766966" locEndLn="7" goals="0," />
    <StdViol msg="Parameter 'TextLength' is not used in function 'SQLExecDirect'" ln="7" locFile="/BugDetective/sql.c" locStartln="7" sev="4" auth="root" locRef="10" rule="MISRAC2012-RULE_2_7-a" lnHash="7512296" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="7512296" unbViolId="518535d4-7694-3b6e-bd7f-80f9c340a0fa" locStartPos="46" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2bec03cb-0786-38c5-a7f6-856c308ffc31" locEndPos="47" locType="sr" hash="1115766966" locEndLn="7" goals="0," />
    <StdViol msg="Declaration of object 'requestBeginning' does not precede its definition" ln="8" locFile="/BugDetective/sqlInjection.c" locStartln="8" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_8_4-a" lnHash="-559418447" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-559418447" unbViolId="ac056019-9086-3c76-a13f-7520c4d48b05" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="606a9c4e-b0ec-37b4-948d-2a23ea1e762c" locEndPos="13" locType="sr" hash="-1138451494" locEndLn="8" goals="0," />
    <StdViol msg="The object 'requestBeginning' is referenced only in the translation unit where it is defined" ln="8" locFile="/BugDetective/sqlInjection.c" locStartln="8" sev="4" auth="root" locRef="11" rule="MISRAC2012-RULE_8_7-a" lnHash="-559418447" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-559418447" unbViolId="9306f422-fc62-38cd-8257-cfb53166364f" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e1583c1e-1fd1-35b7-8e9c-c75daab8b554" locEndPos="13" locType="sr" hash="-1138451494" locEndLn="8" goals="0," />
    <StdViol msg="Declaration of object 'requestPassword' does not precede its definition" ln="9" locFile="/BugDetective/sqlInjection.c" locStartln="9" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_8_4-a" lnHash="973978042" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="973978042" unbViolId="689d51fb-c65d-3856-94aa-7b7775393fbb" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5a71d62c-4cc1-31b7-8fc3-a6525f7366b8" locEndPos="13" locType="sr" hash="-1138451494" locEndLn="9" goals="0," />
    <StdViol msg="The object 'requestPassword' is referenced only in the translation unit where it is defined" ln="9" locFile="/BugDetective/sqlInjection.c" locStartln="9" sev="4" auth="root" locRef="11" rule="MISRAC2012-RULE_8_7-a" lnHash="973978042" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="973978042" unbViolId="8555a1a1-913e-330d-b8c3-94fdc1281417" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="34d548a2-cd5e-31dd-b85b-9a8dde3dcb89" locEndPos="13" locType="sr" hash="-1138451494" locEndLn="9" goals="0," />
    <StdViol msg="Declaration of object 'requestEnding' does not precede its definition" ln="10" locFile="/BugDetective/sqlInjection.c" locStartln="10" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_8_4-a" lnHash="-1884737516" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1884737516" unbViolId="b287a163-d495-3bff-bd40-dc03b35e5d31" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="03bff0e3-f868-3cf4-9b68-9e43056f07f3" locEndPos="13" locType="sr" hash="-1138451494" locEndLn="10" goals="0," />
    <StdViol msg="The object 'requestEnding' is referenced only in the translation unit where it is defined" ln="10" locFile="/BugDetective/sqlInjection.c" locStartln="10" sev="4" auth="root" locRef="11" rule="MISRAC2012-RULE_8_7-a" lnHash="-1884737516" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-1884737516" unbViolId="5f8686f6-983b-3f8a-92db-d6907d09f5be" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="23f05d26-ce8f-3c5d-b806-6cc96a9caf0a" locEndPos="13" locType="sr" hash="-1138451494" locEndLn="10" goals="0," />
    <StdViol msg="Prototype of function 'extractUsername' does not precede function definition" ln="12" locFile="/BugDetective/sqlInjection.c" locStartln="12" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_8_4-a" lnHash="-1702657345" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1702657345" unbViolId="c9197cf1-3dcd-3b20-bf5f-b279646d6ad5" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="be34a189-f91d-3d36-b5a8-48574798a533" locEndPos="7" locType="sr" hash="-1138451494" locEndLn="12" goals="0," />
    <StdViol msg="The function 'extractUsername' is referenced only in the translation unit where it is defined" ln="12" locFile="/BugDetective/sqlInjection.c" locStartln="12" sev="4" auth="root" locRef="11" rule="MISRAC2012-RULE_8_7-a" lnHash="-1702657345" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-1702657345" unbViolId="22c5b92f-fafb-315e-a0fa-52cd8db41af6" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="eff0e31f-f819-333f-80f1-6f3fd7d4f7f9" locEndPos="7" locType="sr" hash="-1138451494" locEndLn="12" goals="0," />
    <StdViol msg="Prototype of function 'extractPassword' does not precede function definition" ln="18" locFile="/BugDetective/sqlInjection.c" locStartln="18" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_8_4-a" lnHash="-1186038118" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1186038118" unbViolId="d4222339-14e7-3550-a3a1-6c8e11a3e0ab" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="48c62514-e55d-3085-9388-d437d0c008e8" locEndPos="7" locType="sr" hash="-1138451494" locEndLn="18" goals="0," />
    <StdViol msg="The function 'extractPassword' is referenced only in the translation unit where it is defined" ln="18" locFile="/BugDetective/sqlInjection.c" locStartln="18" sev="4" auth="root" locRef="11" rule="MISRAC2012-RULE_8_7-a" lnHash="-1186038118" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-1186038118" unbViolId="dbf09efd-6cb4-3cde-9c8d-de7bb3e89ca0" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="9d184da5-0c63-33df-a893-d79d60341891" locEndPos="7" locType="sr" hash="-1138451494" locEndLn="18" goals="0," />
    <StdViol msg="Prototype of function 'handleRequest' does not precede function definition" ln="24" locFile="/BugDetective/sqlInjection.c" locStartln="24" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_8_4-a" lnHash="-1127426835" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-1127426835" unbViolId="68671f83-f731-30ff-bbca-f5d99b45fba4" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="daaa8abf-fb00-3c63-834e-f55dcb224343" locEndPos="6" locType="sr" hash="-1138451494" locEndLn="24" goals="0," />
    <FlowViol msg="Value returned from method &quot;fread&quot; should be checked" ln="29" locFile="/BugDetective/sqlInjection.c" ruleSAFMsg="Point by which returned value should be checked" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="30" rule="MISRAC2012-DIR_4_7-b" FirstElSrcRngStartPos="0" lnHash="-511599591" ruleSCSCMsg="Method call" FirstElSrcRngFile="/BugDetective/sqlInjection.c" rule.header="Always check the returned value of non-void function" FirstElSrcRngStartln="29" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1426786920" lang="cpp" violId="1ce9cecd-df71-36e5-ad34-36df47a34e04" locEndPos="0" locEndLn="30" goals="0," locStartln="29" sev="2" locRef="11" tool="c++test" lineHash="-511599591" unbViolId="80ddec27-0c94-379f-bc6c-c37ac391c5ea" locType="sr" hash="-1138451494" causeLocRef="11">
      <Props />
      <ElDescList>
        <ElDesc lineHash="-905220607" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/sqlInjection.c" desc="char parametersString[BUF_SIZE];" ElType="." rngLn="26" />
        <ElDesc lineHash="-559634335" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/sqlInjection.c" desc="char request[BUF_SIZE];" ElType="." rngLn="27" />
        <ElDesc lineHash="-511599591" ln="29" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="29" srcRngEndLn="30" srcRngFile="/BugDetective/sqlInjection.c" desc="fread(parametersString, 1, BUF_SIZE, file);" ElType="CP" rngLn="29">
          <Anns>
            <Ann msg="Method call" kind="cause" />
            <Ann msg="Point by which returned value should be checked" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'fread' function is not allowed" ln="29" locFile="/BugDetective/sqlInjection.c" locStartln="29" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_21_6-a" lnHash="-511599591" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-511599591" unbViolId="022fa83c-d39a-3dfc-bbf9-69cca8636910" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="73e18745-0a22-3032-b00b-4b225f7b46df" locEndPos="5" locType="sr" hash="-1138451494" locEndLn="29" goals="0," />
    <StdViol msg="Unused function's &quot;fread&quot; return value" ln="29" locFile="/BugDetective/sqlInjection.c" locStartln="29" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_17_7-a" lnHash="-511599591" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-511599591" unbViolId="4c97bf8b-f512-3ea3-832d-3c55f1a5971e" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c49283a1-875a-3682-8b9f-6f0d719a7f99" locEndPos="5" locType="sr" hash="-1138451494" locEndLn="29" goals="0," />
    <StdViol msg="Unused function's &quot;strcpy&quot; return value" ln="30" locFile="/BugDetective/sqlInjection.c" locStartln="30" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_17_7-a" lnHash="-1599126410" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1599126410" unbViolId="ba929a96-5b8f-3e8d-93f9-f04de173a0cc" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="01598881-02d3-34a1-a0b5-95c04a340343" locEndPos="5" locType="sr" hash="-1138451494" locEndLn="30" goals="0," />
    <StdViol msg="Unused function's &quot;strcat&quot; return value" ln="31" locFile="/BugDetective/sqlInjection.c" locStartln="31" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_17_7-a" lnHash="-1251525233" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1251525233" unbViolId="2feb01e5-b373-38c3-9bcb-ff5284e3be00" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e27b705e-980d-309d-b6a1-4504046e526b" locEndPos="5" locType="sr" hash="-1138451494" locEndLn="31" goals="0," />
    <StdViol msg="Unused function's &quot;strcat&quot; return value" ln="32" locFile="/BugDetective/sqlInjection.c" locStartln="32" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_17_7-a" lnHash="1521663516" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="1521663516" unbViolId="ddebe3a2-a199-3a5a-95ee-d27885319d46" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fa993f04-7806-3c07-8093-809da8085ca0" locEndPos="5" locType="sr" hash="-1138451494" locEndLn="32" goals="0," />
    <StdViol msg="Unused function's &quot;strcat&quot; return value" ln="33" locFile="/BugDetective/sqlInjection.c" locStartln="33" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_17_7-a" lnHash="377084628" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="377084628" unbViolId="6e502607-47eb-3724-8389-82ceeaba8ba0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5b660ff8-0fb0-348c-a025-eaadf2b0c3f8" locEndPos="5" locType="sr" hash="-1138451494" locEndLn="33" goals="0," />
    <StdViol msg="Unused function's &quot;strcat&quot; return value" ln="34" locFile="/BugDetective/sqlInjection.c" locStartln="34" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_17_7-a" lnHash="970597736" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="970597736" unbViolId="742ddb62-1553-3746-b5ce-f025f5ffde15" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="62b1efc3-7c33-3e59-a5ca-b2a2ac5f2649" locEndPos="5" locType="sr" hash="-1138451494" locEndLn="34" goals="0," />
    <FlowViol msg="Data obtained from a file (&quot;request[]&quot;) is injected to an SQL query" ln="35" locFile="/BugDetective/sqlInjection.c" ruleSAFMsg="Call to a dangerous method" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="30" rule="MISRAC2012-DIR_4_14-g" FirstElSrcRngStartPos="0" lnHash="2001837733" ruleSCSCMsg="Tainting point" FirstElSrcRngFile="/BugDetective/sqlInjection.c" rule.header="Protect against SQL injection" FirstElSrcRngStartln="29" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1873730567" lang="cpp" violId="c4d4b355-e9a6-30e6-9783-d853f3acc1e3" locEndPos="0" locEndLn="36" goals="0," locStartln="35" sev="2" locRef="11" tool="c++test" lineHash="2001837733" unbViolId="ae770e12-f067-3f96-a81e-d6bc9e3e813b" locType="sr" hash="-1138451494" causeLocRef="11">
      <Props>
        <Prop key="Tracked variables" val="Tainted data" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-905220607" ln="26" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="26" srcRngEndLn="27" srcRngFile="/BugDetective/sqlInjection.c" desc="char parametersString[BUF_SIZE];" ElType="." rngLn="26" />
        <ElDesc lineHash="-559634335" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/sqlInjection.c" desc="char request[BUF_SIZE];" ElType="." rngLn="27" />
        <ElDesc lineHash="-511599591" ln="29" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="29" srcRngEndLn="30" srcRngFile="/BugDetective/sqlInjection.c" desc="fread(parametersString, 1, BUF_SIZE, file);" ElType=".C" rngLn="29">
          <Props>
            <Prop key="Tracked variables" val="parametersString[]" />
          </Props>
          <Anns>
            <Ann msg="Tainting point" kind="cause" />
            <Ann msg="Tainted data: parametersString[]" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1599126410" ln="30" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="30" srcRngEndLn="31" srcRngFile="/BugDetective/sqlInjection.c" desc="strcpy(request, requestBeginning);" ElType="." rngLn="30" />
        <ElDesc lineHash="-1251525233" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/BugDetective/sqlInjection.c" desc="extractUsername(...)" ElType="!" rngLn="31">
          <ElDescList>
            <ElDesc lineHash="1599599919" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/BugDetective/sqlInjection.c" desc="return s;" ElType="!" rngLn="15">
              <Props>
                <Prop key="Tracked variables" val="s[]" />
              </Props>
              <Anns>
                <Ann msg="Tainted data: s[]" kind="var" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
        <ElDesc lineHash="-1251525233" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/BugDetective/sqlInjection.c" desc="strcat(request, extractUsername(parametersString));" ElType="." rngLn="31" />
        <ElDesc lineHash="1521663516" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/sqlInjection.c" desc="strcat(request, requestPassword);" ElType="." rngLn="32" />
        <ElDesc lineHash="377084628" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/sqlInjection.c" desc="extractPassword(...)" ElType="!" rngLn="33">
          <ElDescList>
            <ElDesc lineHash="1599599919" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/sqlInjection.c" desc="return s;" ElType="!" rngLn="21">
              <Props>
                <Prop key="Tracked variables" val="s[]" />
              </Props>
              <Anns>
                <Ann msg="Tainted data: s[]" kind="var" />
              </Anns>
            </ElDesc>
          </ElDescList>
        </ElDesc>
        <ElDesc lineHash="377084628" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/sqlInjection.c" desc="strcat(request, extractPassword(parametersString));" ElType="!" rngLn="33" />
        <ElDesc lineHash="970597736" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/sqlInjection.c" desc="strcat(request, requestEnding);" ElType="." rngLn="34">
          <Props>
            <Prop key="Tracked variables" val="request[]" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: request[]" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="2001837733" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="11" locType="sr" srcRnghash="-1138451494" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/sqlInjection.c" desc="SQLExecDirect(statementHandle, (SQLCHAR *)request, strlen(request));" ElType=".P" rngLn="35">
          <Props>
            <Prop key="Tracked variables" val="request[]" />
          </Props>
          <Anns>
            <Ann msg="Tainted data: request[]" kind="var" />
            <Ann msg="Call to a dangerous method" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Unused function's &quot;SQLExecDirect&quot; return value" ln="35" locFile="/BugDetective/sqlInjection.c" locStartln="35" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_17_7-a" lnHash="2001837733" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="2001837733" unbViolId="8bff15d7-f20a-3746-a206-815cff71b9c9" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="973bbd4f-7453-35f7-9226-dcbbc91ff275" locEndPos="5" locType="sr" hash="-1138451494" locEndLn="35" goals="0," />
    <StdViol msg="The argument number '3' ('essentially unsigned' type) is passed to the function 'SQLExecDirect' as a parameter with the 'essentially signed' type" ln="35" locFile="/BugDetective/sqlInjection.c" locStartln="35" sev="2" auth="root" locRef="11" rule="MISRAC2012-RULE_10_3-b" lnHash="2001837733" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="2001837733" unbViolId="7f1bd93e-5567-3327-abd9-0186925bc933" locStartPos="55" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="deec1c27-49a3-3561-9a84-1cc0eaa8aef5" locEndPos="56" locType="sr" hash="-1138451494" locEndLn="35" goals="0," />
    <StdViol msg="An unused tag declaration 'Figures' has been found" ln="3" locFile="/BugDetective/unreachableCode.c" locStartln="3" sev="4" auth="root" locRef="12" rule="MISRAC2012-RULE_2_4-b" lnHash="1214044715" rule.header="A source file should not contain unused tag declarations" tool="c++test" lineHash="1214044715" unbViolId="fd6a9f64-f70c-318e-84f4-4bca534f94b6" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2e112603-e5d4-3cb3-8fdb-e88771a0203a" locEndPos="6" locType="sr" hash="1398926183" locEndLn="3" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="11" locFile="/BugDetective/unreachableCode.c" locStartln="11" sev="4" auth="root" locRef="12" rule="MISRAC2012-DIR_4_6-b" lnHash="-1480948708" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1480948708" unbViolId="dfa253f3-5b1a-3c46-8020-2509369235c5" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a2493171-af92-37b3-bfb3-30246460cfc7" locEndPos="25" locType="sr" hash="1398926183" locEndLn="11" goals="0," />
    <StdViol msg="Reserved name 'round' used" ln="11" locFile="/BugDetective/unreachableCode.c" locStartln="11" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_2-c" lnHash="-1480948708" rule.header="The names of standard library macros, objects and functions shall not be reused (C99)" tool="c++test" lineHash="-1480948708" unbViolId="2fba1741-75ea-3167-9133-52b653b0b14e" locStartPos="28" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9f17f6e8-7b0c-30b2-8a01-eb6e4b1ab14b" locEndPos="29" locType="sr" hash="1398926183" locEndLn="11" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="11" locFile="/BugDetective/unreachableCode.c" locStartln="11" sev="4" auth="root" locRef="12" rule="MISRAC2012-DIR_4_6-b" lnHash="-1480948708" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1480948708" unbViolId="183c7f1c-0b42-306f-9133-96ead7e1a7d7" locStartPos="35" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a40a1b5b-99c2-387e-9cb5-f8f25327fb50" locEndPos="36" locType="sr" hash="1398926183" locEndLn="11" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="13" locFile="/BugDetective/unreachableCode.c" locStartln="13" sev="4" auth="root" locRef="12" rule="MISRAC2012-DIR_4_6-b" lnHash="1057660582" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1057660582" unbViolId="f9a3bbdf-7e8b-3461-9adc-025f7b5a2602" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="19162a10-e609-38ea-ac0b-a312c021c209" locEndPos="5" locType="sr" hash="1398926183" locEndLn="13" goals="0," />
    <StdViol msg="The left hand operand of the logical operator '&amp;&amp;' should have essentially Boolean type" ln="14" locFile="/BugDetective/unreachableCode.c" locStartln="14" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_1-a" lnHash="698448873" rule.header="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" tool="c++test" lineHash="698448873" unbViolId="d4beee68-0490-310e-98ad-5b8a16189146" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0a2a7334-ee49-304b-a742-ed121a814704" locEndPos="9" locType="sr" hash="1398926183" locEndLn="14" goals="0," />
    <StdViol msg="The right hand operand of the logical operator '&amp;&amp;' should have essentially Boolean type" ln="14" locFile="/BugDetective/unreachableCode.c" locStartln="14" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_1-a" lnHash="698448873" rule.header="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" tool="c++test" lineHash="698448873" unbViolId="bb822866-602e-315d-80f8-402029d71b6c" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="019b75b7-9b4a-3118-8f30-dd7273483851" locEndPos="9" locType="sr" hash="1398926183" locEndLn="14" goals="0," />
    <StdViol msg="The expression of the 'essentially Enum' type is assigned to an object with the 'essentially signed' type" ln="15" locFile="/BugDetective/unreachableCode.c" locStartln="15" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_3-b" lnHash="-793927953" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="-793927953" unbViolId="b899ab98-ab16-3d05-9bf9-e568b637c27d" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3c722678-1606-35aa-8ed3-fe4922a4a940" locEndPos="9" locType="sr" hash="1398926183" locEndLn="15" goals="0," />
    <StdViol msg="The left hand operand of the logical operator '&amp;&amp;' should have essentially Boolean type" ln="16" locFile="/BugDetective/unreachableCode.c" locStartln="16" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_1-a" lnHash="-187791626" rule.header="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" tool="c++test" lineHash="-187791626" unbViolId="77ecc2f6-b8ee-3d01-96d2-2ad517817303" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7250c761-5fe4-32fa-92d7-a81e40739e07" locEndPos="16" locType="sr" hash="1398926183" locEndLn="16" goals="0," />
    <StdViol msg="The operand of the logical negation operator '!' should have essentially Boolean type" ln="16" locFile="/BugDetective/unreachableCode.c" locStartln="16" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_1-a" lnHash="-187791626" rule.header="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" tool="c++test" lineHash="-187791626" unbViolId="37daced5-b6ae-39a3-af72-fa3962539276" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="83ae1097-9b29-3abb-a707-68421b531566" locEndPos="25" locType="sr" hash="1398926183" locEndLn="16" goals="0," />
    <StdViol msg="The operands of a logical '&amp;&amp;' in function 'guessFigure' should be parenthesized" ln="16" locFile="/BugDetective/unreachableCode.c" locStartln="16" sev="4" auth="root" locRef="12" rule="MISRAC2012-RULE_12_1-b" lnHash="-187791626" rule.header="The operands of a logical &amp;&amp; or || shall be primary-expressions" tool="c++test" lineHash="-187791626" unbViolId="8900e932-d09c-3fc9-86fc-a7569600d530" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4889bdc0-71cc-3c85-95cb-750fc3ef0942" locEndPos="25" locType="sr" hash="1398926183" locEndLn="16" goals="0," />
    <StdViol msg="The expression of the 'essentially Enum' type is assigned to an object with the 'essentially signed' type" ln="17" locFile="/BugDetective/unreachableCode.c" locStartln="17" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_3-b" lnHash="1994648140" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="1994648140" unbViolId="e0b6bee4-a1b9-3e6c-8ff6-935c11ff0634" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3ee9e0ae-ea12-371f-b086-c0d5e2167f8c" locEndPos="9" locType="sr" hash="1398926183" locEndLn="17" goals="0," />
    <StdViol msg="The operand of the logical negation operator '!' should have essentially Boolean type" ln="18" locFile="/BugDetective/unreachableCode.c" locStartln="18" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_1-a" lnHash="-1388792196" rule.header="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" tool="c++test" lineHash="-1388792196" unbViolId="b6b00b15-1afd-35fb-bb1d-5930b03f1e34" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eeef4546-64a0-3306-a000-c3570f620b0a" locEndPos="16" locType="sr" hash="1398926183" locEndLn="18" goals="0," />
    <StdViol msg="The right hand operand of the logical operator '&amp;&amp;' should have essentially Boolean type" ln="18" locFile="/BugDetective/unreachableCode.c" locStartln="18" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_1-a" lnHash="-1388792196" rule.header="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" tool="c++test" lineHash="-1388792196" unbViolId="3ebff440-f67d-3f38-b1b2-c4da0077a2b5" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ff02b343-aa22-3ac9-8a7c-ecc1cf4882cf" locEndPos="16" locType="sr" hash="1398926183" locEndLn="18" goals="0," />
    <StdViol msg="The operands of a logical '&amp;&amp;' in function 'guessFigure' should be parenthesized" ln="18" locFile="/BugDetective/unreachableCode.c" locStartln="18" sev="4" auth="root" locRef="12" rule="MISRAC2012-RULE_12_1-b" lnHash="-1388792196" rule.header="The operands of a logical &amp;&amp; or || shall be primary-expressions" tool="c++test" lineHash="-1388792196" unbViolId="b45678c3-39d7-3158-b679-66fe6d9831f6" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4878b27b-5d5b-381c-acf6-1eb66090ad11" locEndPos="16" locType="sr" hash="1398926183" locEndLn="18" goals="0," />
    <StdViol msg="The expression of the 'essentially Enum' type is assigned to an object with the 'essentially signed' type" ln="19" locFile="/BugDetective/unreachableCode.c" locStartln="19" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_3-b" lnHash="851578823" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="851578823" unbViolId="a1ddad04-7fd7-3dbe-abe0-b28bbf57ad68" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="552bb3f4-646f-338f-859b-181f51811a9d" locEndPos="9" locType="sr" hash="1398926183" locEndLn="19" goals="0," />
    <StdViol msg="The expression of the 'essentially Enum' type is assigned to an object with the 'essentially signed' type" ln="21" locFile="/BugDetective/unreachableCode.c" locStartln="21" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_3-b" lnHash="-753412193" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="-753412193" unbViolId="2102acb9-ab6e-3ca8-9813-569f499916fa" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="96bd0e38-6de2-32b4-94e6-af4c33ef574a" locEndPos="9" locType="sr" hash="1398926183" locEndLn="21" goals="0," />
    <StdViol msg="The expression of the 'essentially Enum' type in a switch statement's case label is converted to the 'essentially signed' type" ln="25" locFile="/BugDetective/unreachableCode.c" locStartln="25" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_3-b" lnHash="485117389" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="485117389" unbViolId="5295fbbf-40dd-3d1c-8e61-c11564d80ab3" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="011621ee-3748-37f3-b14a-6eaa3456a574" locEndPos="9" locType="sr" hash="1398926183" locEndLn="25" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="26" locFile="/BugDetective/unreachableCode.c" locStartln="26" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_6-a" lnHash="-984489055" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-984489055" unbViolId="708a305d-acee-3842-b0c4-0bfd3873c565" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fadbfbfb-3fc6-37ea-b654-da294e078349" locEndPos="13" locType="sr" hash="1398926183" locEndLn="26" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="26" locFile="/BugDetective/unreachableCode.c" locStartln="26" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_17_7-a" lnHash="-984489055" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-984489055" unbViolId="d7d3ad1c-78ff-3e2c-bf97-ea0eaef781b6" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5ceb4422-fc4b-323f-91ce-4a5356828360" locEndPos="13" locType="sr" hash="1398926183" locEndLn="26" goals="0," />
    <StdViol msg="The expression of the 'essentially Enum' type in a switch statement's case label is converted to the 'essentially signed' type" ln="29" locFile="/BugDetective/unreachableCode.c" locStartln="29" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_3-b" lnHash="-327745628" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="-327745628" unbViolId="8611658a-9062-3629-bf7a-8f4137f7fa9c" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="98bc9eba-b060-31c7-a2e9-59698f7922fc" locEndPos="9" locType="sr" hash="1398926183" locEndLn="29" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="30" locFile="/BugDetective/unreachableCode.c" locStartln="30" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_6-a" lnHash="-725201032" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-725201032" unbViolId="13102d12-3354-3f31-b44b-5feff331a04a" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="18fd4de8-622d-3fd1-9f43-21c1d3e7cdd2" locEndPos="13" locType="sr" hash="1398926183" locEndLn="30" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="30" locFile="/BugDetective/unreachableCode.c" locStartln="30" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_17_7-a" lnHash="-725201032" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-725201032" unbViolId="b982352d-9de5-35ec-ac64-3cf07e587331" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d0713b35-ff4a-3885-bb45-04646e3010e5" locEndPos="13" locType="sr" hash="1398926183" locEndLn="30" goals="0," />
    <StdViol msg="The expression of the 'essentially Enum' type in a switch statement's case label is converted to the 'essentially signed' type" ln="32" locFile="/BugDetective/unreachableCode.c" locStartln="32" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_3-b" lnHash="-1061789574" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="-1061789574" unbViolId="4f011217-9f57-3bde-b3d9-b393b6e30815" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="72b4cb92-670d-34e2-ba3b-6ee7a7e7836a" locEndPos="9" locType="sr" hash="1398926183" locEndLn="32" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="33" locFile="/BugDetective/unreachableCode.c" locStartln="33" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_6-a" lnHash="-1222456386" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1222456386" unbViolId="86e1e1dc-4c6f-305f-b48e-fda41524f9ed" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="69b5abb9-f380-3e5c-bce2-7d2410b06489" locEndPos="13" locType="sr" hash="1398926183" locEndLn="33" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="33" locFile="/BugDetective/unreachableCode.c" locStartln="33" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_17_7-a" lnHash="-1222456386" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1222456386" unbViolId="86a9ffc0-2db3-39db-9747-2026df13dabe" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="abfd721c-0eab-3481-ad29-fe7fcf767258" locEndPos="13" locType="sr" hash="1398926183" locEndLn="33" goals="0," />
    <StdViol msg="The expression of the 'essentially Enum' type in a switch statement's case label is converted to the 'essentially signed' type" ln="35" locFile="/BugDetective/unreachableCode.c" locStartln="35" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_10_3-b" lnHash="499795381" rule.header="The value of an expression shall not be assigned to an object of a different essential type category" tool="c++test" lineHash="499795381" unbViolId="ef01d9df-d73f-3192-b35f-ac6f7e8d327b" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="81b7a466-a4f9-3bb9-b789-828531c2cde9" locEndPos="9" locType="sr" hash="1398926183" locEndLn="35" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="36" locFile="/BugDetective/unreachableCode.c" locStartln="36" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_6-a" lnHash="1569944761" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="1569944761" unbViolId="4ec8497b-4184-397d-92c0-46a26187a3d6" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dd377d8c-1481-3d7f-a3f3-94fe9f032191" locEndPos="13" locType="sr" hash="1398926183" locEndLn="36" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="36" locFile="/BugDetective/unreachableCode.c" locStartln="36" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_17_7-a" lnHash="1569944761" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="1569944761" unbViolId="ec1f7a8f-bce7-39cc-b013-81c3220204e5" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aaa84019-726b-3f2b-b193-d043e8583312" locEndPos="13" locType="sr" hash="1398926183" locEndLn="36" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="39" locFile="/BugDetective/unreachableCode.c" locStartln="39" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_6-a" lnHash="-703549359" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-703549359" unbViolId="bd84efa0-3799-33f7-857b-7975b3a60643" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2a29743c-85f0-3fcf-a608-03991bae60ba" locEndPos="13" locType="sr" hash="1398926183" locEndLn="39" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="39" locFile="/BugDetective/unreachableCode.c" locStartln="39" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_17_7-a" lnHash="-703549359" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-703549359" unbViolId="814668b8-8001-3f33-b792-ad7d133720a7" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="56fffd42-3b3b-3aab-b420-6c5d182327ce" locEndPos="13" locType="sr" hash="1398926183" locEndLn="39" goals="0," />
    <StdViol msg="Pass parameter &quot;cur&quot; with const specifier" ln="44" locFile="/BugDetective/unreachableCode.c" locStartln="44" sev="4" auth="root" locRef="12" rule="MISRAC2012-RULE_8_13-a" lnHash="1739736142" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="1739736142" unbViolId="a15a6043-08ff-3463-a8b1-c0644dbd4b7c" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b3492b1b-bdf0-373f-8077-49067bfdc588" locEndPos="30" locType="sr" hash="1398926183" locEndLn="44" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="47" locFile="/BugDetective/unreachableCode.c" locStartln="47" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_6-a" lnHash="1876045705" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="1876045705" unbViolId="c4c3cc3b-f0ad-3f70-96c1-5050816685fb" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2ddc1981-8db1-3c6b-9afe-b5e62c6e4d39" locEndPos="3" locType="sr" hash="1398926183" locEndLn="47" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="47" locFile="/BugDetective/unreachableCode.c" locStartln="47" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_17_7-a" lnHash="1876045705" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="1876045705" unbViolId="f76008ca-5b33-3002-a3b1-63bff1c81415" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e3d0ba07-a0ee-3514-a590-a788770b9df8" locEndPos="3" locType="sr" hash="1398926183" locEndLn="47" goals="0," />
    <StdViol msg="'return' statement should be at the end of the 'checkRange' function" ln="48" locFile="/BugDetective/unreachableCode.c" locStartln="48" sev="4" auth="root" locRef="12" rule="MISRAC2012-RULE_15_5-a" lnHash="516678635" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="516678635" unbViolId="f306adea-2693-3c41-a93b-02702272c3b5" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f135640f-d76d-3556-8b2f-0a640a38809f" locEndPos="3" locType="sr" hash="1398926183" locEndLn="48" goals="0," />
    <FlowViol msg="Condition &quot;(*cur >= 'a') &amp;&amp; (*cur &lt;= 'f')&quot; always evaluates to false" ln="51" locFile="/BugDetective/unreachableCode.c" ruleSAFMsg="Point where senseless condition is used" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="45" rule="MISRAC2012-RULE_14_3-ac" FirstElSrcRngStartPos="0" lnHash="1747727699" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/unreachableCode.c" rule.header="Avoid conditions that always evaluate to the same value" FirstElSrcRngStartln="44" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1451351576" lang="cpp" violId="ccbec138-b010-3203-b159-f4ecb2760d25" locEndPos="0" locEndLn="52" goals="0," locStartln="51" sev="2" locRef="12" tool="c++test" lineHash="1747727699" unbViolId="712b3d89-b08c-3e0e-b79a-7afb557cb38d" locType="sr" hash="1398926183" causeLocRef="12">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1739736142" ln="44" srcRngStartPos="0" srcRngEndPos="0" locRef="12" locType="sr" srcRnghash="1398926183" srcRngStartln="44" srcRngEndLn="45" srcRngFile="/BugDetective/unreachableCode.c" desc="static void checkRange(char* cur)" ElType=".C" rngLn="44">
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="207315533" ln="46" srcRngStartPos="0" srcRngEndPos="0" locRef="12" locType="sr" srcRnghash="1398926183" srcRngStartln="46" srcRngEndLn="47" srcRngFile="/BugDetective/unreachableCode.c" desc="if ((*cur &lt; '0') || (*cur > '9')) {" ElType="." rngLn="46">
          <Anns>
            <Ann msg="Condition evaluation: (*cur &lt; 48) (assuming false)" kind="condEval" />
            <Ann msg="Condition evaluation: (*cur > 57) (assuming false)" kind="condEval" />
            <Ann msg="Condition evaluation: (*cur &lt; '0') || (*cur > '9') (false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1747727699" ln="51" srcRngStartPos="0" srcRngEndPos="0" locRef="12" locType="sr" srcRnghash="1398926183" srcRngStartln="51" srcRngEndLn="52" srcRngFile="/BugDetective/unreachableCode.c" desc="if ((*cur >= 'a') &amp;&amp; (*cur &lt;= 'f')) {" ElType=".P" rngLn="51">
          <Anns>
            <Ann msg="Condition evaluation: (*cur >= 97) (false)" kind="condEval" />
            <Ann msg="Point where senseless condition is used" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Pass parameter &quot;cur&quot; with const specifier" ln="56" locFile="/BugDetective/unreachableCode.c" locStartln="56" sev="4" auth="root" locRef="12" rule="MISRAC2012-RULE_8_13-a" lnHash="1824344440" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="1824344440" unbViolId="5eef4822-87cb-38f6-9a17-66da6592ed73" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a50035cd-9c2e-3528-9b38-4c9c215a9ea0" locEndPos="32" locType="sr" hash="1398926183" locEndLn="56" goals="0," />
    <StdViol msg="Usage of 'printf' function is not allowed" ln="59" locFile="/BugDetective/unreachableCode.c" locStartln="59" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_6-a" lnHash="157306488" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="157306488" unbViolId="9b0947b4-e547-35fe-8b9a-0f41405d3cdb" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e32e3883-b9e1-3a17-987d-acc11dd0d400" locEndPos="3" locType="sr" hash="1398926183" locEndLn="59" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="59" locFile="/BugDetective/unreachableCode.c" locStartln="59" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_17_7-a" lnHash="157306488" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="157306488" unbViolId="82bc1712-a591-3e46-947e-da505989d48d" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7adf214a-e5e0-32f1-aeb6-a807609d82e9" locEndPos="3" locType="sr" hash="1398926183" locEndLn="59" goals="0," />
    <StdViol msg="Provide only one exit point in 'checkSequence' function" ln="60" locFile="/BugDetective/unreachableCode.c" locStartln="60" sev="4" auth="root" locRef="12" rule="MISRAC2012-RULE_15_5-a" lnHash="516678635" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="516678635" unbViolId="288fda98-e665-3e77-b3fe-00fe1ef98255" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="823ad2b1-f875-3752-9247-a710f4cafd08" locEndPos="3" locType="sr" hash="1398926183" locEndLn="60" goals="0," />
    <FlowViol msg="&quot;cur&quot; is checked for null after being dereferenced" ln="63" locFile="/BugDetective/unreachableCode.c" ruleSAFMsg="Point of checking for nullity" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="59" rule="MISRAC2012-DIR_4_1-f" FirstElSrcRngStartPos="0" lnHash="219043974" ruleSCSCMsg="Point of dereferencing" FirstElSrcRngFile="/BugDetective/unreachableCode.c" rule.header="Do not check for null after dereferencing" FirstElSrcRngStartln="58" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1480975621" lang="cpp" violId="914d82f2-a861-378d-b6f1-24cee35a147d" locEndPos="0" locEndLn="64" goals="0," locStartln="63" sev="2" locRef="12" tool="c++test" lineHash="219043974" unbViolId="9f7789b8-d670-3965-9b60-aa1a6be12ef6" locType="sr" hash="1398926183" causeLocRef="12">
      <Props>
        <Prop key="Tracked variables" val="Important values" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1138493433" ln="58" srcRngStartPos="0" srcRngEndPos="0" locRef="12" locType="sr" srcRnghash="1398926183" srcRngStartln="58" srcRngEndLn="59" srcRngFile="/BugDetective/unreachableCode.c" desc="if (cur[0] == '-') {" ElType=".C" rngLn="58">
          <Props>
            <Prop key="Tracked variables" val="cur != null" />
          </Props>
          <Anns>
            <Ann msg="Point of dereferencing" kind="cause" />
            <Ann msg="Important values: cur != null" kind="var" />
            <Ann msg="Condition evaluation: (cur[0] == 45) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="219043974" ln="63" srcRngStartPos="0" srcRngEndPos="0" locRef="12" locType="sr" srcRnghash="1398926183" srcRngStartln="63" srcRngEndLn="64" srcRngFile="/BugDetective/unreachableCode.c" desc="if (cur == 0) {" ElType=".P" rngLn="63">
          <Props>
            <Prop key="Tracked variables" val="cur != null" />
          </Props>
          <Anns>
            <Ann msg="Important values: cur != null" kind="var" />
            <Ann msg="Point of checking for nullity" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Condition &quot;cur == 0&quot; always evaluates to false" ln="63" locFile="/BugDetective/unreachableCode.c" ruleSAFMsg="Point where senseless condition is used" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="57" rule="MISRAC2012-RULE_14_3-ac" FirstElSrcRngStartPos="0" lnHash="219043974" ruleSCSCMsg="Start of the path" FirstElSrcRngFile="/BugDetective/unreachableCode.c" rule.header="Avoid conditions that always evaluate to the same value" FirstElSrcRngStartln="56" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1056502269" lang="cpp" violId="6369e946-eb26-3448-85e3-e19f1154821d" locEndPos="0" locEndLn="64" goals="0," locStartln="63" sev="2" locRef="12" tool="c++test" lineHash="219043974" unbViolId="db324e9b-688a-3161-b278-56a4ed9ca88f" locType="sr" hash="1398926183" causeLocRef="12">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1824344440" ln="56" srcRngStartPos="0" srcRngEndPos="0" locRef="12" locType="sr" srcRnghash="1398926183" srcRngStartln="56" srcRngEndLn="57" srcRngFile="/BugDetective/unreachableCode.c" desc="static void checkSequence(char cur[])" ElType=".C" rngLn="56">
          <Anns>
            <Ann msg="Start of the path" kind="cause" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1138493433" ln="58" srcRngStartPos="0" srcRngEndPos="0" locRef="12" locType="sr" srcRnghash="1398926183" srcRngStartln="58" srcRngEndLn="59" srcRngFile="/BugDetective/unreachableCode.c" desc="if (cur[0] == '-') {" ElType="." rngLn="58">
          <Anns>
            <Ann msg="Condition evaluation: (cur[0] == 45) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="219043974" ln="63" srcRngStartPos="0" srcRngEndPos="0" locRef="12" locType="sr" srcRnghash="1398926183" srcRngStartln="63" srcRngEndLn="64" srcRngFile="/BugDetective/unreachableCode.c" desc="if (cur == 0) {" ElType=".P" rngLn="63">
          <Anns>
            <Ann msg="Point where senseless condition is used" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'printf' function is not allowed" ln="64" locFile="/BugDetective/unreachableCode.c" locStartln="64" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_21_6-a" lnHash="-1003437044" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1003437044" unbViolId="ea115623-9816-3046-996c-25ccaf899ad2" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a531137c-d8d2-3949-9a78-5cbb5303fba4" locEndPos="3" locType="sr" hash="1398926183" locEndLn="64" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="64" locFile="/BugDetective/unreachableCode.c" locStartln="64" sev="2" auth="root" locRef="12" rule="MISRAC2012-RULE_17_7-a" lnHash="-1003437044" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1003437044" unbViolId="407b83fd-5ff5-3437-9a00-b99fead96f81" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="91dd413f-a8e0-34b4-b95b-9a3cb2f9ba87" locEndPos="3" locType="sr" hash="1398926183" locEndLn="64" goals="0," />
    <StdViol msg="Provide only one exit point in 'checkSequence' function" ln="65" locFile="/BugDetective/unreachableCode.c" locStartln="65" sev="4" auth="root" locRef="12" rule="MISRAC2012-RULE_15_5-a" lnHash="516678635" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="516678635" unbViolId="9c19a0b5-92a1-37a7-ae1e-ec4059a46065" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4af6b1aa-527d-3f4e-bba5-8a483fe5ecc6" locEndPos="3" locType="sr" hash="1398926183" locEndLn="65" goals="0," />
    <StdViol msg="Prototype of function 'storePersonToDB' does not precede function definition" ln="10" locFile="/BugDetective/useBeforeInit.c" locStartln="10" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_8_4-a" lnHash="-120518627" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="-120518627" unbViolId="2353affc-ba4d-3afb-a3be-771b0707aca8" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7ed99ca3-55d6-3739-a836-5d5d9191a730" locEndPos="6" locType="sr" hash="-54878936" locEndLn="10" goals="0," />
    <StdViol msg="The function 'storePersonToDB' is referenced only in the translation unit where it is defined" ln="10" locFile="/BugDetective/useBeforeInit.c" locStartln="10" sev="4" auth="root" locRef="13" rule="MISRAC2012-RULE_8_7-a" lnHash="-120518627" rule.header="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" tool="c++test" lineHash="-120518627" unbViolId="dff02624-0030-30f9-a9b9-6e2cf3057786" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="673f785e-27b7-38f3-8506-87789ab1cd2e" locEndPos="6" locType="sr" hash="-54878936" locEndLn="10" goals="0," />
    <StdViol msg="Pass parameter &quot;p&quot; with const specifier" ln="10" locFile="/BugDetective/useBeforeInit.c" locStartln="10" sev="4" auth="root" locRef="13" rule="MISRAC2012-RULE_8_13-a" lnHash="-120518627" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="-120518627" unbViolId="a07572cd-b7c9-3901-9caf-f2b206374486" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="40da0bb9-b851-3828-ad78-89b8abfbd5c6" locEndPos="30" locType="sr" hash="-54878936" locEndLn="10" goals="0," />
    <StdViol msg="Parameter 'p' is not used in function 'storePersonToDB'" ln="10" locFile="/BugDetective/useBeforeInit.c" locStartln="10" sev="4" auth="root" locRef="13" rule="MISRAC2012-RULE_2_7-a" lnHash="-120518627" rule.header="There should be no unused parameters in functions" tool="c++test" lineHash="-120518627" unbViolId="581feff4-e4b5-353c-b7bf-a52f30ff1ecf" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b4a1daaf-390d-3551-9d0d-1375eb98175b" locEndPos="30" locType="sr" hash="-54878936" locEndLn="10" goals="0," />
    <StdViol msg="Prototype of function 'writePersonToFile' does not precede function definition" ln="15" locFile="/BugDetective/useBeforeInit.c" locStartln="15" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_8_4-a" lnHash="1204832453" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="1204832453" unbViolId="1be79799-f513-3d80-9b24-0ea3f899dccc" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="72c3a281-ba08-3668-8960-7908ce41398a" locEndPos="6" locType="sr" hash="-54878936" locEndLn="15" goals="0," />
    <StdViol msg="The names of the identifiers 'person' and 'Person' (line: 7 in the 'dbutil.h' file) differ only in capitalization" ln="15" locFile="/BugDetective/useBeforeInit.c" locStartln="15" sev="4" auth="root" locRef="13" rule="MISRAC2012-DIR_4_5-a" lnHash="1204832453" rule.header="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" tool="c++test" lineHash="1204832453" unbViolId="4f336fe2-52a4-3e0a-b467-bf9b759c7223" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1a15f43d-bf0e-3911-a4a7-ce93c41aaa1e" locEndPos="32" locType="sr" hash="-54878936" locEndLn="15" goals="0," />
    <StdViol msg="Pass parameter &quot;person&quot; with const specifier" ln="15" locFile="/BugDetective/useBeforeInit.c" locStartln="15" sev="4" auth="root" locRef="13" rule="MISRAC2012-RULE_8_13-a" lnHash="1204832453" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="1204832453" unbViolId="1c8964ea-0627-3bf6-b12a-3f70082e33bc" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="879beab6-ce6c-3982-a1d4-3cdf27f6dc4f" locEndPos="32" locType="sr" hash="-54878936" locEndLn="15" goals="0," />
    <StdViol msg="Pass parameter &quot;filename&quot; with const specifier" ln="15" locFile="/BugDetective/useBeforeInit.c" locStartln="15" sev="4" auth="root" locRef="13" rule="MISRAC2012-RULE_8_13-a" lnHash="1204832453" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="1204832453" unbViolId="c14c4592-60b3-33b9-9833-c4d2e2a1e3fd" locStartPos="45" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="06a734ce-a595-3698-b953-6913106603e9" locEndPos="46" locType="sr" hash="-54878936" locEndLn="15" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="18" locFile="/BugDetective/useBeforeInit.c" locStartln="18" sev="4" auth="root" locRef="13" rule="MISRAC2012-DIR_4_6-b" lnHash="943815722" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="943815722" unbViolId="b52d872a-8e79-3ce9-8fc5-27d9cf84f106" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="abea0aa7-6304-36bd-8217-cde584b6c679" locEndPos="5" locType="sr" hash="-54878936" locEndLn="18" goals="0," />
    <StdViol msg="Usage of 'fopen' function is not allowed" ln="19" locFile="/BugDetective/useBeforeInit.c" locStartln="19" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="986280837" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="986280837" unbViolId="56e66948-7fb0-3d21-b512-6aae1ff6cd40" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="29c1ca87-864c-364d-9069-719764e74e4a" locEndPos="12" locType="sr" hash="-54878936" locEndLn="19" goals="0," />
    <StdViol msg="Usage of 'fprintf' function is not allowed" ln="22" locFile="/BugDetective/useBeforeInit.c" locStartln="22" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="-1900966605" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1900966605" unbViolId="9b49e63a-7183-3424-994e-95b98c2b6dd5" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="be1c01ca-cea0-3202-910f-b280b6bb9ca8" locEndPos="37" locType="sr" hash="-54878936" locEndLn="22" goals="0," />
    <StdViol msg="Usage of 'fclose' function is not allowed" ln="24" locFile="/BugDetective/useBeforeInit.c" locStartln="24" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="-632205244" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-632205244" unbViolId="82565b18-9256-3f50-8d9c-80c052905eba" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6ffd51d4-2811-3e22-ba4c-9e30af089b73" locEndPos="9" locType="sr" hash="-54878936" locEndLn="24" goals="0," />
    <StdViol msg="Unused function's &quot;fclose&quot; return value" ln="24" locFile="/BugDetective/useBeforeInit.c" locStartln="24" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_17_7-a" lnHash="-632205244" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-632205244" unbViolId="1bca149f-fa0f-3064-a21e-08c209adde9f" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f845b0b2-24d0-3662-b96d-6b9cc252293c" locEndPos="9" locType="sr" hash="-54878936" locEndLn="24" goals="0," />
    <FlowViol msg="&quot;numberOfCharactersPrinted&quot; is used prior to initialization" ln="27" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Usage point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="19" rule="MISRAC2012-RULE_1_3-b" FirstElSrcRngStartPos="0" lnHash="-1547729396" ruleSCSCMsg="Source of not initialized value" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Avoid use before initialization" FirstElSrcRngStartln="18" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="2060208960" lang="cpp" violId="2dcaa8de-c073-33e9-9d0a-d4ecab27401f" locEndPos="0" locEndLn="28" goals="0," locStartln="27" sev="2" locRef="13" tool="c++test" lineHash="-1547729396" unbViolId="0c97b0e8-b2fc-3afe-b5fb-7b742d2f3348" locType="sr" hash="-54878936" causeLocRef="13">
      <Props>
        <Prop key="Tracked variables" val="Not initialized value" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-1954950279" ln="17" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="17" srcRngEndLn="18" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="17" />
        <ElDesc lineHash="943815722" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/useBeforeInit.c" desc="int numberOfCharactersPrinted;" ElType=".C" rngLn="18">
          <Props>
            <Prop key="Tracked variables" val="numberOfCharactersPrinted" />
          </Props>
          <Anns>
            <Ann msg="Source of not initialized value" kind="cause" />
            <Ann msg="Not initialized value: numberOfCharactersPrinted" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="986280837" ln="19" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="19" srcRngEndLn="20" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;w&quot;);" ElType="." rngLn="19" />
        <ElDesc lineHash="1027984352" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="21">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1547729396" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/useBeforeInit.c" desc="printf(&quot;File length: %d\n&quot;, numberOfCharactersPrinted);" ElType=".P" rngLn="27">
          <Props>
            <Prop key="Tracked variables" val="numberOfCharactersPrinted" />
          </Props>
          <Anns>
            <Ann msg="Not initialized value: numberOfCharactersPrinted" kind="var" />
            <Ann msg="Usage point" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;numberOfCharactersPrinted&quot; is used prior to initialization" ln="27" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Usage point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="19" rule="MISRAC2012-RULE_9_1-a" FirstElSrcRngStartPos="0" lnHash="-1547729396" ruleSCSCMsg="Source of not initialized value" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Avoid use before initialization" FirstElSrcRngStartln="18" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="2069690053" lang="cpp" violId="7c930084-2c77-3b75-8571-6f36accf829b" locEndPos="0" locEndLn="28" goals="0," locStartln="27" sev="1" locRef="13" tool="c++test" lineHash="-1547729396" unbViolId="791c5e5f-eee1-3869-a479-41d57cc39620" locType="sr" hash="-54878936" causeLocRef="13">
      <Props>
        <Prop key="Tracked variables" val="Not initialized value" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="-1954950279" ln="17" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="17" srcRngEndLn="18" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="17" />
        <ElDesc lineHash="943815722" ln="18" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="18" srcRngEndLn="19" srcRngFile="/BugDetective/useBeforeInit.c" desc="int numberOfCharactersPrinted;" ElType=".C" rngLn="18">
          <Props>
            <Prop key="Tracked variables" val="numberOfCharactersPrinted" />
          </Props>
          <Anns>
            <Ann msg="Source of not initialized value" kind="cause" />
            <Ann msg="Not initialized value: numberOfCharactersPrinted" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="986280837" ln="19" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="19" srcRngEndLn="20" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;w&quot;);" ElType="." rngLn="19" />
        <ElDesc lineHash="1027984352" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="21">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1547729396" ln="27" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="27" srcRngEndLn="28" srcRngFile="/BugDetective/useBeforeInit.c" desc="printf(&quot;File length: %d\n&quot;, numberOfCharactersPrinted);" ElType=".P" rngLn="27">
          <Props>
            <Prop key="Tracked variables" val="numberOfCharactersPrinted" />
          </Props>
          <Anns>
            <Ann msg="Not initialized value: numberOfCharactersPrinted" kind="var" />
            <Ann msg="Usage point" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'printf' function is not allowed" ln="27" locFile="/BugDetective/useBeforeInit.c" locStartln="27" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="-1547729396" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1547729396" unbViolId="639ebdae-1934-3139-994a-c2d9eae16f5a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d380eaf3-cf27-361e-807a-5af1aaafc3df" locEndPos="5" locType="sr" hash="-54878936" locEndLn="27" goals="0," />
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="27" locFile="/BugDetective/useBeforeInit.c" locStartln="27" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_17_7-a" lnHash="-1547729396" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1547729396" unbViolId="300f59a0-4a31-368e-b8a5-f247c58d85f9" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d1ff547b-330d-34c4-b04e-c84b5784d3ba" locEndPos="5" locType="sr" hash="-54878936" locEndLn="27" goals="0," />
    <StdViol msg="Prototype of function 'copyPersonFromFileToDB' does not precede function definition" ln="30" locFile="/BugDetective/useBeforeInit.c" locStartln="30" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_8_4-a" lnHash="407946307" rule.header="A declaration shall be visible when an object or function with external linkage is defined" tool="c++test" lineHash="407946307" unbViolId="a1f5d402-9b0f-34fb-a9c1-5077fc4f7bee" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6e2aad6a-65a2-3e71-a05c-c80e95a8042c" locEndPos="6" locType="sr" hash="-54878936" locEndLn="30" goals="0," />
    <StdViol msg="Pass parameter &quot;filename&quot; with const specifier" ln="30" locFile="/BugDetective/useBeforeInit.c" locStartln="30" sev="4" auth="root" locRef="13" rule="MISRAC2012-RULE_8_13-a" lnHash="407946307" rule.header="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" tool="c++test" lineHash="407946307" unbViolId="67f964e9-a492-316f-89cc-596c086e070f" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f06e8d7d-9259-3115-8463-a758945cf762" locEndPos="35" locType="sr" hash="-54878936" locEndLn="30" goals="0," />
    <StdViol msg="Usage of 'fopen' function is not allowed" ln="34" locFile="/BugDetective/useBeforeInit.c" locStartln="34" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="986131882" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="986131882" unbViolId="d8fb49fe-8523-3b4c-be2a-69b4c7338def" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0616a8b3-fc54-356d-836b-02c36cd29b0d" locEndPos="12" locType="sr" hash="-54878936" locEndLn="34" goals="0," />
    <StdViol msg="Pointer to void type should not be converted to pointer to object type 'Person *'" ln="39" locFile="/BugDetective/useBeforeInit.c" locStartln="39" sev="4" auth="root" locRef="13" rule="MISRAC2012-RULE_11_5-a" lnHash="1433650083" rule.header="A conversion should not be performed from pointer to void into pointer to object" tool="c++test" lineHash="1433650083" unbViolId="a34c6400-34b8-35ec-83a8-b80e0483b10b" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="692addcd-1fec-3f14-8d54-fe167cab6e10" locEndPos="9" locType="sr" hash="-54878936" locEndLn="39" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="39" locFile="/BugDetective/useBeforeInit.c" locStartln="39" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_3-a" lnHash="1433650083" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1433650083" unbViolId="d40cb43b-e803-354b-89dc-4ccb8f1c0a7d" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7dd33f3-569b-3e54-8d99-9f9fa3d27432" locEndPos="13" locType="sr" hash="-54878936" locEndLn="39" goals="0," />
    <StdViol msg="'malloc' function should not be used" ln="39" locFile="/BugDetective/useBeforeInit.c" locStartln="39" sev="2" auth="root" locRef="13" rule="MISRAC2012-DIR_4_12-a" lnHash="1433650083" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1433650083" unbViolId="0708e0d6-6bd8-3974-9020-24c329da734a" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c578fa9d-a67d-396a-90dc-e1eba4517ea3" locEndPos="13" locType="sr" hash="-54878936" locEndLn="39" goals="0," />
    <FlowViol msg="File not closed: file" ln="40" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Point where opened file is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="35" rule="MISRAC2012-RULE_22_1-a" FirstElSrcRngStartPos="0" lnHash="-321328779" ruleSCSCMsg="Point where file is opened" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="34" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1991957079" lang="cpp" violId="682e43d6-ed44-3c53-96a2-58f12af658b2" locEndPos="0" locEndLn="41" goals="0," locStartln="40" sev="2" locRef="13" tool="c++test" lineHash="-321328779" unbViolId="f1eefdd5-8b4b-3814-a1aa-ae2fe993ba2b" locType="sr" hash="-54878936" causeLocRef="13">
      <Props>
        <Prop key="Tracked variables" val="Opened file" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1041656438" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/useBeforeInit.c" desc="Person* p;" ElType="." rngLn="32" />
        <ElDesc lineHash="-1954950279" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="33" />
        <ElDesc lineHash="986131882" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;r&quot;);" ElType=".C" rngLn="34">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Point where file is opened" kind="cause" />
            <Ann msg="Opened file: file" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1027984352" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="35">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming true)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="905762227" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/useBeforeInit.c" desc="char id[10];" ElType="." rngLn="36" />
        <ElDesc lineHash="-170681591" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/useBeforeInit.c" desc="char name[100];" ElType="." rngLn="37" />
        <ElDesc lineHash="-483460585" ln="38" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="38" srcRngEndLn="39" srcRngFile="/BugDetective/useBeforeInit.c" desc="char reference[1000];" ElType="." rngLn="38" />
        <ElDesc lineHash="1433650083" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/useBeforeInit.c" desc="p = malloc(sizeof(Person));" ElType="." rngLn="39" />
        <ElDesc lineHash="-321328779" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/useBeforeInit.c" desc="exit(...)" ElType=".P" rngLn="40">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Opened file: file" kind="var" />
            <Ann msg="Point where opened file is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="File not closed: file" ln="40" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Point where opened file is lost" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="35" rule="MISRAC2012-DIR_4_13-a" FirstElSrcRngStartPos="0" lnHash="-321328779" ruleSCSCMsg="Point where file is opened" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Ensure resources are freed" FirstElSrcRngStartln="34" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1991957079" lang="cpp" violId="73d83cd6-3f9e-370c-9246-cb6d15187214" locEndPos="0" locEndLn="41" goals="0," locStartln="40" sev="4" locRef="13" tool="c++test" lineHash="-321328779" unbViolId="c6163c51-b9cd-35c5-ac80-8640b0d50f94" locType="sr" hash="-54878936" causeLocRef="13">
      <Props>
        <Prop key="Tracked variables" val="Opened file" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1041656438" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/useBeforeInit.c" desc="Person* p;" ElType="." rngLn="32" />
        <ElDesc lineHash="-1954950279" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="33" />
        <ElDesc lineHash="986131882" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;r&quot;);" ElType=".C" rngLn="34">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Point where file is opened" kind="cause" />
            <Ann msg="Opened file: file" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="1027984352" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="35">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming true)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="905762227" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/useBeforeInit.c" desc="char id[10];" ElType="." rngLn="36" />
        <ElDesc lineHash="-170681591" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/useBeforeInit.c" desc="char name[100];" ElType="." rngLn="37" />
        <ElDesc lineHash="-483460585" ln="38" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="38" srcRngEndLn="39" srcRngFile="/BugDetective/useBeforeInit.c" desc="char reference[1000];" ElType="." rngLn="38" />
        <ElDesc lineHash="1433650083" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/useBeforeInit.c" desc="p = malloc(sizeof(Person));" ElType="." rngLn="39" />
        <ElDesc lineHash="-321328779" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/useBeforeInit.c" desc="exit(...)" ElType=".P" rngLn="40">
          <Props>
            <Prop key="Tracked variables" val="file" />
          </Props>
          <Anns>
            <Ann msg="Opened file: file" kind="var" />
            <Ann msg="Point where opened file is lost" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Conditional statement 'if' in a function 'copyPersonFromFileToDB' should be followed by a block" ln="40" locFile="/BugDetective/useBeforeInit.c" locStartln="40" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_15_6-b" lnHash="-321328779" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-321328779" unbViolId="38f1222e-be0e-3e85-8d74-9135c083dd98" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a2ddfebc-341c-3897-9abc-e1f5adefe43c" locEndPos="9" locType="sr" hash="-54878936" locEndLn="40" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="40" locFile="/BugDetective/useBeforeInit.c" locStartln="40" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_11_9-a" lnHash="-321328779" rule.header="Literal zero (0) shall not be used as the null-pointer-constant" tool="c++test" lineHash="-321328779" unbViolId="c664d99d-7b4f-3379-8cad-45e06a76ab4a" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="366b7023-124a-3dc1-be0e-a6daf244553f" locEndPos="18" locType="sr" hash="-54878936" locEndLn="40" goals="0," />
    <StdViol msg="Expression of pointer type is compared with '0'" ln="40" locFile="/BugDetective/useBeforeInit.c" locStartln="40" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_11_9-b" lnHash="-321328779" rule.header="Use NULL instead of literal zero (0) as the null-pointer-constant" tool="c++test" lineHash="-321328779" unbViolId="f3ad729c-6ccf-3870-8ca9-85611a21c627" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9c781d9a-df28-30fc-8194-5bf4ce41725f" locEndPos="18" locType="sr" hash="-54878936" locEndLn="40" goals="0," />
    <StdViol msg="Function 'exit' should be called at the end of the 'copyPersonFromFileToDB' function" ln="40" locFile="/BugDetective/useBeforeInit.c" locStartln="40" sev="4" auth="root" locRef="13" rule="MISRAC2012-RULE_15_5-a" lnHash="-321328779" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-321328779" unbViolId="a064f10e-3716-37c8-b14e-3c425f0df54b" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0418a139-487b-322e-b578-1f8ce8830ee5" locEndPos="21" locType="sr" hash="-54878936" locEndLn="40" goals="0," />
    <StdViol msg="The 'exit' library function should not be used" ln="40" locFile="/BugDetective/useBeforeInit.c" locStartln="40" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_8-b" lnHash="-321328779" rule.header="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" tool="c++test" lineHash="-321328779" unbViolId="c7fb490f-81f9-3153-a7fe-8ed085baec12" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="860f46d4-8d4d-31cd-8b40-481aa23ff7b5" locEndPos="21" locType="sr" hash="-54878936" locEndLn="40" goals="0," />
    <FlowViol msg="Value returned from method &quot;fgets&quot; should be checked" ln="41" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Point by which returned value should be checked" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="42" rule="MISRAC2012-DIR_4_7-b" FirstElSrcRngStartPos="0" lnHash="733807829" ruleSCSCMsg="Method call" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Always check the returned value of non-void function" FirstElSrcRngStartln="41" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1482391288" lang="cpp" violId="4488143a-4e2c-3dbf-8313-256acc93fffe" locEndPos="0" locEndLn="42" goals="0," locStartln="41" sev="2" locRef="13" tool="c++test" lineHash="733807829" unbViolId="5ad2ddb3-b0ac-3b3e-95ed-b7688fc161df" locType="sr" hash="-54878936" causeLocRef="13">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1041656438" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/useBeforeInit.c" desc="Person* p;" ElType="." rngLn="32" />
        <ElDesc lineHash="-1954950279" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="33" />
        <ElDesc lineHash="986131882" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;r&quot;);" ElType="." rngLn="34" />
        <ElDesc lineHash="1027984352" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="35">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming true)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="905762227" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/useBeforeInit.c" desc="char id[10];" ElType="." rngLn="36" />
        <ElDesc lineHash="-170681591" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/useBeforeInit.c" desc="char name[100];" ElType="." rngLn="37" />
        <ElDesc lineHash="-483460585" ln="38" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="38" srcRngEndLn="39" srcRngFile="/BugDetective/useBeforeInit.c" desc="char reference[1000];" ElType="." rngLn="38" />
        <ElDesc lineHash="1433650083" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/useBeforeInit.c" desc="p = malloc(sizeof(Person));" ElType="." rngLn="39" />
        <ElDesc lineHash="-321328779" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (p == 0) exit(1);" ElType="." rngLn="40">
          <Anns>
            <Ann msg="Condition evaluation: (p == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="733807829" ln="41" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="41" srcRngEndLn="42" srcRngFile="/BugDetective/useBeforeInit.c" desc="fgets(id, 10, file);" ElType="CP" rngLn="41">
          <Anns>
            <Ann msg="Method call" kind="cause" />
            <Ann msg="Point by which returned value should be checked" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'fgets' function is not allowed" ln="41" locFile="/BugDetective/useBeforeInit.c" locStartln="41" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="733807829" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="733807829" unbViolId="cd78ea2d-186c-342a-b86c-3658ed49053f" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1eb5f5d6-8625-3c40-9f25-03272925ec3c" locEndPos="9" locType="sr" hash="-54878936" locEndLn="41" goals="0," />
    <StdViol msg="Unused function's &quot;fgets&quot; return value" ln="41" locFile="/BugDetective/useBeforeInit.c" locStartln="41" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_17_7-a" lnHash="733807829" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="733807829" unbViolId="7d2b6dea-312d-35f5-923f-1daa265838b6" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ef600026-6da4-3d7e-9550-339206c2d422" locEndPos="9" locType="sr" hash="-54878936" locEndLn="41" goals="0," />
    <StdViol msg="Usage of 'atoi' function is not allowed" ln="42" locFile="/BugDetective/useBeforeInit.c" locStartln="42" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_7-a" lnHash="1253528737" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="1253528737" unbViolId="a40cdf70-365f-35ad-92ea-e7fd277c70eb" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="52e24ed7-0dc6-37de-9004-d7c0a3911183" locEndPos="25" locType="sr" hash="-54878936" locEndLn="42" goals="0," />
    <FlowViol msg="Value returned from method &quot;fgets&quot; should be checked" ln="43" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Point by which returned value should be checked" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="44" rule="MISRAC2012-DIR_4_7-b" FirstElSrcRngStartPos="0" lnHash="-726318129" ruleSCSCMsg="Method call" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Always check the returned value of non-void function" FirstElSrcRngStartln="43" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1678578016" lang="cpp" violId="b16be861-eb03-3bb8-a648-f973326b1b0f" locEndPos="0" locEndLn="44" goals="0," locStartln="43" sev="2" locRef="13" tool="c++test" lineHash="-726318129" unbViolId="b8b00ada-806d-3081-a6ed-0be4a8d7894c" locType="sr" hash="-54878936" causeLocRef="13">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1041656438" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/useBeforeInit.c" desc="Person* p;" ElType="." rngLn="32" />
        <ElDesc lineHash="-1954950279" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="33" />
        <ElDesc lineHash="986131882" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;r&quot;);" ElType="." rngLn="34" />
        <ElDesc lineHash="1027984352" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="35">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming true)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="905762227" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/useBeforeInit.c" desc="char id[10];" ElType="." rngLn="36" />
        <ElDesc lineHash="-170681591" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/useBeforeInit.c" desc="char name[100];" ElType="." rngLn="37" />
        <ElDesc lineHash="-483460585" ln="38" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="38" srcRngEndLn="39" srcRngFile="/BugDetective/useBeforeInit.c" desc="char reference[1000];" ElType="." rngLn="38" />
        <ElDesc lineHash="1433650083" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/useBeforeInit.c" desc="p = malloc(sizeof(Person));" ElType="." rngLn="39" />
        <ElDesc lineHash="-321328779" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (p == 0) exit(1);" ElType="." rngLn="40">
          <Anns>
            <Ann msg="Condition evaluation: (p == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="733807829" ln="41" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="41" srcRngEndLn="42" srcRngFile="/BugDetective/useBeforeInit.c" desc="fgets(id, 10, file);" ElType="." rngLn="41" />
        <ElDesc lineHash="1253528737" ln="42" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="42" srcRngEndLn="43" srcRngFile="/BugDetective/useBeforeInit.c" desc="p->personalId = atoi(id);" ElType="." rngLn="42" />
        <ElDesc lineHash="-726318129" ln="43" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="43" srcRngEndLn="44" srcRngFile="/BugDetective/useBeforeInit.c" desc="fgets(name, 100, file);" ElType="CP" rngLn="43">
          <Anns>
            <Ann msg="Method call" kind="cause" />
            <Ann msg="Point by which returned value should be checked" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'fgets' function is not allowed" ln="43" locFile="/BugDetective/useBeforeInit.c" locStartln="43" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="-726318129" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-726318129" unbViolId="d0d37fee-505d-3f02-b19c-8766d6feaec7" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f975269-0486-3f7d-bbe9-cb0eec44faae" locEndPos="9" locType="sr" hash="-54878936" locEndLn="43" goals="0," />
    <StdViol msg="Unused function's &quot;fgets&quot; return value" ln="43" locFile="/BugDetective/useBeforeInit.c" locStartln="43" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_17_7-a" lnHash="-726318129" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-726318129" unbViolId="ffeb4cf6-d80c-36a9-850a-5e867973b16c" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d5855e1d-4b56-3daa-be15-5f9f50381fa0" locEndPos="9" locType="sr" hash="-54878936" locEndLn="43" goals="0," />
    <FlowViol msg="Value returned from method &quot;fgets&quot; should be checked" ln="45" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Point by which returned value should be checked" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="46" rule="MISRAC2012-DIR_4_7-b" FirstElSrcRngStartPos="0" lnHash="-1026068167" ruleSCSCMsg="Method call" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Always check the returned value of non-void function" FirstElSrcRngStartln="45" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-2100132604" lang="cpp" violId="2c0e6c71-a15f-3a8a-a07a-88b4979994a7" locEndPos="0" locEndLn="46" goals="0," locStartln="45" sev="2" locRef="13" tool="c++test" lineHash="-1026068167" unbViolId="59f5548a-1116-304e-aae5-3af426848261" locType="sr" hash="-54878936" causeLocRef="13">
      <Props />
      <ElDescList>
        <ElDesc lineHash="1041656438" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/useBeforeInit.c" desc="Person* p;" ElType="." rngLn="32" />
        <ElDesc lineHash="-1954950279" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="33" />
        <ElDesc lineHash="986131882" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;r&quot;);" ElType="." rngLn="34" />
        <ElDesc lineHash="1027984352" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="35">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming true)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="905762227" ln="36" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="36" srcRngEndLn="37" srcRngFile="/BugDetective/useBeforeInit.c" desc="char id[10];" ElType="." rngLn="36" />
        <ElDesc lineHash="-170681591" ln="37" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="37" srcRngEndLn="38" srcRngFile="/BugDetective/useBeforeInit.c" desc="char name[100];" ElType="." rngLn="37" />
        <ElDesc lineHash="-483460585" ln="38" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="38" srcRngEndLn="39" srcRngFile="/BugDetective/useBeforeInit.c" desc="char reference[1000];" ElType="." rngLn="38" />
        <ElDesc lineHash="1433650083" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/BugDetective/useBeforeInit.c" desc="p = malloc(sizeof(Person));" ElType="." rngLn="39" />
        <ElDesc lineHash="-321328779" ln="40" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="40" srcRngEndLn="41" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (p == 0) exit(1);" ElType="." rngLn="40">
          <Anns>
            <Ann msg="Condition evaluation: (p == 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="733807829" ln="41" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="41" srcRngEndLn="42" srcRngFile="/BugDetective/useBeforeInit.c" desc="fgets(id, 10, file);" ElType="." rngLn="41" />
        <ElDesc lineHash="1253528737" ln="42" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="42" srcRngEndLn="43" srcRngFile="/BugDetective/useBeforeInit.c" desc="p->personalId = atoi(id);" ElType="." rngLn="42" />
        <ElDesc lineHash="-726318129" ln="43" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="43" srcRngEndLn="44" srcRngFile="/BugDetective/useBeforeInit.c" desc="fgets(name, 100, file);" ElType="." rngLn="43" />
        <ElDesc lineHash="68474233" ln="44" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="44" srcRngEndLn="45" srcRngFile="/BugDetective/useBeforeInit.c" desc="p->name = name;" ElType="." rngLn="44" />
        <ElDesc lineHash="-1026068167" ln="45" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="45" srcRngEndLn="46" srcRngFile="/BugDetective/useBeforeInit.c" desc="fgets(reference, 100, file);" ElType="CP" rngLn="45">
          <Anns>
            <Ann msg="Method call" kind="cause" />
            <Ann msg="Point by which returned value should be checked" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Usage of 'fgets' function is not allowed" ln="45" locFile="/BugDetective/useBeforeInit.c" locStartln="45" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="-1026068167" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1026068167" unbViolId="df07368a-05a9-3c26-be38-7825934ed3ab" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9ba51db7-e3fe-3cdd-b501-38ceb35421bd" locEndPos="9" locType="sr" hash="-54878936" locEndLn="45" goals="0," />
    <StdViol msg="Unused function's &quot;fgets&quot; return value" ln="45" locFile="/BugDetective/useBeforeInit.c" locStartln="45" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_17_7-a" lnHash="-1026068167" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1026068167" unbViolId="17b28955-6bcc-3609-9617-ae6523e18e03" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="454008a7-f380-3e49-9a2d-b0954736c2ae" locEndPos="9" locType="sr" hash="-54878936" locEndLn="45" goals="0," />
    <StdViol msg="Usage of 'fclose' function is not allowed" ln="48" locFile="/BugDetective/useBeforeInit.c" locStartln="48" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_6-a" lnHash="-632205244" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-632205244" unbViolId="6e705964-8a87-3733-8aa0-f530fecd420c" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e44df738-49f5-313d-a4fd-311b36b0bb46" locEndPos="9" locType="sr" hash="-54878936" locEndLn="48" goals="0," />
    <StdViol msg="Unused function's &quot;fclose&quot; return value" ln="48" locFile="/BugDetective/useBeforeInit.c" locStartln="48" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_17_7-a" lnHash="-632205244" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-632205244" unbViolId="751a9e60-865e-328d-ace1-fcb0273fc196" locStartPos="8" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c0c21f39-8d47-30be-9400-8cf143abe5e3" locEndPos="9" locType="sr" hash="-54878936" locEndLn="48" goals="0," />
    <FlowViol msg="&quot;p&quot; is used prior to initialization" ln="51" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Usage point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="33" rule="MISRAC2012-RULE_1_3-b" FirstElSrcRngStartPos="0" lnHash="1220665574" ruleSCSCMsg="Source of not initialized value" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Avoid use before initialization" FirstElSrcRngStartln="32" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1888625583" lang="cpp" violId="7fba30b1-78e2-36ff-8080-2fdf066d7a88" locEndPos="0" locEndLn="52" goals="0," locStartln="51" sev="2" locRef="13" tool="c++test" lineHash="1220665574" unbViolId="960e700a-2491-3a4f-9e11-c251cd978e5c" locType="sr" hash="-54878936" causeLocRef="13">
      <Props>
        <Prop key="Tracked variables" val="Not initialized value" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1041656438" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/useBeforeInit.c" desc="Person* p;" ElType=".C" rngLn="32">
          <Props>
            <Prop key="Tracked variables" val="p" />
          </Props>
          <Anns>
            <Ann msg="Source of not initialized value" kind="cause" />
            <Ann msg="Not initialized value: p" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1954950279" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="33" />
        <ElDesc lineHash="986131882" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;r&quot;);" ElType="." rngLn="34" />
        <ElDesc lineHash="1027984352" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="35">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="295924201" ln="50" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="50" srcRngEndLn="51" srcRngFile="/BugDetective/useBeforeInit.c" desc="storePersonToDB(p);" ElType="." rngLn="50" />
        <ElDesc lineHash="1220665574" ln="51" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="51" srcRngEndLn="52" srcRngFile="/BugDetective/useBeforeInit.c" desc="free(p);" ElType=".P" rngLn="51">
          <Props>
            <Prop key="Tracked variables" val="p" />
          </Props>
          <Anns>
            <Ann msg="Not initialized value: p" kind="var" />
            <Ann msg="Usage point" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="&quot;p&quot; is used prior to initialization" ln="51" locFile="/BugDetective/useBeforeInit.c" ruleSAFMsg="Usage point" FirstElSrcRngEndPos="0" auth="root" FirstElSrcRngEndLn="33" rule="MISRAC2012-RULE_9_1-a" FirstElSrcRngStartPos="0" lnHash="1220665574" ruleSCSCMsg="Source of not initialized value" FirstElSrcRngFile="/BugDetective/useBeforeInit.c" rule.header="Avoid use before initialization" FirstElSrcRngStartln="32" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1895996972" lang="cpp" violId="a3a89db4-3fe3-35e4-8ce4-acbcbbd808e8" locEndPos="0" locEndLn="52" goals="0," locStartln="51" sev="1" locRef="13" tool="c++test" lineHash="1220665574" unbViolId="e1e581e6-3a61-3609-94c5-5b91a796accb" locType="sr" hash="-54878936" causeLocRef="13">
      <Props>
        <Prop key="Tracked variables" val="Not initialized value" />
      </Props>
      <ElDescList>
        <ElDesc lineHash="1041656438" ln="32" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="32" srcRngEndLn="33" srcRngFile="/BugDetective/useBeforeInit.c" desc="Person* p;" ElType=".C" rngLn="32">
          <Props>
            <Prop key="Tracked variables" val="p" />
          </Props>
          <Anns>
            <Ann msg="Source of not initialized value" kind="cause" />
            <Ann msg="Not initialized value: p" kind="var" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-1954950279" ln="33" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="33" srcRngEndLn="34" srcRngFile="/BugDetective/useBeforeInit.c" desc="FILE *file;" ElType="." rngLn="33" />
        <ElDesc lineHash="986131882" ln="34" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="34" srcRngEndLn="35" srcRngFile="/BugDetective/useBeforeInit.c" desc="file = fopen(filename, &quot;r&quot;);" ElType="." rngLn="34" />
        <ElDesc lineHash="1027984352" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/BugDetective/useBeforeInit.c" desc="if (file!=NULL) {" ElType="." rngLn="35">
          <Anns>
            <Ann msg="Condition evaluation: (file != 0) (assuming false)" kind="condEval" />
          </Anns>
        </ElDesc>
        <ElDesc lineHash="295924201" ln="50" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="50" srcRngEndLn="51" srcRngFile="/BugDetective/useBeforeInit.c" desc="storePersonToDB(p);" ElType="." rngLn="50" />
        <ElDesc lineHash="1220665574" ln="51" srcRngStartPos="0" srcRngEndPos="0" locRef="13" locType="sr" srcRnghash="-54878936" srcRngStartln="51" srcRngEndLn="52" srcRngFile="/BugDetective/useBeforeInit.c" desc="free(p);" ElType=".P" rngLn="51">
          <Props>
            <Prop key="Tracked variables" val="p" />
          </Props>
          <Anns>
            <Ann msg="Not initialized value: p" kind="var" />
            <Ann msg="Usage point" kind="point" />
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="'free' function should not be used" ln="51" locFile="/BugDetective/useBeforeInit.c" locStartln="51" sev="2" auth="root" locRef="13" rule="MISRAC2012-RULE_21_3-a" lnHash="1220665574" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1220665574" unbViolId="5bdcee29-4b56-30e1-a018-2f68a4fc33cd" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="867964fb-0e0c-3350-8284-9aa43722dbfe" locEndPos="5" locType="sr" hash="-54878936" locEndLn="51" goals="0," />
    <StdViol msg="'free' function should not be used" ln="51" locFile="/BugDetective/useBeforeInit.c" locStartln="51" sev="2" auth="root" locRef="13" rule="MISRAC2012-DIR_4_12-a" lnHash="1220665574" rule.header="Dynamic heap memory allocation shall not be used" tool="c++test" lineHash="1220665574" unbViolId="2308dcce-b720-331b-a71d-6b9f8c23f8a0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b0da3ed2-e9d3-3371-8f23-e829b8f182ea" locEndPos="5" locType="sr" hash="-54878936" locEndLn="51" goals="0," />
    <StdViol msg="Multiple include guard should appear as first #ifndef or #if preprocessor directive" ln="1" locFile="/BugDetective/dbutil.h" locStartln="1" sev="2" auth="root" locRef="14" rule="MISRAC2012-DIR_4_10-a" lnHash="-1331786010" rule.header="Use multiple include guards" tool="c++test" lineHash="-1331786010" unbViolId="63bf7f07-1296-373f-8cad-d1659c5825db" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="328661c6-8a60-37d2-8eba-c0e3d8753dc3" locEndPos="1" locType="sr" urgent="true" hash="-390129458" locEndLn="1" goals="1," />
    <StdViol msg="Consider hiding the implementation of the structure 'Person' in a translation unit 'arrayOutOfBounds.c'" ln="1" locFile="/BugDetective/dbutil.h" locStartln="1" sev="4" auth="root" locRef="14" rule="MISRAC2012-DIR_4_8-a" lnHash="-1331786010" rule.header="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" tool="c++test" lineHash="-1331786010" unbViolId="bb6096af-f6b2-32bd-a1d9-b8d537583bc1" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="739b61f8-b3c5-356a-84f2-0da72e236d4e" locEndPos="16" locType="sr" urgent="true" hash="-390129458" locEndLn="1" goals="1," />
    <StdViol msg="Typedef names shall not be reused: Person" ln="1" locFile="/BugDetective/dbutil.h" locStartln="1" sev="2" auth="root" locRef="14" rule="MISRAC2012-RULE_5_6-a" lnHash="-1331786010" rule.header="Do not reuse typedef names" tool="c++test" lineHash="-1331786010" unbViolId="cf122418-17f0-3e4c-82b4-7792cb5c4e7a" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="769bdcc3-46c7-3252-85e7-713d7a1519aa" locEndPos="16" locType="sr" urgent="true" hash="-390129458" locEndLn="1" goals="1," />
    <StdViol msg="Consider hiding the implementation of the structure 'Person' in a translation unit 'fileLeaks.c'" ln="1" locFile="/BugDetective/dbutil.h" locStartln="1" sev="4" auth="root" locRef="14" rule="MISRAC2012-DIR_4_8-a" lnHash="-1331786010" rule.header="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" tool="c++test" lineHash="-1331786010" unbViolId="4a8c8858-da96-35b7-a331-95271f0d31b9" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="232cc72f-6ada-36c8-8beb-fdbfa8fd819e" locEndPos="16" locType="sr" hash="-390129458" locEndLn="1" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="3" locFile="/BugDetective/dbutil.h" locStartln="3" sev="4" auth="root" locRef="14" rule="MISRAC2012-DIR_4_6-b" lnHash="1738087791" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1738087791" unbViolId="a361334b-e588-305a-9ae5-227f60cfc58c" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2d599a5e-5a12-3190-980e-5553e49bf210" locEndPos="5" locType="sr" urgent="true" hash="-390129458" locEndLn="3" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="5" locFile="/BugDetective/dbutil.h" locStartln="5" sev="4" auth="root" locRef="14" rule="MISRAC2012-DIR_4_6-b" lnHash="-514704256" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-514704256" unbViolId="cbf45051-bb4d-32e9-9878-599d374ac5da" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="64079cd9-8531-3f17-88be-751dcaee05f2" locEndPos="5" locType="sr" urgent="true" hash="-390129458" locEndLn="5" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="6" locFile="/BugDetective/dbutil.h" locStartln="6" sev="4" auth="root" locRef="14" rule="MISRAC2012-DIR_4_6-b" lnHash="-333446744" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-333446744" unbViolId="b248503b-b911-35b3-8253-36e6f9dc9e3c" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ff88c10b-df6e-3386-865a-8d4c52185b41" locEndPos="5" locType="sr" urgent="true" hash="-390129458" locEndLn="6" goals="1," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" locFile="/BugDetective/dbutil.h" locStartln="9" sev="4" auth="root" locRef="14" rule="MISRAC2012-DIR_4_6-b" lnHash="-1090727390" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="-1090727390" unbViolId="e5efffb3-113e-3420-9744-3e1cc4a638f0" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bea79799-2caf-321f-a3e4-abd8a7304eef" locEndPos="30" locType="sr" urgent="true" hash="-390129458" locEndLn="9" goals="1," />
    <StdViol msg="More than 509 characters in a logical source line: 548" ln="4" locFile="/BugDetective/socket.h" locStartln="4" sev="2" auth="root" locRef="15" rule="MISRAC2012-RULE_1_1-c" lnHash="1919496450" rule.header="A program should not exceed the translation limits imposed by The Standard (c90)" tool="c++test" lineHash="1919496450" unbViolId="325089da-36b7-3834-8033-07698b6d2d83" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d34d203b-d987-3df8-b1a3-6a3c6699ede8" locEndPos="1" locType="sr" hash="-1106475955" locEndLn="4" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="6" locFile="/BugDetective/socket.h" locStartln="6" sev="4" auth="root" locRef="15" rule="MISRAC2012-DIR_4_6-b" lnHash="38877241" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="38877241" unbViolId="862bd3a5-4aad-3793-b973-0368e7ef8c19" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b0281d68-031d-3e8e-a947-f1f55ef93085" locEndPos="10" locType="sr" hash="-1106475955" locEndLn="6" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="6" locFile="/BugDetective/socket.h" locStartln="6" sev="4" auth="root" locRef="15" rule="MISRAC2012-DIR_4_6-b" lnHash="38877241" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="38877241" unbViolId="1e68325a-732a-3451-9814-8279596a3eb2" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="84c1a1cc-247d-358d-a8b1-c9e1e0570b2c" locEndPos="19" locType="sr" hash="-1106475955" locEndLn="6" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="6" locFile="/BugDetective/socket.h" locStartln="6" sev="4" auth="root" locRef="15" rule="MISRAC2012-DIR_4_6-b" lnHash="38877241" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="38877241" unbViolId="47646955-f13a-30d4-a451-90f6ab577110" locStartPos="45" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="32103173-cb26-3faa-87e4-4ca995e2940d" locEndPos="46" locType="sr" hash="-1106475955" locEndLn="6" goals="0," />
    <StdViol msg="The basic numerical type 'int' should not be used" ln="6" locFile="/BugDetective/socket.h" locStartln="6" sev="4" auth="root" locRef="15" rule="MISRAC2012-DIR_4_6-b" lnHash="38877241" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="38877241" unbViolId="7d04d96b-acc7-356f-9f7b-6bc1e6224421" locStartPos="54" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92afc1eb-45ef-30f1-a05e-4f5088d9f76e" locEndPos="55" locType="sr" hash="-1106475955" locEndLn="6" goals="0," />
    <StdViol msg="#include statements are not grouped properly. This is the last #include in file. Some statements are in line 6" ln="14" locFile="/BugDetective/socket.h" locStartln="14" sev="4" auth="root" locRef="15" rule="MISRAC2012-RULE_20_1-a" lnHash="-258085874" rule.header="#include statements in a file should only be preceded by other preprocessor directives or comments" tool="c++test" lineHash="-258085874" unbViolId="2912874e-1af6-3bed-ab26-6a8053f37c6b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5fbbba46-1a4b-3452-b12c-593bad46295f" locEndPos="1" locType="sr" hash="-1106475955" locEndLn="14" goals="0," />
    <StdViol msg="Do not use reserved identifiers : _BUGDETECTIVE_SQL_H_" ln="3" locFile="/BugDetective/sql.h" locStartln="3" sev="2" auth="root" locRef="16" rule="MISRAC2012-RULE_21_1-a" lnHash="1264968809" rule.header="Do not #define or #undef identifiers with names which start with underscore" tool="c++test" lineHash="1264968809" unbViolId="73a7c64a-06ef-3bbf-ad65-4eb6d113deec" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4e7d52c2-f454-3b50-ae8a-e4039477924e" locEndPos="1" locType="sr" hash="-1897154214" locEndLn="3" goals="0," />
    <StdViol msg="Use type from stdint.h instead of declaring your own type 'SQLCHAR'" ln="11" locFile="/BugDetective/sql.h" locStartln="11" sev="4" auth="root" locRef="16" rule="MISRAC2012-DIR_4_6-c" lnHash="-1998022005" rule.header="Use typedefs from stdint.h instead of declaring your own in C99 code" tool="c++test" lineHash="-1998022005" unbViolId="24008e97-6da1-35d1-b506-ad71d04bb502" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4e5c3a9c-d99c-31c6-b233-283709285219" locEndPos="23" locType="sr" hash="-1897154214" locEndLn="11" goals="0," />
    <StdViol msg="Typedef name 'SQLCHAR' does not contain any digits indicating the size" ln="11" locFile="/BugDetective/sql.h" locStartln="11" sev="4" auth="root" locRef="16" rule="MISRAC2012-DIR_4_6-a" lnHash="-1998022005" rule.header="typedefs to basic types should contain some digits in their name" tool="c++test" lineHash="-1998022005" unbViolId="1882a86e-c1c8-3f95-bf57-23fc83b7a4d8" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b74c0a6a-68d2-334c-bab4-cc6cce6d25ac" locEndPos="23" locType="sr" hash="-1897154214" locEndLn="11" goals="0," />
    <StdViol msg="Use type from stdint.h instead of declaring your own type 'SQLINTEGER'" ln="12" locFile="/BugDetective/sql.h" locStartln="12" sev="4" auth="root" locRef="16" rule="MISRAC2012-DIR_4_6-c" lnHash="-993144710" rule.header="Use typedefs from stdint.h instead of declaring your own in C99 code" tool="c++test" lineHash="-993144710" unbViolId="c9b92e37-e1a9-3fef-8809-7633fff9b26e" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7d65ac12-1e44-32dc-a5fc-90c810aa6594" locEndPos="14" locType="sr" hash="-1897154214" locEndLn="12" goals="0," />
    <StdViol msg="Typedef name 'SQLINTEGER' does not contain any digits indicating the size" ln="12" locFile="/BugDetective/sql.h" locStartln="12" sev="4" auth="root" locRef="16" rule="MISRAC2012-DIR_4_6-a" lnHash="-993144710" rule.header="typedefs to basic types should contain some digits in their name" tool="c++test" lineHash="-993144710" unbViolId="ee1be628-1960-363d-b06f-17008d695c69" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1c1c5fcb-d7fe-3059-bbfd-e93aead16e97" locEndPos="14" locType="sr" hash="-1897154214" locEndLn="12" goals="0," />
    <StdViol msg="Use type from stdint.h instead of declaring your own type 'SQLSMALLINT'" ln="20" locFile="/BugDetective/sql.h" locStartln="20" sev="4" auth="root" locRef="16" rule="MISRAC2012-DIR_4_6-c" lnHash="-1144362146" rule.header="Use typedefs from stdint.h instead of declaring your own in C99 code" tool="c++test" lineHash="-1144362146" unbViolId="11f08afa-dca3-376e-9346-4acf9cf84993" locStartPos="14" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f50e1c60-b986-38d2-bf4d-3b89039a1fce" locEndPos="15" locType="sr" hash="-1897154214" locEndLn="20" goals="0," />
    <StdViol msg="Typedef name 'SQLSMALLINT' does not contain any digits indicating the size" ln="20" locFile="/BugDetective/sql.h" locStartln="20" sev="4" auth="root" locRef="16" rule="MISRAC2012-DIR_4_6-a" lnHash="-1144362146" rule.header="typedefs to basic types should contain some digits in their name" tool="c++test" lineHash="-1144362146" unbViolId="1dcff2c5-650f-348e-b616-10f4eda5e932" locStartPos="14" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="41435846-88fb-31bf-ac3e-11def5aab307" locEndPos="15" locType="sr" hash="-1897154214" locEndLn="20" goals="0," />
  </StdViols>

      <TestedFilesDetails>
         <Total name="Total (Suppressed)" supp="0" total="489">
            <Project id="BugDetective" name="BugDetective" supp="0" total="489">
               <Res loc="/BugDetective/arrayOutOfBounds.c" locRef="1" locType="sr" name="arrayOutOfBounds.c" supp="0" total="37" />
               <Res loc="/BugDetective/bufferOverflow.c" locRef="2" locType="sr" name="bufferOverflow.c" supp="0" total="28" />
               <Res loc="/BugDetective/dbutil.c" locRef="3" locType="sr" name="dbutil.c" supp="0" total="12" />
               <Res loc="/BugDetective/divisionByZero.c" locRef="4" locType="sr" name="divisionByZero.c" supp="0" total="54" />
               <Res loc="/BugDetective/fileLeaks.c" locRef="5" locType="sr" name="fileLeaks.c" supp="0" total="41" />
               <Res loc="/BugDetective/integerOverflow.c" locRef="6" locType="sr" name="integerOverflow.c" supp="0" total="31" />
               <Res loc="/BugDetective/memoryLeaks.c" locRef="7" locType="sr" name="memoryLeaks.c" supp="0" total="34" />
               <Res loc="/BugDetective/nullPointerDeref.c" locRef="8" locType="sr" name="nullPointerDeref.c" supp="0" total="29" />
               <Res loc="/BugDetective/nullPointerDerefBenchmark.c" locRef="9" locType="sr" name="nullPointerDerefBenchmark.c" supp="0" total="85" />
               <Res loc="/BugDetective/sql.c" locRef="10" locType="sr" name="sql.c" supp="0" total="4" />
               <Res loc="/BugDetective/sqlInjection.c" locRef="11" locType="sr" name="sqlInjection.c" supp="0" total="22" />
               <Res loc="/BugDetective/unreachableCode.c" locRef="12" locType="sr" name="unreachableCode.c" supp="0" total="45" />
               <Res loc="/BugDetective/useBeforeInit.c" locRef="13" locType="sr" name="useBeforeInit.c" supp="0" total="46" />
               <Res loc="/BugDetective/dbutil.h" locRef="14" locType="sr" name="dbutil.h" supp="0" total="8" />
               <Res loc="/BugDetective/socket.h" locRef="15" locType="sr" name="socket.h" supp="0" total="6" />
               <Res loc="/BugDetective/sql.h" locRef="16" locType="sr" name="sql.h" supp="0" total="7" />
            </Project>
         </Total>
      </TestedFilesDetails>
   </CodingStandards>
   <Statistics>
      
   </Statistics>
</ResultsSession>
